This is an example of reducing memory by eliminating intermediate arrays.

The code is based on one of the key algorithms in the Large Eddy Simulator for Urban Flows.

The simulator performs the following actions at every timestep (the number in parentheses is the number of full-domain 3-D arrays used):
- Set initial boundary conditions for wind velocity and pressure (4)
- Calculate the turbulent flow using the marker-and-cell method: based on the velocity fields u,v,w calculate the convection components and from this calculates the force fields f,g,h. (37)
- Integrate the force fields over time (Adams-Bashfort) (6)
- Solve the Poisson equation for the pressure using successive over-relatation (6)

In the original code, the turbulent flow algorithm uses the following 3-D arrays, 37 in total:

u,v,w
f,g,h
diu 1..9 for partial derivatives of the velocity
nou 1..9 for interpolated values
cov 1..9 for convection components
df{u,v,w}1 for updating the force fields with their derivatives 
sm 

Of these 37 arrays, only u,v,w are actual inputs to the calculation and f,g,h computed outputs. 

Our memory reduction approach eliminates the 31 intermediate arrays entirely. In the other algorithms, there are no redundant arrays. 

To illustrate the impact: assuming the GPU has 4GB of memory, then the maximum domain  for the original code was 100 MB, which translates to a domain of about 400x400 points.
After removal of the intermediate arrays, the domain can be up to 1000x1000 points.
As all redundant array accesses are replace by register accesses in the GPU, the resulting code is not only more memory efficient but also faster.

The work flow is as follows:
1. In ~/Research/DPRI/LEScode/OriginalSourcesF77: run `refactorF4Acc.pl -c ../rf4a.cfg`
    This will generated refactored code in RefactoredSourcesV11
2. In ~/Git/MPI-LES: run `./copy_refactored_src_from_OriginalSourcesF77.sh`
    This will copy the refactored sources in to src-for_MemoryReduction
3. In ~/Git/MPI-LES: run `perl aux/generate_and_build_OpenCL_version.pl --stage autopar --srcdir src-for_MemoryReduction --refsrcdir generated-src-for_MemoryReduction`
4. In ~/Git/MPI-LES/generated-src-for_MemoryReduction:
    `cp module_adam_bondv1_feedbf_les_press_v_etc_superkernel.f95 ~/Git/RefactorF4Acc/tests/velfg_memory_reduction/module_velfg_superkernel.f95`
5. In ~/Git/RefactorF4Acc/tests/velfg_memory_reduction/:
    - Manually edit the file to remove anything that wil not work
    - run `memory_reduction.pl`. This should create the reduced file
6. In ~/Git/RefactorF4Acc/tests/velfg_memory_reduction/MemoryReduction/Generated:
    - Run the inliner, TODO!
7. TODO create a code to drive this and compare with the original version    

It looks like I actually did a better version in  ~/Git/MPI-LES/generated-src-for_MemoryReduction/Work but still needs to run the inliner.
The inliner will run if there are !$RF4A Inline pragmas. These are generated by `MemoryReduction-exe` 

See `/home/wim/Git/RefactorF4Acc/tests/SOR_unroll/aux/generate_and_build_OpenCL_version.pl`, 

refactorF4acc.pl '.$vflag.' -c rf4a_inline.cfg

# Create `rf4a_inline.cfg` 
    my $rf4a_inline = <<ENDCFG;
# Relative path to the original Fortran source code
SRCDIRS = Generated
# Relative path to the refactored Fortran source code
NEWSRCPATH = ../../mem_reduced_inlined$suffix
# Name of the subroutine to start from. If this is the main program, leave blank.
# TOP = 
EXT = .f95
RENAME_PARS_IN_INLINED_SUBS = 0
RENAME_VARS_IN_INLINED_SUBS = 0
ONE_SUB_PER_MODULE = 0
ENDCFG

    open my $CFG, '>', 'rf4a_inline.cfg';
    print $CFG $rf4a_inline;
    close $CFG;

    say($ENV{HOME}.'/Git/RefactorF4Acc/bin/'.'refactorF4acc.pl '.$vflag.' -c rf4a_inline.cfg');
    system($ENV{HOME}.'/Git/RefactorF4Acc/bin/'.'refactorF4acc.pl '.$vflag.' -c rf4a_inline.cfg');

So, in Work/MemoryReduction I did the following:

* In Scalarised:
  - edited the files to add parameter declarations, 
  - then ran `gfortran -ffree-line-length-0 -c velfg_map_*.f95` to create `.mod` files
* In Generated  
  - edited `module_gen_velfg_superkernel.f95` because some scalars have an Intent but they are not toplevel args. Size was only 47K, 562 loc
  - Compiling with `gfortran -Ofast -ffree-line-length-0 -c module_velfg_superkernel.f95` (after manual removal of incorrect Intents) gives a 13K .o 

  - then ran `gfortran -I ../Scalarized/ -ffree-line-length-0 -c module_gen_velfg_superkernel.f95`
  - This generates a 15K .mod and a 171K .o file, no errors
* In Work/MemoryReduction
- `mkdir ../mem_reduced_inlined`
- created the `rf4a_inline.cfg`  file
- `refactorF4acc.pl -c ./rf4a_inline.cfg` => LOTS of warnings!
- `rm ../mem_reduced_inlined/Generated/f_*`
- `rm ../mem_reduced_inlined/Generated/module_gen_velfg_superkernel.f95`
- Final result is in `../mem_reduced_inlined/Generated/stage_kernel_1.f95`
- Size is 87K, 2796 loc;
- Compiling with `gfortran -Ofast -ffree-line-length-0 -c stage_kernel_1.f95` generates a 54K .o (same for -O3; -O2 51K; -O1 64K)

There is still a lot more wrong with the generated code. The main thing is that stage_kernel should take arrays rather than scalars. This is OK for the inputs but wrong for the outputs, what gives? Need to check if this was already the case before inlining!

The scalarised function is currently in a module with the same name as the wrapper. So I'll need to rename them with _scal