#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Making Legacy Fortran Code Type Safe through Source-to-source Compilation
\end_layout

\begin_layout Author
Wim Vanderbauwhede
\end_layout

\begin_layout Abstract
In this paper we present the program transformations and type checking algorithm
s required to convert FORTRAN 77 subroutines and functions into pure, side-effec
t free subroutines and functions in Fortran 90.
 The resulting code is type safe and the pure, side-effect free and referentiall
y transparent subroutines can readily be offloaded to accelerators.
 
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Fortran still matters
\end_layout

\begin_layout Standard
Show bibliographic data, Archer load, see other paper
\end_layout

\begin_layout Subsection
Acceleration by offloading matters
\end_layout

\begin_layout Standard
Hardware accelerators have proven extremely effective in accelerating scientific
 code.
 Of the Green Top 10 (https://www.top500.org/lists/green500/2019/11/), 8 systems
 use accelerators.
 However, in practice the accelertors have their own memory, and the most
 common compute model is still to offload part of the calculation to the
 accelerator and copy the results back to the host memory.
 Even if the accelerator is cache-coherent with the host memory, having
 the code to be run on the accelertor in a separate memory space is still
 advantageous as it results in reduced coherency traffic.
\end_layout

\begin_layout Standard
Cite success of heterogeneous supercomputers etc
\end_layout

\begin_layout Subsection
The need for pure functions
\end_layout

\begin_layout Standard
Therefore we need self-contained ("pure") functions
\end_layout

\begin_layout Standard
- no shared memory space - no system calls - no library calls except intrinsic
 ones - no I/O
\end_layout

\begin_layout Subsection
The case for type safety
\end_layout

\begin_layout Standard
In his paper, 
\begin_inset Quotes eld
\end_inset

A Theory of Type Polymorphism in Programming
\begin_inset Quotes erd
\end_inset

 [REF], Robin Milner expressed the notion of type safety as “Well typed
 programs cannot go wrong.” By 
\begin_inset Quotes eld
\end_inset

going wrong
\begin_inset Quotes erd
\end_inset

 we mean in general not computing the expected result.
 There are several components contributing to this behaviour: one is the
 language's type system, the other is the type checker, and finally there
 is the actual program code.
 
\end_layout

\begin_layout Standard
In a type-safe language, the language’s type system ensures programs cannot
 perform operations that are not compatible with the types of the operands
 involved, i.e.
 there are no type errors in a well-typed program written in a type-safe
 language.
 By type error we mean an error arising from the fact that a variable (or
 constant or function) with a given type is treated as if it has a different
 type.
 
\end_layout

\begin_layout Standard
A type checker is called 
\emph on
sound 
\emph default
if it only accepts correctly typed programs.
 However, the fact that a sound typechecker accepts a correctly typed program
 does not mean the program is correct.
 
\end_layout

\begin_layout Standard
In the context of Fortran, the type system as specified in 
\begin_inset Quotes eld
\end_inset

ANSI X3.9-1978 – American National Standard Programming Language FORTRAN
\begin_inset Quotes erd
\end_inset

 [REF], hereafter called the 
\begin_inset Quotes eld
\end_inset

f77 specification
\begin_inset Quotes erd
\end_inset

, is not type-safe.
 It is possible to write programs which the type checker accepts but are
 nonetheless incorrect.
 The key culprit for this is the type erasure which happens when data is
 handled via COMMON or EQUIVALENCE.
 The subset of Fortran 90 which we target in this paper, and which we can
 loosely define as FORTRAN 77 without COMMON or EQUIVALENCE statements,
 with pure functions and referential transparency, and using Fortran 90
 style type declarations, is type safe and well typed programs in this subset
 will not go wrong if they are accepted by the type checker.
 
\end_layout

\begin_layout Standard
Therefore, if we can extended the FORTRAN 77 type system to be type-safe,
 then programs accepted by the extended type checker are well typed.
 If these programs are
\end_layout

\begin_layout Standard
automatically converted into code written in this Fortran 90 subset, then
 an ordinary Fortran compiler can be used as the type checker with all type-base
d warnings turned into errors, and the code will type check cleanly.
 
\end_layout

\begin_layout Standard
This paper presents such an extended type system and type checks as well
 as the algorithms required to convert FORTRAN 77 into type-safe Fortran
 90.
\end_layout

\begin_layout Section
Related work: 
\end_layout

\begin_layout Standard
see earlier paper, be nice to CamFort
\end_layout

\begin_layout Section
Preliminaries
\end_layout

\begin_layout Subsection
Type systems concepts and notation
\end_layout

\begin_layout Standard
A type is a formal mechanism to provide information about the expected form
 of the result of a computation.
 More precisely, 
\end_layout

\begin_layout Standard
if 
\emph on
e
\emph default
 is an expression, a 
\emph on
typing 
\emph default
of for e.g.
 
\begin_inset Formula $e:\mathrm{integer}$
\end_inset

 is an assertion that when 
\emph on
e
\emph default
 is evaluated, its value will be an integer.
 Such an assertion is called a typing judgment.
 For such a typing judegement to be meaningful, e must be well typed.
 For any expression this means that it must be internally consistent as
 well as consistent with its context, i.e.
 if it contains free variables, they must be declared with the right type
 in the context of the code unit.
 We will use the terms 
\emph on
type statement
\emph default
 (as used in the f77 specification) or 
\emph on
type declaration
\emph default
 (more common in type theory) for the statements that declare the type of
 a constant, variable or function.
\end_layout

\begin_layout Standard
We will use set theory to construct the sets of valid types for FORTRAN
 77, and the standard notation for typing rules as used for example in [REF
 Pierce].
 
\end_layout

\begin_layout Standard
In summary:
\end_layout

\begin_layout Itemize
The assertion 
\begin_inset Quotes eld
\end_inset

the expression 
\emph on
e
\emph default
 has type 
\begin_inset Formula $\tau$
\end_inset


\begin_inset Quotes erd
\end_inset

 is written as 
\begin_inset Formula $e:\tau$
\end_inset


\end_layout

\begin_layout Itemize
If an assertion must hold for a certain context, i.e.
 a set of expressions with declared types such as a code unit, the context
 is conventionally denoted as 
\begin_inset Formula $\Gamma$
\end_inset

 and the operator 
\begin_inset Formula $\vdash$
\end_inset

 (called 
\begin_inset Quotes eld
\end_inset

turnstyle
\begin_inset Quotes erd
\end_inset

 in type theory) is used to write an assertion of the form 
\begin_inset Quotes eld
\end_inset

assuming a context 
\begin_inset Formula $\Gamma$
\end_inset

 then the expression 
\emph on
e
\emph default
 has type 
\begin_inset Formula $\tau$
\end_inset


\begin_inset Quotes erd
\end_inset

 is written as 
\begin_inset Formula $\Gamma\vdash e:\tau$
\end_inset

 .
\end_layout

\begin_layout Itemize
The type of a function of a single argument is written as 
\begin_inset Formula $f:\tau_{in}\rightarrow\tau_{out}$
\end_inset

 and the function itself is written without parentheses, so 
\begin_inset Formula $y=f\,x$
\end_inset

 rather than 
\begin_inset Formula $y=f(x)$
\end_inset

.
\end_layout

\begin_layout Itemize
We will write the type declaration for a tuple (ordered set) of 
\emph on
m
\emph default
 expressions as 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $(e_{1},...,e_{m}):(\tau_{1},...,\tau_{m})$
\end_inset

 or for brevity as 
\begin_inset Formula $\mathbf{e_{m}}:\mathbf{T_{m}}$
\end_inset

.
\end_layout

\begin_layout Standard
We deviate slightly from the terminology used in the f77 specification in
 favour of the more common terminology: we will refer to the symbolic name
 of a datum as a variable rather than a variable name, and we will refer
 to what the f77 specification calls a variable as a scalar.
 Thus a variable can be a scalar or an array.
 
\end_layout

\begin_layout Subsection
The definition of a pure function
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-definition-of"

\end_inset


\end_layout

\begin_layout Standard
In the context of Fortran, we can without loss of generality assume that
 a function takes as a single argument a tuple of expressions, and returns
 a tuple of expressions.
 This lets us simplify the notation somewhat.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\Gamma$
\end_inset

 be the context of a given program, i.e.
 the set of all variables with their type that are declared in a code unit:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Gamma=\{...,x_{i}:\tau_{i},...\}
\]

\end_inset


\end_layout

\begin_layout Standard
Consider a function 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
f:(\tau_{in,1},...,\tau_{in,k}) & \rightarrow & (\tau_{out,1},...,\tau_{out,m})\\
(x_{out,1},...,x_{out,m}) & = & f\,(x_{in,1},...,x_{in,k})
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
or shorter
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
f:\mathbf{T_{in,k}} & \rightarrow & \mathbf{T_{out,m}}\\
\mathbf{x_{out,k}} & = & f\,\mathbf{x_{in,m}}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
This function is 
\emph on
pure
\emph default
 iff
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\forall\,\Gamma,\forall\mathbf{x_{in,k}}\in\Gamma,\exists!\,\mathbf{x_{out,m}}\in\Gamma:\mathbf{x_{out,m}}=f\mathbf{\,x_{in,k}}
\]

\end_inset


\end_layout

\begin_layout Standard
In words, for any given environment 
\begin_inset Formula $\Gamma$
\end_inset

 where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbf{x_{in,k}}$
\end_inset

 and 
\begin_inset Formula $\mathbf{x_{out,m}}$
\end_inset

 are declared
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
, then if 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbf{x_{in,k}}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 is a given set of argument values of the correct type, the function will
 always return the same value 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbf{x_{out,m}}$
\end_inset

 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
regardless of the rest of the content of 
\begin_inset Formula $\Gamma$
\end_inset

.
 We will see in Section XXX and following how any Fortran subroutine can
 be transformed into a pure function.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The type 
\begin_inset Formula $\mathbf{T_{m}}$
\end_inset

 is a tuple of valid Fortran types, as introduced.
 We therefore extend our type system with the notion of a tuple:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\mathit{Tuple}=(\tau_{1},...,\tau_{i},...,\tau_{k}),\,\forall\,i\,\in[1,k]\,|\,\tau_{i}\in\mathit{FortranType}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
How type-safe is FORTRAN 77?
\end_layout

\begin_layout Standard
We start by considering a FORTRAN 77 program that consists of pure functions
 or subroutines (see below for a formal definition) and where all variables,
 parameters and functions are explicitly typed.
 We will see later how to achieve fully explicity typing and under which
 conditions a subroutine or function can be made pure.
 
\end_layout

\begin_layout Standard
According to §4.1 
\begin_inset Quotes eld
\end_inset

Data Types
\begin_inset Quotes erd
\end_inset

 of the f77 specification, the six types of data are:
\end_layout

\begin_layout Enumerate
Integer
\end_layout

\begin_layout Enumerate
Real
\end_layout

\begin_layout Enumerate
Double precision
\end_layout

\begin_layout Enumerate
Complex
\end_layout

\begin_layout Enumerate
Logical
\end_layout

\begin_layout Enumerate
Character
\end_layout

\begin_layout Standard
The f77 specification discusses each of these types in terms of their 
\emph on
storage units
\emph default
.
 According to §2.13 
\begin_inset Quotes eld
\end_inset

Storage
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

A storage unit is either a numeric storage unit or a character storage unit.
 An integer, real, or logical datum has one numeric storage unit in a storage
 sequence.
 A double precision or complex datum has two numeric storage units in a
 storage sequence.
 A character datum has one character storage unit in a storage sequence
 for each character in the datum.
 This standard does not specify a relationship between a numeric storage
 unit and a character storage unit.
 If a datum requires more than one storage unit in a storage sequence, those
 storage units are consecutive.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
An integer or real has one storage unit
\end_layout

\begin_layout Itemize
A 
\emph on
double precision
\emph default
 datum has two consecutive numeric storage units in a storage sequence (§4.5
 Double Precision Type).
\end_layout

\begin_layout Itemize
A 
\emph on
complex
\emph default
 datum is a processor approximation to the value of a complex number.
 The representation of a complex datum is in the form of an ordered pair
 of real data.
 The first of the pair represents the real part of the complex datum and
 the second represents the imaginary part.
 Each part has the same degree of approximation as for a real datum.
 A complex datum has two consecutive numeric storage units in a storage
 sequence; the first storage unit is the real part and the second storage
 unit is the imaginary part (§4.6 Complex Type).
\end_layout

\begin_layout Standard
As quoted above, the f77 specification does not specify the size of a storage
 unit.
 However, the consensus amongst Fortran compilers is as follows:
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size in bytes (Kind)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
#Storage Units (numeric)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Real
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Double precision
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Complex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Logical
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size in bytes 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
#Storage Units (character)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Relationship between storage unit, kind and bytes for FORTRAN 77 types.
\begin_inset CommandInset label
LatexCommand label
name "tab:Relationship-between-storage"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Various extensions exists such as Byte, Double complex etc.
 Technically, the use of Kinds in type declarations (e.g.
 integer*8) is not part of the f77 specification.
 It is however widely used and supported by all current Fortran compilers,
 specifically the open source GNU Fortran compiler g77.
 In this paper we effectively consider FORTRAN 77 to be defined by the f77
 specification combined with the g77 extensions https://gcc.gnu.org/onlinedocs/gcc
-3.4.6/g77/Language.html.
 
\end_layout

\begin_layout Standard
We will treat the kind as the number of bytes of storage as in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Relationship-between-storage"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and define the scalar types as (Typename, Kind) tuples.
 Moreover, we define a character storage unit as 1 byte.
 This allows us the simplify the types to integer, real, complex and logical,
 because we can define a double precision as (real,8) and a character as
 (integer,1).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Double precision: (real,8)
\end_layout

\begin_layout Plain Layout
Complex: ((real,4),(real,4)) – not sure!
\end_layout

\begin_layout Plain Layout
Double Complex ((real,8),(real,8)) – not sure!
\end_layout

\begin_layout Plain Layout
Character: (integer,1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the rest of the discussion we will treat the character type as an integer
 with a kind of 1 and a character string as an array of characters.
\end_layout

\begin_layout Subsubsection
The FORTRAN 77 type system
\end_layout

\begin_layout Standard
With the above conventions and assumptions, we can describe Fortran's type
 system as show in Alg 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:The-FORTRAN-77"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
Type = 
\begin_inset Formula $\left\{ Integer,Real,Complex,Logical\right\} $
\end_inset

 
\end_layout

\begin_layout Plain Layout
NumType = 
\begin_inset Formula $\left\{ Integer,Real,Complex\right\} $
\end_inset

 
\end_layout

\begin_layout Plain Layout
Kind = 
\begin_inset Formula $\left\{ 2^{n}|\;n\in[0,5]\right\} $
\end_inset


\end_layout

\begin_layout Plain Layout
Scalar = 
\begin_inset Formula $\left\{ Type\times Kind\right\} $
\end_inset

, and we denote an element of this set as 
\emph on
Scalar t k
\end_layout

\begin_layout Plain Layout
Num = 
\begin_inset Formula $\left\{ NumType\times Kind\right\} $
\end_inset

, and we denote an element of this set as 
\emph on
Num a
\end_layout

\begin_layout Plain Layout
Bool= 
\begin_inset Formula $\left\{ Logical\times Kind\right\} $
\end_inset

, and we denote an element of this singleton set as 
\emph on
Bool
\end_layout

\begin_layout Plain Layout
Dim =
\begin_inset Formula $\left\{ ((b_{i},e_{i}),...,(b_{i},e_{i}),...,(b_{k},e_{k})),\forall k,i\in\,[1,7],b_{i},e_{i}\in\mathbb{Z},b_{i}\le e_{i}\right\} $
\end_inset

, so Dim is a set of ordered sets of tuples, we denote an element as 
\emph on
Dim d
\end_layout

\begin_layout Plain Layout
Array = 
\begin_inset Formula $\left\{ Scalar\times Dim\right\} $
\end_inset

, and we denote an element of this set as 
\emph on
Array (Scalar t k) (Dim d)
\end_layout

\begin_layout Plain Layout
FortranType = 
\begin_inset Formula $Scalar\cap Array$
\end_inset

 
\end_layout

\begin_layout Plain Layout
Tuple = 
\begin_inset Formula $(\tau_{1},...,\tau_{i},...,\tau_{k}),\,\forall\,i\,\in[1,k]\,|\,\tau_{i}\in\mathit{FortranType}$
\end_inset

 and we'll write 
\emph on
Tuple t
\emph default
, where 
\begin_inset Formula $t=(\tau_{1},...,\tau_{k})$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The FORTRAN 77 type system for scalars and arrays
\begin_inset CommandInset label
LatexCommand label
name "alg:The-FORTRAN-77"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
To investigate the type safety, we need to consider the typing rules for
\end_layout

\begin_layout Itemize
constants
\end_layout

\begin_layout Itemize
scalar and array declarations and accesses
\end_layout

\begin_layout Itemize
function and subroutine declarations and applications
\end_layout

\begin_layout Itemize
expressions
\end_layout

\begin_layout Itemize
assignments
\end_layout

\begin_layout Subsubsection
Constants
\end_layout

\begin_layout Standard
The forms of numeric constants are described in words in §4 of the f77 specifica
tion.
 Using Extended Backus-Naur Form
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "https://www.w3.org/TR/2008/REC-xml-20081126/#sec-notation"

\end_inset


\end_layout

\end_inset

, we can describe them formally as show in Alg 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:EBNF-for-numeric"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout LyX-Code
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout LyX-Code
integer-constant ::= [sign] {digit}+ 
\end_layout

\begin_layout LyX-Code
sign ::= + | -
\end_layout

\begin_layout LyX-Code
digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
real-constant ::= [sign] {digit}* decimal-point {digit}* [real-exponent]
\end_layout

\begin_layout LyX-Code
| [sign] {digit}+ [decimal-point {digit}*] real-exponent
\end_layout

\begin_layout LyX-Code
decimal-point ::= .
\end_layout

\begin_layout LyX-Code
real-exponent ::= E [sign] {digit}+
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
double-constant ::= [sign] {digit}* decimal-point {digit}* [double-exponent]
\end_layout

\begin_layout LyX-Code
| [sign] {digit}+ [decimal-point {digit}*] double-exponent
\end_layout

\begin_layout LyX-Code
double-exponent ::= D [sign] {digit}+
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
complex-constant ::== ( real-constant , real-constant )
\end_layout

\begin_layout LyX-Code
logical-constant ::== .TRUE.
 | .FALSE.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
EBNF for numeric constants
\begin_inset CommandInset label
LatexCommand label
name "alg:EBNF-for-numeric"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
We define the set of constants of for each type, for example for integers:
\end_layout

\begin_layout Standard
IntegerConstants = 
\begin_inset Formula $\left\{ n\,|\,n\,\textrm{is an integer-constant}\right\} $
\end_inset


\end_layout

\begin_layout Standard
and thus we can write the typing rule
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{n\,:\,Integer}.\,\forall\,n\in\mathit{IntegerConstants}
\]

\end_inset


\end_layout

\begin_layout Description
and similar for the other types.
\end_layout

\begin_layout Subsubsection
Scalars
\end_layout

\begin_layout Standard
The typing rule for a scalar 
\emph on
s
\emph default
 is simply that any access of a scalar variable, this variable must have
 the same type, which must be the type from its declaration in the current
 contex (code unit) 
\begin_inset Formula $\Gamma$
\end_inset

 and belong to the set 
\emph on
Scalar
\emph default
.
 we write this as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\Gamma\vdash s:\tau_{s}=Scalar\,t\,k}
\]

\end_inset


\end_layout

\begin_layout Standard
What this means is that, given the context 
\begin_inset Formula $\Gamma$
\end_inset

 which contains all types of all variables valid in a given expression,
 the type judegement is valid.
 In a Fortran expression this means that all variables with a type statement
 in a code unit will be of the type determined by that statement.
 
\end_layout

\begin_layout Subsubsection
Arrays
\end_layout

\begin_layout Standard
The typing rule for an array declaration is that in addition to being of
 a valid Scalar type 
\end_layout

\begin_layout Itemize
it must have a non-empty Dim set, 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\frac{\,}{\Gamma\vdash a:\tau_{a}=Array\,(Scalar\,t_{a}\,k_{a})\ (Dim\,d)}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $d=((b_{1},e_{i}),...,(b_{i},e_{i}),...,(b_{k},e_{k}))$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
and for any array access 
\begin_inset Formula $a(j_{1},...,j_{k}),j_{i}\in[b_{i},e_{i}]$
\end_inset

 that
\end_layout

\begin_layout Itemize
the number indices must 
\begin_inset Formula $k=\#d$
\end_inset

, 
\end_layout

\begin_layout Itemize
the type must be the scalar type:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\frac{\Gamma\vdash a:\tau_{a}\;\;\;\Gamma\vdash j_{i}:Integer,\forall\,i\in[1,k]}{\Gamma\vdash a(j_{1},...,j_{i},...,j_{k}):\tau_{s}=Scalar\,t_{a}\,k_{a}}
\end{align*}

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Note that the additional condition of validity of the range of the array
 indices 
\begin_inset Formula $a(j_{1},...,j_{i},...,j_{k}),\,\forall\,i\in[1,k]|j_{i}\in[b_{i},e_{i}]$
\end_inset

 is not a type checking condition but an run-time range checking condition,
 so it is not part of the typing rules.
\end_layout

\begin_layout Paragraph
Array Slicing
\end_layout

\begin_layout Standard
Fortran allows array slicing using the notation 
\begin_inset Formula $(b_{s}:e_{s}:s_{s})$
\end_inset

.
 For example:
\end_layout

\begin_layout LyX-Code
integer a, s
\end_layout

\begin_layout LyX-Code
dimension a(5,7), s(3)
\end_layout

\begin_layout LyX-Code
s = a(2,1:5:2)
\end_layout

\begin_layout Standard
The array s will be populated with the values from a(2,1) ,a(2,3) and a(2,5).
 From a type checking perspective, we need to check if the slice has the
 correct type, in this case the same type as the array to which it is assigned.
\end_layout

\begin_layout Standard
For a given tuple 
\begin_inset Formula $(b_{i},e_{i})$
\end_inset

 from 
\emph on
d
\emph default
, a slice is valid (i.e.
 within bounds) if 
\begin_inset Formula $b_{s}\geq b_{i},e_{s}\leq e_{i},s_{s}\leq e_{i}-b_{i}$
\end_inset

.
 We will call the set of indices in the slice a DimSlice and it is given
 by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathit{DimSlice}=\left\{ idx|idx\in[b,e]\land(idx-b)\,mod\,%s=0
\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
and we'll denote this as 
\emph on
DimSlice b e s
\emph default
.
 
\end_layout

\begin_layout Standard
The type of a sliced array is determined from the 
\emph on
DimSlice
\emph default
 as follows: 
\end_layout

\begin_layout Itemize
let the array 
\emph on
a
\emph default
 have 
\emph on
Dim d
\emph default
, 
\begin_inset Formula $d=(p_{1},...,p_{i},...,p_{k})$
\end_inset

 and we slice 
\emph on
p_i
\emph default
 with a valid slice 
\begin_inset Formula $s_{i}=\mathit{DimSlice}\,b_{s}e_{s}s_{s}$
\end_inset

.
\end_layout

\begin_layout Itemize
Then this results in a new 
\begin_inset Formula $p'_{i}=(1,\#s_{i})$
\end_inset

 
\end_layout

\begin_layout Itemize
and therefore a new 
\emph on
Dim d
\emph default
', 
\begin_inset Formula $d'=(p_{1},...,p'_{i},...,p_{k})$
\end_inset

 
\end_layout

\begin_layout Itemize
and a new array type
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
\tau'_{a}=Array\,\tau_{s}\ (Dim\,d')
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
To be type safe, the size of the 
\emph on
DimSlice
\emph default
 must be known at type check time.
 This implies that the components 
\emph on
b,e,s
\emph default
 of the slice must be constant.
 If so, we can determin the size of the slice and thus check that the new
 type is correct given the context.
 
\end_layout

\begin_layout Paragraph
Arrays as indices
\end_layout

\begin_layout Standard
Fortran also allows arrays to be indexed by other arrays, for example
\end_layout

\begin_layout LyX-Code
       integer a(5,5), b(3), k(3)
\end_layout

\begin_layout LyX-Code
       k = (/ 1, 5, 2 /)
\end_layout

\begin_layout LyX-Code
       b = a(2, k)
\end_layout

\begin_layout Standard
The array b will contain the values a(2,1),a(2,5) and a(2,2) in that order.
\end_layout

\begin_layout Standard
The array to be used for indexing must be an array of rank 1 that contains
 the indices of the locations to be accessed, just like a 
\emph on
DimSlice
\emph default
.
 Thus the requirement for type safety is the same (the size of the array),
 and the criterion for the array to be valid for indexing is that all elements
 must be in the valid index range for the given array index.
\end_layout

\begin_layout Paragraph
Bounds checking
\end_layout

\begin_layout Standard
Fortran checks constant array bounds at type check time and our compiler
 performs a more aggressive constant folding so that any index reduceable
 to a constant with linear arithmetic will be considered constant.
 However, in general array indices are not known at type check time and
 therefore even in a well typed program, it is still possible to have out-of-bou
nd errors.
 Fundamentally, index checking is not type checking because it concerns
 the actual values, and has to be performed at run time.
 All modern Fortran compilers provide this option, e.g.
 -fcheck=bounds in the GNU gfortran.
\end_layout

\begin_layout Subsubsection
Subroutines and Functions
\end_layout

\begin_layout Standard
As explained below (Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-definition-of"
plural "false"
caps "false"
noprefix "false"

\end_inset

), every Fortran function or subroutine can be transformed into a pure function.
 From a type checking perspective, the only difference between a Fortran
 function and subroutine is that a function call can occur in an expression
 and a subroutine call can't.
 
\end_layout

\begin_layout Standard
Given a function 
\emph on
f
\emph default
, for any expression 
\emph on
e
\end_layout

\begin_layout LyX-Code
\begin_inset Formula $e=...f(...,a_{i},...)...$
\end_inset


\end_layout

\begin_layout Standard
we can always replace the function call 
\end_layout

\begin_layout LyX-Code
\begin_inset Formula $\tau$
\end_inset

 function 
\begin_inset Formula $f(...,a_{i}:\tau_{i},...)$
\end_inset

 
\end_layout

\begin_layout LyX-Code
\begin_inset Formula $...$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $f=...$
\end_inset


\end_layout

\begin_layout LyX-Code
end function
\end_layout

\begin_layout Standard
with a subroutine call with 
\begin_inset Formula $f$
\end_inset

 as an additional argument and as the final assigned variable: 
\end_layout

\begin_layout LyX-Code
subroutine 
\begin_inset Formula $sf(...,a_{i}:\tau_{i},...,f:\tau)$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $...$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $f=...$
\end_inset


\end_layout

\begin_layout LyX-Code
end subroutine
\end_layout

\begin_layout Standard
We call 
\emph on
sf
\emph default
 immediately before the expression is evaluated:
\end_layout

\begin_layout LyX-Code
call 
\begin_inset Formula $sf(...,a_{i},...,f)$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $e=...f...$
\end_inset


\end_layout

\begin_layout Standard
Therefore, in what follows we only discuss subroutines that behave as pure
 functions.
 We write these as explained in Section XXX, as functions from an input
 tuple of expressions to an output tuple of variables.
\end_layout

\begin_layout Standard
The subroutine declaration typing rule is that every dummy argument must
 be of a valid 
\emph on
FortranType
\emph default
.
 Using the tuple type notation from Section XXX, we write this as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
FortranType\,\mathbf{T_{k}},\mathbf{FortranType\,T_{m}}\Rightarrow sf:\mathbf{T_{k}}\rightarrow\mathbf{T_{m}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\[
sf(a_{1},...,a_{i},...,a_{m})\,|\,a_{i}:FortranType,\forall i\in[1,m],m\in\mathbb{N}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The double arrow (
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Rightarrow$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
) is read as 
\begin_inset Quotes eld
\end_inset

these constraints must apply to the types for the type judgement to hold
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
The subroutine application (call) typing rule is that every call argument
 and every dummy argument must have the same type.
 If that is the case, then because our subroutines are pure functions, we
 can derive the type of the return value of the function.
 
\end_layout

\begin_layout Standard
The rule for type checking a function call is in general
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{f:\tau_{i}\rightarrow\tau_{o}\;\;\;e:\tau_{i}}{f\,e:\tau_{o}}
\]

\end_inset


\end_layout

\begin_layout Standard
and specifically for a function from tuple to tuple
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{sf:\mathbf{T_{k}}\rightarrow\mathbf{T_{m}}\;\;\;\mathbf{\Gamma\vdash x_{k}}:\mathbf{T_{k}}}{\Gamma\vdash sf\,\mathbf{x_{k}}:\mathbf{T_{m}}}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Assignments
\end_layout

\begin_layout Standard
Because the assignment in Fortran is a statement, it does not return a type.
 Therefore, the type check rule for an assignment (
\begin_inset Formula $\leftarrow$
\end_inset

) of variable 
\emph on
x
\emph default
 declared in the context 
\begin_inset Formula $\Gamma$
\end_inset

 to an expression 
\emph on
e
\emph default
 which may contain any variable 
\begin_inset Formula $x_{i}$
\end_inset

 declared in the context 
\begin_inset Formula $\Gamma$
\end_inset

, is as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\vdash x:\tau\;\;\;\Gamma(x_{i})\vdash e(x_{i}):\tau}{\Gamma\vdash x\leftarrow e:\,void}
\]

\end_inset


\end_layout

\begin_layout Standard
Note that we are more strict than the Fortran specification, because we
 require the left-hand side and the right-hand side to be of the same type.
 This means that the implicit type coercions are made explicit following
 the rules form from Table 4 in the f77 specification.
\end_layout

\begin_layout Subsubsection
Expressions
\end_layout

\begin_layout Standard
Expressions can consist of constants, variables, operators and calls to
 intrinsic functions.
 With the transformation outlined above, expressions can always be rewritten
 so that they do not contain external function calls.
 
\end_layout

\begin_layout Itemize
Operators +,-,* and / all have the type 
\begin_inset Formula $Num\,a\Rightarrow a\rightarrow a\rightarrow a$
\end_inset

, which means that given that 
\emph on
a
\emph default
 is an element of 
\emph on
Num
\emph default
 (see XXX) then the operator takes two arguments of type 
\emph on
a
\emph default
 and returns an argument of type 
\emph on
a
\emph default
.
 As with the assignment, the implicit type coercion performed by the operators
 is replaced by an explicit conversion according to the rules in Tables
 2 and 3 in the f77 specification.
\end_layout

\begin_layout Itemize
The operator (**) has the same signature except when the exponent is an
 integer, in that case we have 
\begin_inset Formula $Kind\,k,\,Num\,a\Rightarrow a\rightarrow Scalar\,Integer\,k\rightarrow a$
\end_inset

 .
\end_layout

\begin_layout Itemize
Comparison operations .lt., .le.,.eq.,.ne.,.gt.,.ge.
 are all of type 
\begin_inset Formula $Num\,a\Rightarrow a\rightarrow a\rightarrow Bool$
\end_inset

,
\end_layout

\begin_layout Itemize
For the typechecking of intrinsic functions, we refer to Table 5 in the
 f77 specification.
 Intrinsics are either of type
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Num\,a\Rightarrow a\rightarrow a\rightarrow a$
\end_inset

 
\begin_inset Newline newline
\end_inset

except 
\begin_inset Formula $imag:Kind\,k\Rightarrow Scalar\,Complex\,k\rightarrow\rightarrow Scalar\,Real\,k$
\end_inset

 o
\end_layout

\begin_layout Itemize
\begin_inset Formula $Num\,a\Rightarrow a\rightarrow a\rightarrow a$
\end_inset

 except 
\begin_inset Newline newline
\end_inset


\begin_inset Formula $dprod:Scalar\,Real\,4\rightarrow Scalar\,Real\,4\rightarrow Scalar\,Real\,8$
\end_inset

 
\begin_inset Newline newline
\end_inset


\begin_inset Formula $amin0:Scalar\,Integer\,4\rightarrow Scalar\,Integer\,4\rightarrow Scalar\,Real\,4$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $min1:Scalar\,Real\,4\rightarrow Scalar\,Real\,4\rightarrow Scalar\,Integer\,4$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
The expression forms a tree and type checking is performed via recursive
 descent, for example for the + operator:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{Num\,a\;\;\;\Gamma\vdash e_{1}:a\;\;\;\Gamma\vdash e_{2}:a}{\Gamma\vdash e_{1}+e_{2}:\,a}
\]

\end_inset


\end_layout

\begin_layout Subsection
Transforming Fortran subroutines into pure functions
\end_layout

\begin_layout Standard
A FORTRAN 77 subroutine can be translated into a pure function as follows:
 
\end_layout

\begin_layout Itemize
infer the INTENT of every argument (see Section XXX)
\end_layout

\begin_layout Itemize
replace every InOut argument with an (In,Out) tuple
\end_layout

\begin_layout Itemize
every read is from the In argument, every write is to the Out argument
\end_layout

\begin_layout Standard
Thus,
\end_layout

\begin_layout LyX-Code
subroutine 
\begin_inset Formula $f(a_{1},...,a_{i},...,a_{n})$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $\tau_{i},$
\end_inset

intent(InOut)
\begin_inset Formula $::a_{i}$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $(...,a_{i},...,...,l_{i},...)=exp(...,a_{i},...,...,l_{i},...)$
\end_inset


\end_layout

\begin_layout LyX-Code
end subroutine 
\begin_inset Formula $f$
\end_inset


\end_layout

\begin_layout Standard
becomes
\end_layout

\begin_layout LyX-Code
subroutine 
\begin_inset Formula $f'(a_{1},...,a_{i,in},a_{i,out},...,a_{n})$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $\tau_{i},$
\end_inset

intent(In)
\begin_inset Formula $::a_{i,in}$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $\tau_{i},$
\end_inset

intent(Out)
\begin_inset Formula $::a_{i,out}$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $\tau_{i}::a_{i}$
\end_inset

! local
\end_layout

\begin_layout LyX-Code
\begin_inset Formula $a_{i}=a_{i,in}$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $(...,a_{i},...,...,l_{i},...)=exp(...,a_{i},...,...,l_{i},...))$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $a_{i,out}=a_{i}$
\end_inset


\end_layout

\begin_layout LyX-Code
end subroutine 
\begin_inset Formula $f'$
\end_inset


\end_layout

\begin_layout Standard
Let us denote the transformed argument list as 
\emph on
a'
\emph default
, so 
\begin_inset Formula $(a_{i}\in a'|\textrm{intent}(a_{i})=\textrm{InOut})=\emptyset$
\end_inset


\end_layout

\begin_layout Standard
Given the intent, then we have:
\end_layout

\begin_layout LyX-Code
\begin_inset Formula $y=(a_{i}\in a'|\textrm{intent}(a_{i})=\textrm{Out})$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $a''=a'\ \backslash\ y$
\end_inset


\end_layout

\begin_layout Standard
The type of 
\emph on
y
\emph default
 is the 
\emph on
Tuple
\emph default
 of the types of all arguments with intent Out.
 In this way we have identified the function arguments and the function
 return value and their types.
 So regardless of the subroutine syntax, with this information it is now
 a pure function as far as its arguments are concerned.
 
\end_layout

\begin_layout Subsection
Explicit typing
\end_layout

\begin_layout Standard
According to §4.1.2 of the f77 specification, in FORTRAN 77 a variable 
\begin_inset Quotes eld
\end_inset

may have its type specified in a type-statement (8.4) as integer, real, double
 precision, complex, logical, or character.
 In the absence of an explicit declaration in a type-statement, the type
 is implied by the first letter of the name.
 A first letter of I, J, K, L, M, or N implies type integer and any other
 letter implies type real, unless an IMPLICIT statement (8.5) is used to
 change the default implied type.
\begin_inset Quotes erd
\end_inset

 An IMPLICIT statement specifies a type for all variables that begin with
 any letter that appears in the specification.
 
\end_layout

\begin_layout Standard
From a type safety perspective, the problem with this typing discipline
 is no 
\emph on
referential transparency
\emph default
, i.e.
 if the name of a variable changes then the result of a computation may
 change.
 As our aim is to create pure functional code, our compiler infers explicity
 type declarations (
\begin_inset Quotes eld
\end_inset

type-statements
\begin_inset Quotes erd
\end_inset

 in the F77 spec) for all implicity typed variables.
 
\end_layout

\begin_layout Standard
The algorithm for this is straightforward:
\end_layout

\begin_layout Enumerate
Parse all IMPLICIT statements and turn them into a lookup table {Char =>
 (Type,ArrayOrScalar,Attribute)}.
 This lookup table is initially populated with the default rule: implicit
 integer (i-n), real (a-h, o-z)
\end_layout

\begin_layout Enumerate
Analyse all executable statements for occurences of undeclared variables
 and add declarations following the IMPLICIT rules, i.e
\end_layout

\begin_deeper
\begin_layout Enumerate
Get the first character
\end_layout

\begin_layout Enumerate
Look up the type in the lookup table
\end_layout

\begin_layout Enumerate
Create a type declaration 
\end_layout

\end_deeper
\begin_layout Enumerate
Add the created declarations before the first executable statement
\end_layout

\begin_layout Enumerate
Add IMPLICIT NONE before the first non-executable statement to specify that
 no implicit typing should be done in the generated code
\end_layout

\begin_layout Subsection
Removal of COMMON blocks
\end_layout

\begin_layout Standard
From the spec:
\end_layout

\begin_layout Standard
The COMMON statement provides a means of associating entities in different
 program units.
 This allows different program units to define and reference the same data
 without using arguments, and to share storage units.
\end_layout

\begin_layout Standard
(From the F95 spec: "The COMMON statement specifies blocks of physical storage,
 called common blocks, that may be accessed by any of the scoping units
 in a program.
 Thus, the COMMON statement provides a global data facility based on storage
 association.
\end_layout

\begin_layout Standard
Storage sequences are used to describe relationships that exist among variables,
 common blocks, and result variables.
 Storage association is the association of two or more data objects that
 occurs when two or more storage sequences share or are aligned with one
 or more storage units.
 " )
\end_layout

\begin_layout Standard
Our approach is to convert COMMON block variables into subroutine arguments.
 The more common approach of conversion into module-scoped variables is
 not suitable for our purpose because it does not result in pure functions.
 (Furthermore, because of the difference in semantics of storage association
 and module scoped variables, this approach only works for COMMON blocks
 where all variables are aligned, whereas COMMON blocks allow overlapping
 sequences).
 One of the main contributions of this paper is in this conversion and the
 associated type checks.
\end_layout

\begin_layout Subsubsection
Construct the COMMON block chain
\end_layout

\begin_layout Standard
In a subroutine call chain, it is not necessary for a COMMON blocks to occur
 in the caller.
 It is sufficient that the COMMON block used in a called subroutine occurs
 somewhere in the call chain.
 As a consequence, it is not generally possible to associate the COMMON
 block variables in a called subroutine with those of the caller.
 For example:
\end_layout

\begin_layout LyX-Code
progam ex1
\end_layout

\begin_layout LyX-Code
common /bf2/x 
\end_layout

\begin_layout LyX-Code
common /bf1/y
\end_layout

\begin_layout LyX-Code
call f1
\end_layout

\begin_layout LyX-Code
end program ex1
\end_layout

\begin_layout LyX-Code
subroutine f1 
\end_layout

\begin_layout LyX-Code
common /bf1/y1 
\end_layout

\begin_layout LyX-Code
call f2 
\end_layout

\begin_layout LyX-Code
end subroutine f1
\end_layout

\begin_layout LyX-Code
subroutine f2 
\end_layout

\begin_layout LyX-Code
common /bf2/x2 
\end_layout

\begin_layout LyX-Code
end subroutine f2
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
In this example, x2 in f2 is associated with x in the main program 
\end_layout

\begin_layout LyX-Code
progam ex1 
\end_layout

\begin_layout LyX-Code
call f1(x,y) 
\end_layout

\begin_layout LyX-Code
end program ex1
\end_layout

\begin_layout LyX-Code
subroutine 
\end_layout

\begin_layout LyX-Code
f1(x,y1) 
\end_layout

\begin_layout LyX-Code
call f2(x) 
\end_layout

\begin_layout LyX-Code
! ...
 use y1 ...
 
\end_layout

\begin_layout LyX-Code
end subroutine f1
\end_layout

\begin_layout LyX-Code
subroutine f2(x2) 
\end_layout

\begin_layout LyX-Code
! ...
 use of x2 
\end_layout

\begin_layout LyX-Code
end subroutine f2
\end_layout

\begin_layout Standard
So the argument for f2 has to be passed via f1 from the main program.
 Therefore, we need to analyse the code for the call chain paths between
 disjoint COMMON blocks and pass all arguments via the intervening calls.
 This also requires checking if the names are unique an renaming if necessary.
 The result of this analysis is that for every called subroutine, we have
 a pair consisting of the common block sequence that will become the call
 arguments, and the common block sequence that will become the dummy arguments.
 
\end_layout

\begin_layout Subsubsection
The actual conversion
\end_layout

\begin_layout Standard
To create the call arguments and dummy arguments, we need to identify which
 variable in the caller sequence matches which in the subroutine call sequence
 (called the 'local' sequence for brevity).
 This is complicated by the fact that storage sequences are allowed to overlap,
 and do not follow the normal type checking rules.
 For example, the following is acceptable:
\end_layout

\begin_layout LyX-Code
! caller 
\end_layout

\begin_layout LyX-Code
real xc(8),z1c,z2c 
\end_layout

\begin_layout LyX-Code
complex yc 
\end_layout

\begin_layout LyX-Code
common yc,xc,zx
\end_layout

\begin_layout LyX-Code
! local real xl(2),zl(4) 
\end_layout

\begin_layout LyX-Code
complex yl(3) 
\end_layout

\begin_layout LyX-Code
common yl,xl,zl
\end_layout

\begin_layout Standard
yl(1) will be associated with yc(1) yl(2) will be associated with xl(1)
 and xl(2) yl(3) will be associated with zl(1) and zl(2) zl(3) will be associate
d with z1c zl(4) will be associated with z2c
\end_layout

\begin_layout Standard
Furthermore, we need to type check the associations, because COMMON blocks
 are not type safe: the association does not cause type conversion or imply
 mathematical equivalence.
 
\end_layout

\begin_layout Standard
XXX algos here XXX
\end_layout

\begin_layout Section
Removal of EQUIVALENCE statements
\end_layout

\begin_layout Standard
According to §8.2 of the F77 spec , "An EQUIVALENCE statement is used to
 specify the sharing of storage units by two or more entities in a program
 unit.
 This causes association of the entities that share the storage units.
 If the equivalenced entities are of different data types, the EQUIVALENCE
 statement does not cause type conversion or imply mathematical equivalence.
 If a variable and an array are equivalenced, the variable does not have
 array properties and the array does not have the properties of a variable."
\end_layout

\begin_layout Standard
This is another form of storage association, with the same issue that it
 is not type-safe.
 For example
\end_layout

\begin_layout LyX-Code
XXX example XXX
\end_layout

\begin_layout Standard
Therefore, EQUIVALENCE statements also need to be refactored.
 They come with their own flavour of complications.
 
\end_layout

\begin_layout Standard
if a line has multiple tuples, this is allowed: 
\end_layout

\begin_layout Standard
(v1,v2),(v2,v3) 
\end_layout

\begin_layout Standard
So we must effectively do a transitivity check across all tuples.
 We do this by checking if an element of a tuple occurs in another tuple.
 It is sufficient to do this for a single element because the transivity
 means that every element from the one tuple will be associated with every
 element from the other.
\end_layout

\begin_layout Standard
Furthermore, the tuples (called lists in the spec) can have more than two
 elements.
 
\end_layout

\begin_layout Standard
(v1,v2,v3),(v3,v4,v5) 
\end_layout

\begin_layout Standard
then this effectively means (v1,v2,v3,v4,v5) and each of these variables
 is associated with all the others, so there are 10 unique associations
 in this example.
 In general, for a tuple of n values, there will be (n-1)*n/2 associations.
\end_layout

\begin_layout Standard
Another complication is that overlapping is allowed, e.g.:
\end_layout

\begin_layout Standard
DIMENSION RADE11(5), RADE12(5) 
\end_layout

\begin_layout Standard
EQUIVALENCE (RADE11(4), RADE12(2))
\end_layout

\begin_layout Standard
Because the arrays start at 1, and they overlap, this actually creates an
 equivalence between `RADE11(3), RADE12(1)` and `RADE11(5), RADE12(3)` as
 well.
 So we have to equate the overlapping ranges.
\end_layout

\begin_layout Section
INTENT inference 
\end_layout

\begin_layout Standard
Because the subroutines to be offloaded cannot contain external calls or
 I/O calls, we can infer the intent of all arguments by recursive descent
 into nested calls.
\end_layout

\begin_layout Subsection*
Typechecking COMMON block and EQUIVALENCE associations 
\end_layout

\begin_layout Standard
Variables stored in COMMON blocks lose all type information.
 This means in particular that there is no type coercion between real and
 integer values.
 To ensure type safety before refactoring, if a COMMON block is used to
 pass arguments to a subroutine, our compiler will perform typechecks.
 Because of the lack of coercion, these checks are different from the typechecks
 performed for normal assignments or arguments passed to subroutines via
 dummy parameters.
 The same is true for EQUIVALENCE statements: they associate different names
 with the same memory location, but the type of the word written to the
 memory location is erased.
 Therefore, the following is legal and does not generate any warnings, but
 is incorrect
\end_layout

\begin_layout LyX-Code
integer*4 i1
\end_layout

\begin_layout LyX-Code
real*4 r1       
\end_layout

\begin_layout LyX-Code
equivalence (i2,r1)
\end_layout

\begin_layout LyX-Code
i1 = 42
\end_layout

\begin_layout LyX-Code
print *, r1 ! prints 5.88545355E-44
\end_layout

\begin_layout LyX-Code
r1 = 42
\end_layout

\begin_layout LyX-Code
print *, i1 ! prints 1109917696
\end_layout

\begin_layout Standard
For the purpose of typechecking, we can assume that all variables are scalar:
 an array a is considered as syntactic sugar for an ordered collection of
 scalars with names a(i).
 We further assume all arrays are linear and traversed using an index starting
 at 1.
 
\end_layout

\begin_layout Standard
The main rule for type soundness which we adopt are:
\end_layout

\begin_layout Itemize
Kind matching (rule-kind)
\end_layout

\begin_deeper
\begin_layout Standard
A scalar type is atomic, and therefore we cannot split the type, which would
 be the case if we attempted to map types with different kinds.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
 & K_{c,i}=K_{l,i} & ,\forall i\in\#K_{l}
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
No COMMON block extension in the called subroutine (rule-size)
\end_layout

\begin_deeper
\begin_layout Standard
The ordered set of words in a COMMON block accessed from a subroutine must
 be no larger than the size of the COMMON block in the caller.
 
\end_layout

\begin_layout Standard
If W is the ordered set of all words accessed via the COMMON block then
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
 & \#W_{l}\leq\#W_{c}
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Logical coercion (rule-logical)
\end_layout

\begin_deeper
\begin_layout Standard
The next rule is that all types must match between the sequence of variables
 in the caller and the called subroutine.
 However, this rule is too strict: there are several cases in which type
 coercion is sound.
 The first case involves logicals:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
 &  & \begin{cases}
T_{c,i}=\mbox{logical}\land T_{l,i}=\mbox{integer}\\
T_{c,i}=\mbox{integer}\land T_{l,i}=\mbox{logical}\\
T_{c,i}=\mbox{real}\land T_{l,i}=\mbox{logical}
\end{cases}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
A logical is false when coerced from 0 and true otherwise.
 Therefore interpreting a logical as an integer gives 1 or 0, and interpreting
 an integer or real as a logical will return correct values of .true.
 or .false.
 .
 Note that Therefore interpreting a logical as a real is only correct for
 .false.
 because the .true.
 interpreted as a real is a non-zero number that depends on the kind of
 the real.
 As this is quite non-intuitive, our typechecker therefor throws an error
 on attempts to interpret a logical as a real.
\end_layout

\end_deeper
\begin_layout Itemize
Complex coercion (rule-complex)
\end_layout

\begin_deeper
\begin_layout Standard
The next case involves complex numbers, which can be coerced to and from
 two contiguous real numbers:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
 &  & \begin{cases}
T_{c,i}=\mbox{complex}\land T_{l,i}=\mbox{real}\land T_{l,i+1}=\mbox{real}\\
T_{c,i}=\mbox{real}\land T_{c,i+1}=\mbox{real}\land T_{l,i}=\mbox{complex}
\end{cases}
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Default rule (rule-default)
\end_layout

\begin_deeper
\begin_layout Standard
In all other cases, the types must match:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
 & T_{l,i}=T_{c,i} & ,\forall i\in\#K_{l}
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
So the overall typecheck rule is as follows:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
 & \mbox{rule-kind\land}\mbox{rule-size\land}\left(\mbox{rule-logical}\lor\mbox{rule-complex}\lor\mbox{rule-default}\right)
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection*
Matching up COMMON block variables in a subroutine call
\end_layout

\begin_layout Standard
Given that the typecheck succeeds, then it follows that for every variable
 in a COMMON block declared in the caller, there is a corresponding variable
 in the called subroutine.
 In practice these variables can be either arrays or scalars.
 Whereas for the purpose of typechecking we have assumed that all variables
 are scalar, without loss of generality, we will now assume that all variables
 are arrays.
 A scalar s is simply syntactic sugar for the first element of an array
 of size 1, s(1).
 This is merely to keep the rules more compact.
 As before, we traverse every array using a linear index starting at 1.
\end_layout

\begin_layout Standard
Because it is possible for arrays from the caller and arrays in the called
 subroutine to overlap in both directions, our strategy for converting the
 COMMON variables into dummy parameters is as follows: 
\end_layout

\begin_layout Itemize
we declare dummy parameters with the names of the variables in the caller
 (prefixed with the name of the caller and the COMMON block).
 
\end_layout

\begin_layout Itemize
Then we determine the assignments required to match these dummy parameters
 with the variables that used to be COMMON block variables in the caller
 subroutine, but now are ordinary local variables.
 
\end_layout

\begin_layout Itemize
We insert these assignments after the last specification statement.
 
\end_layout

\begin_layout Itemize
At the end of the subroutine, we insert the corresponding reverse assignments.
\end_layout

\begin_layout Itemize
If required, the right-hand side of the assignment will contain an explicit
 cast and/or a reshape instruction, because it is possible that the arrays
 in the caller and the called subroutine have different shapes.
\end_layout

\begin_layout Standard
The compiler maintains a global state record.
 The state information of each subroutine, 
\emph on
st
\emph default
, is used in 
\family typewriter
updateDim
\family default
 for evaluation of the array bounds.
\end_layout

\begin_layout Standard
the sequence 
\emph on
cseq
\emph default
 consists of tuples of the type declaration 
\emph on
decl
\emph default
 and the linear index 
\emph on
idx
\emph default
 in the 
\family sans
COMMON
\family default
 block
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
cseq & = & (decl_{1},idx_{1}),...,(decl_{i},idx_{i}),...)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
For every array variable, the type declaration contains a 
\emph on
Dim 
\emph default
field 
\emph on
d
\emph default
 which is an array of (start index, end index) tuples, with total size 
\emph on
sz
\emph default
.
\end_layout

\begin_layout Standard
The list of equivalence pairs 
\emph on
eqps
\emph default
 contains the matched up declarations of the original 
\family sans
COMMON
\family default
 block variables of the called subroutine and the 
\family sans
COMMON
\family default
 block variables of the caller that constitute the new arguments to the
 subroutine.
 The caller variables are prefixed with the name of the block and the caller
 subroutine.
\end_layout

\begin_layout Standard
The matching algorithm traverses the local sequence 
\begin_inset Formula $\mathit{cseq}_{c}$
\end_inset

 and matches each element to one or more elements of the caller sequence
 
\begin_inset Formula $\mathit{cseq}_{l}$
\end_inset

.
 The algorithm is iterative and stops when the local sequence has been consumed,
 and returns 
\emph on
eqps
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
d_{l} & = & \begin{cases}
sz_{l}-\mathit{idx_{l}}>sz_{c}-idx_{c} & \mbox{updateDim}\,\mathit{st}_{l}\,d_{l}\,idx_{l}\,1\\
sz_{l}-idx_{l}<=sz_{c}-idx_{c} & \mbox{updateDim}\,\mathit{st}_{l}\,d_{l}\,idx_{l}\,idx_{l,e}
\end{cases}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
d_{c} & = & \begin{cases}
sz_{l}-idx_{l}=>sz_{c}-idx_{c} & \mbox{updateDim}\,\mathit{st}_{c}\,d_{c}\,idx_{c}\,1\\
sz_{l}-idx_{l}<sz_{c}-idx_{c} & \mbox{updateDim}\,st_{c}\,d_{c}\,idx_{c}\,idx_{c,e}
\end{cases}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\mathit{cseq}_{l} & = & \begin{cases}
sz_{l}-idx_{l}>sz_{c}-idx_{c} & \begin{cases}
sz_{l}-idx_{l,e}\geq1 & (\mathit{decl}_{l},idx_{l}+1)\bullet\mathit{cseq}_{l}\\
sz_{l}-idx_{l,e}<1 & \mathit{cseq}_{l}
\end{cases}\\
sz_{l}-idx_{l}\leq sz_{c}-idx_{c} & \mathit{cseq}_{l}
\end{cases}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\mathit{cseq}_{c} & = & \begin{cases}
sz_{l}-idx_{l}<sz_{c}-idx_{c} & \begin{cases}
sz_{c}-idx_{c,e}\geq1 & (\mathit{decl}_{c},idx_{c}+1)\bullet\mathit{cseq}_{c}\\
sz_{c}-idx_{c,e}<1 & \mathit{cseq}_{c}
\end{cases}\\
sz_{l}-idx_{l}\geq sz_{c}-idx_{c} & \mathit{cseq}_{c}
\end{cases}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\mathit{eqps} & = & \mathit{eqps}\bullet(\mathit{decl}_{l}\left\{ \mathit{Dim}=d_{l}\right\} ,\mathit{decl}_{c}\left\{ \mathit{Dim}=d_{c},\mathit{Prefix}=p\right\} )
\end{eqnarray}

\end_inset


\end_layout

\end_body
\end_document
