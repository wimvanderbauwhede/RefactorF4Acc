module CodeGeneration (    
    inferSignatures, 
        generateFortranCode    
    ) where

import Data.Generics (mkQ, everything, mkM, everywhereM, everywhere, mkT)  
import Control.Monad.State
import qualified Data.Map.Strict as Map
import qualified Data.Set as Set
import Data.List (intercalate, nub, partition, zip4, maximum)

import TyTraCLAST
import ASTInstance (functionSignaturesList, stencilDefinitionsList, mainArgDeclsList, origNamesList, scalarisedArgsList)

(!) = (Map.!)

-- For code generation testing
genMain = True
genStages = True

-- Create maps from the lists in ASTIntance.hs
-- This is because ASTIntance.hs is generated by RefactorF4Acc
functionSignatures :: Map.Map Name FSig 
functionSignatures =  Map.fromList functionSignaturesList

mainArgDecls :: Map.Map Name FDecl
mainArgDecls =  Map.fromList mainArgDeclsList

stencilDefinitions :: Map.Map Name [Integer]
stencilDefinitions  =  Map.fromList stencilDefinitionsList

origNames :: Map.Map Name (Map.Map Name [(Name, FIntent)])
origNames = Map.fromList $ map (\(k,v)-> (k, Map.fromList v)) origNamesList

scalarisedArgs :: Map.Map Name [(Name,(Integer, FIntent, Name))]
scalarisedArgs = Map.fromList scalarisedArgsList 

-- For info only, not called except in Main when info = True
inferSignatures :: TyTraCLAST -> [(Name,FSig)]
inferSignatures ast = Map.toList (inferSignaturesMap functionSignatures ast)

{-
Step 1. Derive the intermediate function signatures
-}

-- We update this map with the infered signatures of intermediate functions
-- let's be old-school contrarian and use fold
inferSignaturesMap :: Map.Map Name FSig -> TyTraCLAST -> Map.Map Name FSig
inferSignaturesMap = foldl inferSignature

inferSignature ::  (Map.Map Name FSig) -> (Expr,Expr) -> Map.Map Name FSig
inferSignature functionSignatures ast_tup =
    let
        (lhs,rhs) = ast_tup
        (fname,mfsig) = case lhs of
            Function fname _ -> (fname,Just $ getFunctionSignature rhs functionSignatures)
            _ -> ("",Nothing)
    in 
        case mfsig of
            Just fsig -> Map.insert fname fsig functionSignatures 
            Nothing -> functionSignatures

getFunctionSignature :: Expr ->  (Map.Map Name FSig) -> FSig
getFunctionSignature rhs functionSignatures =
        case rhs of
            MapS (SVec sv_sz _ ) (Function fname _) -> deriveSigMaps sv_sz fname functionSignatures
            Comp (Function f1 _) (Function f2 _) -> deriveSigComp f1 f2 functionSignatures
            Comp (PElt idx) (Function fname _) -> deriveSigPELt idx fname functionSignatures
            FComp (Function f1 _) (Function f2 _) -> deriveSigFComp f1 f2 functionSignatures
            ApplyT fs -> deriveSigApplyT fs functionSignatures

-- ApplyT can only arise because of Map, so it can't be Fold.       
-- Arguments to ApplyT can be Function, Id, what else? Let's assume that is all
-- The signature of the derived function should be grouped   
-- ApplyT simply applies a number of functions to a number of elements in a tuple
-- So the signature is the combination of all signatures

deriveSigApplyT :: [Expr] -> (Map.Map Name FSig) -> FSig      
deriveSigApplyT fs functionSignatures =
    let
        fsigs = getFSigs fs functionSignatures        
        -- So we have for every function a list [Expr, Expr, Expr]
        -- I need to combine this into a single list. To do so, I have to remove the Tuple and then concat. Easy:
        (nsl, msl, osl) = unzip3 $ map (\[nm,m,o] -> (nm,m,o)) fsigs
        (ns, ms, os) = (Tuple nsl,Tuple msl,Tuple osl)
    in
        [ns,ms,os] 

deriveSigMaps :: Int -> Name -> (Map.Map Name FSig) -> FSig
deriveSigMaps sv_sz fname functionSignatures =
    let
        fsig = functionSignatures ! fname
    in            
        case fsig of
            [nms,ms,os] -> let
{-
maps :: SVec sz a -> c->a->b -> c->SVec sz a -> SVec sz b
-}                
                    ms' = SVec sv_sz (updateName "sv" "in" ms)
                    os' = SVec sv_sz (updateName "sv" "out" os)
                in
                    [nms,ms',os']
            [nms,as,ms,os] -> let
                    ms' = SVec sv_sz (updateName "sv" "in" ms)
                    os' = SVec sv_sz (updateName "sv" "out" os)
                in
                    [nms,as,ms',os']

deriveSigComp :: Name -> Name -> (Map.Map Name FSig) -> FSig
deriveSigComp fname1 fname2 functionSignatures =      
    let
        fsig1 =  functionSignatures ! fname1
        fsig2 =  functionSignatures ! fname2
        [nms1,_,os1] = fsig1
        [nms2,ms2,_] = fsig2
-- the output of f2 is used as the input for f1
        (nms,ms',os') = (Tuple [nms1,nms2], ms2, os1)
    in
        [nms,ms',os']

deriveSigFComp fname1 fname2 functionSignatures =               
    let
        fsig1 =  functionSignatures ! fname1
        fsig2 =  functionSignatures ! fname2
        [nms1,as,_,os1] = fsig1
        [nms2,ms2,_] = fsig2
    -- the output of f2 is used as the input for f1
        (nms,ms',os') = (Tuple [nms1,nms2], ms2, os1)
    in
        [nms,as,ms',os']     

deriveSigPELt idx fname functionSignatures = 
    let
        fsig =  functionSignatures ! fname
    in
        case fsig of
            [nms,ms,os] -> let
                    Tuple es = os
                    os' = es !! idx
                in
                     [nms,ms,os']
            [nms,as,ms,os] -> let
                    Tuple es = os
                    os' = es !! idx
                in
                    [nms,as,ms,os']

-- ----------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------

{-
Step 2. Generate Fortran definitions for the non-function expressions
This means stencils, map and fold calls, vector and tuple assignments
-}
-- A tuple, fst elt is a list of declarations, snd elt is a list of statements
-- The statements can only be Stencil, Map or Fold
generateNonSubDefs :: (Map.Map Name FSig) -> TyTraCLAST -> ([String],[String])
generateNonSubDefs functionSignatures ast = 
    let
        (stmts, decls) = foldl (
            \(lst,st) elt ->  let
                (elt',st') = generateNonSubDef functionSignatures elt
            in
                (lst++[elt'],st++st')
                ) ([],[]) ast
        unique_decls = nub decls                
    in
        (unique_decls, stmts)

-- Returns a string with the statement and a list of decl strings
generateNonSubDef :: (Map.Map Name FSig) -> (Expr, Expr) -> (String,[String])
generateNonSubDef functionSignatures t  =
    let
        (lhs,rhs) = t        
        lhs' = mkFinalVecs lhs
        v_name = getName lhs'
    in
        case rhs of
            Stencil s_exp v_exp -> generateStencilAppl s_exp v_exp v_name stencilDefinitions
            Map f_exp v_exp -> generateMap functionSignatures f_exp v_exp t
            UnzipT (Map f_exp v_exp) -> generateMap functionSignatures f_exp v_exp t
            Vec _ (Scalar _ _ _) -> generateVecAssign lhs rhs
            Fold f_exp acc_exp v_exp -> generateFold functionSignatures f_exp acc_exp v_exp t
            _ -> (show rhs, ["generateNonSubDef: TODO: "++(show t)])
        
-- ----------------------------------------------------------------------------------------
-- ---------------------------------------------------------------------------------------- 
{-
Step 3. Generate the Fortran definitions for the intermediate functions
-}       

-- ----------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------        


-- Step 3a. Generate Fortran definitions for the opaque functions
-- These are wrappers which call the original scalarised kernels -- TODO!!!

-- This is fine as we don't need opaques for the Ids
opaqueFunctionExprs = map (\(fname, _) -> (Function fname [], Id fname [] )) functionSignaturesList
generatedOpaqueFunctionDefs = map (\elt -> fst $ generateSubDef functionSignatures elt []) opaqueFunctionExprs

generateDefs :: (Map.Map Name FSig) -> TyTraCLAST -> [String] -- 
generateDefs  functionSignatures ast =
        fst $ foldl (
            \(lst,st) elt ->  let
                (elt',st') = generateSubDef functionSignatures elt st
            in
                (lst++[elt'],st')
                ) ([],[]) ast

generateSubDef :: (Map.Map Name FSig) -> (Expr, Expr) -> [String] -> (String,[String])
generateSubDef functionSignatures t st =
    let
        (lhs,rhs) = t
        Function ho_fname _ = lhs
    in
        (case rhs of 
            MapS sv_exp f_exp -> generateSubDefMapS sv_exp f_exp ho_fname functionSignatures
            ApplyT f_exps -> generateSubDefApplyT f_exps ho_fname functionSignatures
            Comp (PElt idx) f_exp -> generateSubDefElt idx f_exp ho_fname functionSignatures
            Comp f1_exp f2_exp -> generateSubDefComp f1_exp f2_exp ho_fname functionSignatures
            FComp f1_exp f2_exp -> generateSubDefFComp f1_exp f2_exp ho_fname functionSignatures     
            Id _ _ -> generateSubDefOpaque ho_fname functionSignatures
            _ -> show rhs
            ,[])


{-
If a scalarised arg is InOut, then in principle, we should do something like this:

subroutine dyn_map_65(eta_1, eta_2)
    real :: eta_1 -- I assume this is In
    real :: eta_2 -- I assume this is Out as it is the last arg

    real :: eta -- we should be able to infer this name using scalarisedArgs and origNames        
    eta = eta_1 -- This ensures eta_1 can be a proper In    
    call dyn_map_65_scal(un_s_0(1), un_s_0(2), h_s_0(1), h_s_0(2), h_s_0(3), h_s_0(4), h_s_0(5), vn_s_0(1), vn_s_0(2), eta, dt_0, dx_0, dy_0)
    eta_2 = eta -- This ensures eta_2 can be a proper Out
end subroutine dyn_map_65

I think therefore that origNamesList might have to change from 
( "dyn_map_65",[("eta","eta_1"), ("eta","eta_2")])
to
[(String,[(String, FIntent)])]
( "dyn_map_65",[("eta",[( "eta_1", In), ( "eta_2", Out)]]) -- origNames ! dyn_map_65 ! eta = [(eta_1, In),(eta_2, Out)]

And to complement this we change scalarisedArgsList

    ( "dyn_map_65",[ ("eta",(0,InOut, "real")]) -- scalarisedArgs->{dyn_map_65}{eta} = (0,InOut,"real")

Then we can say: if the arg in argsList is InOut, then we need to do special generation; otherwise, we know there can only be a single element, so we take the head of the list and do a sanity check on the Intent,
simply by checking if the arg is in in_args or non_map_args (then it must be In), or in out_args (must be Out

        (mappedArgsList, (orig_arg_decl_str,pre_call_assignment_str,post_call_assignment_str)) =  map (
                \(orig_name, (stencil_index, intent, ftype)) -> 
                    case intent of
                        InOut -> let
                                    extra_statements = handleInOutArg orig_name ftype
                            in 
                              (createCallArg fname orig_name stencil_index,extra_statements)  
                        _ ->  (createCallArg fname orig_name stencil_index,("","",""))
            ) argsList   

("eta",(1,In,"real")), ("eta",(2,In,"real")), ("eta",(3,InOut,"real")), ("eta",(4,In,"real")), ("eta",(5,In,"real"))
("eta",[("eta_s_0",In),("eta_1",Out)])])
eta = eta_s_0(3)
eta_s_0(1),eta_s_0(2), eta, eta_s_0(4), eta_s_0(5)
eta_1 = eta



-}            
createCallArg :: Name -> Name -> Integer -> Name
createCallArg fname orig_name stencil_index =            
    let
        actual_arg_name = if length ( (origNames ! fname) ! orig_name) > 0
            then
                fst $ head ( (origNames ! fname) ! orig_name)
            else
                 error $ (show (origNames ! fname)) ++ "; "++ orig_name
    in
        actual_arg_name ++ (if stencil_index==0 then "" else "("++(show stencil_index)++")")            


handleInOutArg fname orig_name ftype stencil_index = let
    actual_arg_names = (origNames ! fname) ! orig_name
    actual_in_arg_name = if length (filter (\(n,i) -> i==In) actual_arg_names) > 0
        then
            Just $ fst $ head $ filter (\(n,i) -> i==In) actual_arg_names
        else
            -- means that, although the intent in scalarisedArgs is InOut,
            -- the intent in origNames is only Out
            Nothing
            -- error $ show actual_arg_names  

    -- actual_out_arg_name = fst $ head $ filter (\(n,i) -> i==Out) actual_arg_names
    actual_out_arg_name = if length (filter (\(n,i) -> i==Out) actual_arg_names) > 0
        then
            Just $ fst $ head $ filter (\(n,i) -> i==Out) actual_arg_names
        else
            -- means that, although the intent in scalarisedArgs is InOut,
            -- the intent in origNames is only In
            -- error $ show actual_arg_names    
            Nothing
    -- The args are per definition scalar and we only need this for temporary variables
    orig_arg_decl_str =  "    "++ftype++" :: "++orig_name
    pre_call_assignment_str = case actual_in_arg_name of
        Just actual_in_arg_name -> "    "++orig_name++" = "++actual_in_arg_name++ (if stencil_index==0 then "" else "("++(show stencil_index)++")")
        Nothing -> ""
    post_call_assignment_str = case actual_out_arg_name of
        Just actual_out_arg_name -> "    "++actual_out_arg_name++" = "++orig_name
        Nothing -> ""
    in 
        (orig_arg_decl_str,pre_call_assignment_str,post_call_assignment_str)

generateSubDefOpaque fname functionSignatures =
    let
        fsig = case Map.lookup fname functionSignatures of
            Just fs -> fs
            Nothing -> error "BOOM!"  
        -- Then for every f we do:
        opaque_function_code_strs = if null scalarisedArgsList 
            then
                []
            else
                let
                    argsList = scalarisedArgs ! fname
                    (mappedArgsList, extra_statements) = unzip $ map (
                            \(orig_name, (stencil_index, intent, ftype)) -> 
                                case intent of
                                    InOut -> let
                                                extra_statements = handleInOutArg fname orig_name ftype stencil_index
                                        in 
                                            -- we need to use the orig_name instead of the new name!
                                            -- createCallArg fname  stencil_index
                                            (orig_name, extra_statements)  
                                    _ ->  (createCallArg fname orig_name stencil_index,("","",""))
                        ) argsList   
                    (orig_arg_decl_strs,pre_call_assignment_strs,post_call_assignment_strs) = unzip3 extra_statements           
                    mappedArgsListStr = commaSepList mappedArgsList
                in                                            
                    [
                    "    ! Temp vars"
                    , unlines $ filter (/="") orig_arg_decl_strs
                    ,"    ! Call to the original scalarised subroutine"
                    , unlines $ filter (/="") pre_call_assignment_strs
                    ,"    call "++fname++"_scal("++mappedArgsListStr++")"
                    , unlines $ filter (/="") post_call_assignment_strs
                    ]

        in                      
            case fsig of 
                [nms,ms,os] -> 
                    let                
                        non_map_arg_decls = map show $ createIODecls (Just In) nms -- tuple becomes list of decls
                        in_arg_decls = map show $ createIODecls (Just In)  ms
                        out_arg_decls = map show $ createIODecls (Just Out) os
                        non_map_args = getVarNames nms
                        in_args = getVarNames ms
                        out_args = getVarNames os           
                    in
                        unlines $ [
                             "subroutine "++fname++"("  ++(mkArgList [non_map_args,in_args,out_args])++")"
                            , mkDeclLines [non_map_arg_decls,in_arg_decls,out_arg_decls]
                        ] ++
                        opaque_function_code_strs
                        ++ [
                            "end subroutine "++fname
                        ]
                [nms,as,ms,os] ->
                    let                
                        non_map_arg_decls = map show $ createIODecls (Just In) nms -- tuple becomes list of decls
                        acc_arg_decls = map show $ createIODecls (Just In) as
                        in_arg_decls = map show $ createIODecls (Just In) ms
                        out_arg_decls = map show $ createIODecls (Just Out) os
                        non_map_args = getVarNames nms
                        acc_args  = getVarNames as
                        in_args = getVarNames ms
                        out_args = getVarNames os           
                    in
                        -- error $ "TODO:" ++
                        unlines ( [
                             "subroutine "++fname++"("  ++(mkArgList [non_map_args,acc_args,in_args,out_args])++")"
                            , mkDeclLines [non_map_arg_decls,acc_arg_decls,in_arg_decls,out_arg_decls]
                            ] ++
                            opaque_function_code_strs
                            ++ [
                            "end subroutine "++fname
                            ])
           
generateSubDefMapS :: Expr -> Expr -> Name -> (Map.Map Name FSig) -> String
generateSubDefMapS sv_exp f_exp maps_fname functionSignatures =
    let
        SVec sv_sz _ = sv_exp
        Function fname _ = f_exp
        maps_fsig = functionSignatures ! maps_fname 
        [nms',in_arg',out_arg'] = maps_fsig
        nms = mkFinalArgSigList nms'
        in_arg = mkFinalArgSigList in_arg'     
        out_arg = mkFinalArgSigList out_arg'     
        non_map_arg_decls = createDecls nms -- tuple becomes list of decls
        sv_in_decl = createDecls in_arg
        sv_out_decl = createDecls out_arg
        non_map_args = getVarNames nms
        sv_in_iters = createIter in_arg
        sv_out_iters = createIter out_arg
        sv_in_accesses = map (\(x,y)-> x++y) $ zip sv_in sv_in_iters
        sv_out_accesses = map (\(x,y)-> x++y) $ zip sv_out sv_out_iters
        sv_in = getVarNames in_arg
        sv_out = getVarNames out_arg                
    in unlines [        
        "subroutine "++maps_fname++"("  ++(mkArgList [non_map_args,sv_in,sv_out])++")"
        , mkDeclLines [non_map_arg_decls,sv_in_decl,sv_out_decl]
        ,"    integer :: i"
        ,"    do i=1,"++ (show sv_sz )
        ,"        call "++fname++"("++
        (mkArgList [non_map_args,sv_in_accesses,sv_out_accesses])
        ++")"
        ,"    end do"
        ,"end subroutine "++maps_fname
    ]

generateSubDefApplyT :: [Expr]  -> Name -> (Map.Map Name FSig) -> String
generateSubDefApplyT f_exps applyt_fname functionSignatures = 
    let
            -- fsigs = getFSigs f_exps functionSignatures

            applyt_fsig = case Map.lookup applyt_fname functionSignatures of
                Just fs -> fs
                Nothing -> error "BOOM!"
            [nmst@(Tuple nms),in_argt@(Tuple in_args), out_argt@(Tuple out_args)] = applyt_fsig
            -- so nmst etc are lists, one per function in f_exps
            nmstfn = mkFinalArgSigList nmst
            in_argtfn = mkFinalArgSigList in_argt
            out_argtfn = mkFinalArgSigList out_argt

            non_map_args'' = getVarNames nmstfn
            in_args'' = getVarNames in_argtfn
            out_args'' = getVarNames out_argtfn

            non_map_arg_decls =  createDecls nmstfn --  nmst -- tuple becomes list of decls
            in_arg_decls =  createDecls in_argtfn
            out_arg_decls =  createDecls out_argtfn -- concat $ map            

            calls_nmsfn = map mkFinalArgSigList nms
            calls_msfn = map mkFinalArgSigList in_args
            calls_osfn = map mkFinalArgSigList out_args
                       
            calls_non_map_args =  map getVarNames calls_nmsfn
            calls_in_args =  map getVarNames calls_msfn
            calls_out_args =  map getVarNames calls_osfn

            fsig_names_tups = zip4 f_exps calls_non_map_args calls_in_args calls_out_args
            

            
-- For Id we must rename the args so that they are different. Wonder if I could already do that in the Transform?
    in 
        unlines $ concat [
            ["! APPLYT: FLATTENED, NUBBED: \n! " ++(show nmstfn)++"\n! "++(show in_argtfn)++"\n! "++(show out_argtfn)], 
            [            
            "subroutine "++applyt_fname++"("  ++(mkArgList [non_map_args'',in_args'',out_args''])++")"            
            , mkDeclLines [non_map_arg_decls,in_arg_decls,out_arg_decls]
            ]
            , map (\(f_expr,nms,ms,os) -> case f_expr of
                    Function fname _ -> "    call "++fname++"(" ++(mkArgList [nms,ms,os]) ++")"
                    Id fname dt -> unlines $ map (\(o,m) -> "    "++o++" = "++m) (zip os ms)
                    ) fsig_names_tups
            ,["end subroutine "++applyt_fname]
        ]

-- Comp (Function "f4" []) (Function "f_maps_v_3_0" []))
-- nms are joint
-- ms is for f2
-- os is for f1
generateSubDefComp :: Expr -> Expr -> Name -> (Map.Map Name FSig) -> String
generateSubDefComp f1_exp f2_exp comp_fname functionSignatures = 
    let
        Function fname1 _ = f1_exp
        Function fname2 _ = f2_exp
        fsig1 = functionSignatures ! fname1  
        comp_fsig = functionSignatures ! comp_fname
        [nmst@(Tuple nms),in_argt, out_argt] = comp_fsig
        nmstfn = mkFinalArgSigList nmst
        in_argtfn = mkFinalArgSigList in_argt
        out_argtfn = mkFinalArgSigList out_argt

        non_map_args'' = getVarNames nmstfn
        in_args'' = getVarNames in_argtfn
        out_args'' = getVarNames out_argtfn

        non_map_arg_decls =  createDecls nmstfn --  nmst -- tuple becomes list of decls
        in_arg_decls =  createDecls in_argtfn
        out_arg_decls =  createDecls out_argtfn -- concat $ map  
        calls_nmsfn = map mkFinalArgSigList nms                   
        [non_map_args1,non_map_args2] =  map getVarNames calls_nmsfn
        [_,ms1',_] = fsig1 
        ms1 = mkFinalArgSigList ms1'        
        local_var_decls = createDecls ms1
        tmp_args = getVarNames ms1

    in 
        unlines [
            "subroutine "++comp_fname++"("  ++(mkArgList [non_map_args'',in_args'',out_args''])++")"            
            , mkDeclLines [non_map_arg_decls,in_arg_decls,out_arg_decls,local_var_decls]
            , "    call "++fname2++"(" ++(mkArgList [non_map_args2,in_args'',tmp_args]) ++")"
            , "    call "++fname1++"(" ++(mkArgList [non_map_args1,tmp_args,out_args'']) ++")"            
            ,"end subroutine "++comp_fname
        ]

-- (Function "f_fcomp_acc3_1_2" [],FComp (Function "f2" []) (Function "f_comp_acc3_1_1" []))
-- (b -> a -> b) -> (c->a) -> (b -> c -> b)

-- nms are joint
-- ms is for f2
-- os is for f1
-- acc is retained from f1; there is no os
generateSubDefFComp :: Expr -> Expr -> Name -> (Map.Map Name FSig) -> String
generateSubDefFComp f1_exp f2_exp fcomp_fname functionSignatures = 
    let
        Function fname1 _ = f1_exp
        Function fname2 _ = f2_exp
        fsig1 = functionSignatures ! fname1  
        -- fsig2 =  functionSignatures ! fname2
        fcomp_fsig = functionSignatures ! fcomp_fname
        [nmst@(Tuple nms),acc_argt,in_argt, out_argt] = fcomp_fsig
        nmstfn = mkFinalArgSigList nmst
        in_argtfn = mkFinalArgSigList in_argt
        acc_argtfn = mkFinalArgSigList acc_argt
        out_argtfn = mkFinalArgSigList out_argt

        non_map_args'' = getVarNames nmstfn
        acc_args'' = getVarNames acc_argtfn
        in_args'' = getVarNames in_argtfn
        out_args'' = getVarNames out_argtfn

        non_map_arg_decls =  createDecls nmstfn --  nmst -- tuple becomes list of decls
        acc_arg_decls =  createDecls acc_argtfn
        in_arg_decls =  createDecls in_argtfn
        out_arg_decls =  createDecls out_argtfn -- concat $ map  
        calls_nmsfn = map mkFinalArgSigList nms                   
        [non_map_args1,non_map_args2] =  map getVarNames calls_nmsfn
        [_,ms1',_] = fsig1 
        ms1 = mkFinalArgSigList ms1'        
        local_var_decls = createDecls ms1
        tmp_args = getVarNames ms1

    in 
        unlines [                        
            "! TO BE CHECKED!",
            "subroutine "++fcomp_fname++"("  ++(mkArgList [non_map_args'',acc_args'',in_args'',out_args''])++")"            
            , mkDeclLines [non_map_arg_decls,acc_arg_decls,in_arg_decls,out_arg_decls,local_var_decls]
            , "    call "++fname2++"(" ++(mkArgList [non_map_args2,in_args'',tmp_args]) ++")"
            , "    call "++fname1++"(" ++(mkArgList [non_map_args1,acc_args'',tmp_args,out_args'']) ++")"            
            ,"end subroutine "++fcomp_fname            
        ]

-- essentially, select the idx of the tuple as the output of this sub
-- but this seems a bit silly as it means I have the same function n times
generateSubDefElt idx f_exp felt_name functionSignatures =
    let
        Function fname _ = f_exp
        fsig = functionSignatures ! fname   
        [nms',in_arg',out_arg'] = fsig

        nms = mkFinalArgSigList nms'
        in_arg = mkFinalArgSigList in_arg'     
        out_arg = mkFinalArgSigList out_arg'     

        -- nms = makeDeclsUnique nms'
        -- in_arg = makeDeclsUnique in_arg'             

        non_map_arg_decls = createDecls nms -- tuple becomes list of decls
        in_args_decl = createDecls in_arg
        out_args_decl = createDecls out_arg
        non_map_args = getVarNames nms
        in_args = getVarNames in_arg
        out_args = getVarNames out_arg
        sel_out_arg = out_args !! idx
    in
        unlines [
            ("! ELT: FLATTENED, NUBBED: \n! " ++(show nms)++"\n! "++(show in_arg)++"\n! "++(show out_arg)) ,
            "subroutine "++felt_name++"("  ++(mkArgList [non_map_args,in_args,[sel_out_arg]])++")"            
            , mkDeclLines [non_map_arg_decls,in_args_decl,out_args_decl]
            , "    call "++fname++"(" ++(mkArgList [non_map_args,in_args,out_args]) ++")"
            ,"end subroutine "++felt_name
        ]



-- Because we have simply tupled the args for all elts in the apply,
-- we can simply untuple them. So from applyt_fsig, we unpack the tuples \(Tuple es) -> es
mkFinalArgSigList :: Expr -> Expr
mkFinalArgSigList nmst = Tuple $ nub $ (\arg -> case arg of
        Tuple es -> es
        e -> [e]
        ) (flattenSigExpr nmst)

mkFinalVecs :: Expr -> Expr
mkFinalVecs = flattenSigExpr 

-- This function rewrites an expressions so that it becomes a single tuple of Scalar or nested SVec
flattenSigExpr :: Expr -> Expr
flattenSigExpr dt = rewriteDTRec dt (Tuple [])        
-- We need to call rewriteDT' repeatedly untill all occurences of Tuple [Tuple ] have gone
rewriteDTRec dt dt' 
    | dt == dt' = dt
    | otherwise = rewriteDTRec  (rewriteDT' dt) dt   

-- The result is that Tuple is always on the outside and SVec is nested 
rewriteDT' :: Expr -> Expr
rewriteDT' dt = case dt of
    SVec sz (Tuple dts) ->  Tuple (map (\dt -> SVec sz (rewriteDT' dt)) dts)
    SVec sz (SVec sz2 dt2) ->  SVec sz (rewriteDT' (SVec sz2 dt2))
    SVec sz dt2 ->  dt
    Tuple dts -> Tuple $ concatMap (\dt -> case dt of
                        Tuple dts -> map rewriteDT' dts
                        SVec sz2 dt2 -> [ rewriteDT' (SVec sz2 dt2)]
                        Vec sz2 dt2 -> [ rewriteDT' (Vec sz2 dt2)]
                        dt' -> [ dt']
                        ) dts
    Vec sz (Tuple dts)  -> Tuple (map (\dt -> Vec sz (rewriteDT' dt)) dts)
    ZipT dts -> ZipT $ concatMap (\dt -> case dt of
        Tuple dts -> map rewriteDT' dts
        SVec sz2 dt2 -> [ rewriteDT' (SVec sz2 dt2)]
        Vec sz2 dt2 -> [ rewriteDT' (Vec sz2 dt2)]
        dt' -> [ dt']
        ) dts
    _ -> dt

createIter :: Expr -> [String]
createIter (SVec sz dt) = let
        vn = getName dt
        --now vn could be Single or Composite
    in
        case dt of
            -- we know this can only be either nested DSVec or terminal
            SVec _ _  ->  let
                    (szs,_) = getSzFromSVec dt []
                    colons = map (\_->":") szs
                in                    
                    ["("++(commaSepList ("i":colons)) ++")"]
            -- we know this has no tuples inside it  
            -- It means that if vn is Composite (and it should be!), we can zip the names with dts
            Tuple dts -> let 
                        Composite vns = vn 
                    in createIter (
                            Tuple (
                                map (\(vn',dt) -> SVec sz (setName vn' dt)) (zip vns dts) 
                                )
                            )
            dt -> ["(i)"]
createIter (Tuple es) = concatMap createIter es
createIter other =  error $ show other

createIODecls :: Maybe FIntent -> Expr -> [FDecl]
createIODecls intent (SVec sz dt)  = let
        vn = getName dt
    in
        case dt of
            -- we know this can only be either nested DSVec or terminal
            SVec _ _  ->  let
                    (szs,dt') = getSzFromSVec dt []
                    Single vn' = vn
                in
                    [ MkFDecl (fortranType dt') (Just (sz:szs)) intent [ vn']  ]
            -- we know this has no tuples inside it                
            Tuple dts -> let 
                     Composite vns = vn 
                in 
                    createIODecls intent (
                        Tuple (
                            map (\(vn',dt) -> SVec sz (setName vn' dt)) (zip vns dts)
                            )
                    )
            dt -> let 
                        Single vn' = vn 
                in
                    [MkFDecl (fortranType dt) (Just [sz]) intent [vn'] ]

createIODecls intent (Scalar _ DDC vn) =  error "DDC!"
createIODecls intent sdt@(Scalar _ dt vn) = [MkFDecl (fortranType sdt) Nothing intent [vn]]
createIODecls intent (Tuple es) = concatMap (createIODecls intent)  es

createDecls :: Expr -> [String]
createDecls (SVec sz dt) = let
        vn = getName dt
    in
        case dt of
            -- we know this can only be either nested DSVec or terminal
            SVec _ _  ->  let
                    (szs,dt') = getSzFromSVec dt []
                    Single vn' = vn
                in
                    [(fortranType dt')++", dimension("++(commaSepList (map show (sz:szs)))++") :: "++ vn']  
            -- we know this has no tuples inside it                
            Tuple dts -> let 
                     Composite vns = vn 
                in 
                    createDecls (
                        Tuple (
                            map (\(vn',dt) -> SVec sz (setName vn' dt)) (zip vns dts)
                            )
                    )
            dt -> let 
                        Single vn' = vn 
                in
                    [(fortranType dt)++", dimension("++(show sz)++") :: "++ vn']

createDecls (Scalar _ DDC vn) =  error "DDC!"
createDecls sdt@(Scalar _ dt vn) = [(fortranType sdt)++" :: "++vn]
createDecls (Tuple es) = concatMap createDecls es

getVarNames :: Expr -> [String]
getVarNames (SVec sz dt) = getVarNames dt
getVarNames (Scalar _ _ vn) = [vn]
getVarNames (Tuple es) = concatMap getVarNames es 
getVarNames (ZipT es) = concatMap getVarNames es 
getVarNames (Vec _ dt) = getVarNames dt

getSzFromSVec :: Expr -> [Int] -> ([Int],Expr)
getSzFromSVec (SVec sz dt) szs = getSzFromSVec dt (szs++[sz])  
getSzFromSVec dt szs = (szs,dt)

mkArgList :: [[String]] -> String
mkArgList  = commaSepList . concat 

commaSepList :: [String] -> String
commaSepList = intercalate ", "

mkDeclLines :: [[String]] -> String
mkDeclLines  = unlines . (map ("    "++)) . concat 

generateStencilAppl :: Expr -> Expr -> FName -> Map.Map Name [Integer]  -> (String,[String])
generateStencilAppl s_exp v_exp@(Vec _ dt) sv_name stencilDefinitions = 
    let
        Single v_name = getName dt
        Single lhs_v_name = sv_name
        sv_type = fortranType dt      
        (s_names,s_defs,sv_szs) = generateStencilDef' s_exp stencilDefinitions
        -- instead of generating new stencils we can also recompute, simply
        stencil_accesses = intercalate "+" (map (\(s_name,ct)-> s_name++"(s_idx_"++(show ct)++")") $ zip s_names [1..])
        lhs_idx_str =  commaSepList  $ map (\ct -> "s_idx_"++(show ct)) [1 .. length sv_szs]
        decl_lines =
            (map (\(s_name, s_def, sv_sz) -> ("integer, parameter, dimension("++(show sv_sz)++") :: "++s_name++" = "++(show s_def))) (zip3 s_names s_defs sv_szs))++
            [
            -- if the $sv_type is DDC, it means we need to lookup the type from the definition, which will likely be a zip            
                case sv_name of
                    Single sv_name' -> sv_type++", dimension("++(commaSepList $ map show sv_szs)++") :: "++sv_name'
                    Composite sv_names -> error $ sv_type++", dimension("++(commaSepList $ map show sv_szs)++") :: "++(show sv_names) 
            ]++(map (\ct -> "integer :: s_idx_"++(show ct) ) [1 .. length sv_szs]   )
    in
        (unlines $ concat [
            ["! Stencil "++ show (getName s_exp)],
            map (\(sv_sz,ct) -> "    do s_idx_"++(show ct)++" = 1,"++(show sv_sz)) (zip sv_szs [1..]),
            [
             "        "++lhs_v_name++"("++lhs_idx_str++") = "++v_name++"(idx+"++stencil_accesses++")"
             ],
            replicate (length sv_szs) "    end do"
          ]
        ,decl_lines)
generateStencilAppl s_exp v_exp@(ZipT vs_exps') sv_name stencilDefinitions = let
        ZipT vs_exps = mkFinalVecs v_exp   
        gen_stencils :: [String]
        -- [(String,[String])] -> ([String], [[String]])
        (gen_stencils,decls) = case sv_name of
            Composite sv_names -> unzip $ map (\(v_exp,sv_name') -> generateStencilAppl s_exp v_exp sv_name' stencilDefinitions) (zip vs_exps sv_names)
            Single sv_name' -> unzip $ map (\(v_exp,ct) -> generateStencilAppl s_exp v_exp (Single (sv_name'++"_"++(show ct))) stencilDefinitions) (zip vs_exps [0..]) -- SHOULD NOT OCCUR!            
        -- I want to "zip" them but it's a list of lists, so I need to round-robin over it
        gen_stencils_lines :: [[String]]
        gen_stencils_lines = map lines gen_stencils
        grouped_lines :: [[String]]
        grouped_lines = pairUpZipCode gen_stencils_lines []
        -- grouped_lines = gen_stencils_lines
        unique_grouped_lines :: [[String]]
        unique_grouped_lines = map nub grouped_lines
        all_lines :: [String]
        all_lines = concat unique_grouped_lines
    in
        (unlines all_lines, concat decls)

-- some kind of a fold where the result is, if I start from n lists, with each list k lines, then I will have k lists of n lines
-- so for each of these n lists I take the head , that gets me n lines
pairUpZipCode lsts acc
            | null (head lsts) = acc
            | otherwise =
                let
                    (l1,rest) = unzip  $ map (\(x:xs) -> (x,xs)) lsts -- which is a list of tuples                    
                in
                    pairUpZipCode rest (acc++[l1])

generateStencilDef' :: Expr -> Map.Map Name [Integer] -> ([String],[[Integer]],[Int])                
generateStencilDef' s_exp stencilDefinitions = 
     case s_exp of
        SVec sv_sz sv_exp -> let
                    Single s_name = getName sv_exp
                in
                    case Map.lookup s_name  stencilDefinitions of
                        Just s_def -> ([s_name],[s_def], [length s_def])
        SComb s1 s2 -> let
                (s1_name,s1_def, len_s1) = generateStencilDef' s1 stencilDefinitions 
                (s2_name,s2_def, len_s2) = generateStencilDef' s2 stencilDefinitions 
                scomb_name = s1_name++s2_name
                -- scomb_def = [ x+y | x <- s1_def, y <- s2_def]
            in
                (scomb_name, s1_def++s2_def,len_s1++len_s2) -- [length s1_def, length s2_def])                


generateVecAssign lhs rhs = let
        Single rhs_vec_name = getName rhs
        Single lhs_vec_name = getName lhs
        assign_str = "    "++lhs_vec_name++" = "++rhs_vec_name
        lhs_vec_decl = mainArgDecls ! lhs_vec_name  -- risky, might be indirect!
        rhs_vec_decl = lhs_vec_decl{intent=Nothing,names=[rhs_vec_name]}
        rhs_vec_decl_str =  show rhs_vec_decl
            -- (take (length lhs_vec_decl - length ", intent(out) :: " - length lhs_vec_name) lhs_vec_decl) ++ " :: "++rhs_vec_name
    in
        (assign_str,[rhs_vec_decl_str])                

generateMap functionSignatures f_exp v_exp t = -- (Single ov_name)
    let
        Function fname nms_exps = f_exp
        (lhs,rhs) = t
        out_vars_lst = getName lhs 
        Map _ rhs_v_exp = rhs
        -- I reason that output variables *must* be unique
        out_vars_name_lst = case out_vars_lst of
            Single ov_name'' -> if Map.member ov_name'' mainArgDecls then [ov_name''++"(idx)"] else [ov_name'']
            Composite ov_names -> map (\(Single ov_name'') -> if Map.member ov_name'' mainArgDecls then  ov_name''++"(idx)" else  ov_name'') ov_names
        nms_vars_lst = nub $ map (show . getName) nms_exps
        in_vars_lst =  getName rhs_v_exp
        in_vars_name_lst = case in_vars_lst of
            Single ov_name'' -> if Map.member ov_name'' mainArgDecls then [ov_name''++"(idx)"] else [ov_name'']
            Composite ov_names -> let
                    Composite fl_ov_names = flattenNames (Composite ov_names)
                in
                    map (\(Single ov_name'') -> if Map.member ov_name'' mainArgDecls then  ov_name''++"(idx)" else  ov_name'') fl_ov_names
        in_vars_name_lst_str' =  map snd (nubTup $ zip (unwrapName sig_in_args_lst) in_vars_name_lst)
        
        fsig = functionSignatures ! fname 
        [_,v_exp',_] = fsig
        sig_in_args_lst = getName $ flattenSigExpr v_exp'
    in
        (
            unlines [
            "! Map",
            "    call "++fname++"("++
                mkArgList [nms_vars_lst, in_vars_name_lst_str',out_vars_name_lst]
                 ++ ")",
            "" ]
        ,[])

-- I think the difference between fold and map is the acc and the output type
-- In principle the accumulator could be a tuple, so the code as is is not generic!
generateFold functionSignatures f_exp acc_exp v_exp t =
    let
        Function fname nms_exps = f_exp
        fsig = functionSignatures ! fname 
        [_,acc_exp',v_exp',_] = fsig
        sig_in_args_lst = getName $ flattenSigExpr v_exp'
        sig_acc_args_lst = getName $ flattenSigExpr acc_exp'

        (lhs,rhs) = t
        out_vars_lst = getName lhs
        Fold _ rhs_acc_exp rhs_v_exp = rhs -- fold f acc v
        out_vars_name_lst = case out_vars_lst of
            Single ov_name'' -> if Map.member ov_name'' mainArgDecls then ov_name''++"(idx)" else ov_name''
            Composite ov_names -> error $ show $ map (\(Single ov_name'') -> if Map.member ov_name'' mainArgDecls then  ov_name''++"(idx)" else  ov_name'') ov_names
        nms_vars_lst =  nub $ map (show . getName) nms_exps
        in_vars_lst =  getName rhs_v_exp
        in_vars_name_lst = case in_vars_lst of
            Single ov_name'' -> if Map.member ov_name'' mainArgDecls then [ov_name''++"(idx)"] else [ov_name'']
            Composite ov_names -> let
                    Composite fl_ov_names = flattenNames (Composite ov_names)
                in
                    map (\(Single ov_name'') -> if Map.member ov_name'' mainArgDecls then  ov_name''++"(idx)" else  ov_name'') fl_ov_names
        in_vars_name_lst' =  map snd (nubTup $ zip (unwrapName sig_in_args_lst) in_vars_name_lst)            

        
        acc_vars_lst =  getName rhs_acc_exp
        acc_vars_name_lst = case acc_vars_lst of
            Single ov_name'' -> if Map.member ov_name'' mainArgDecls then [ov_name''++"(idx)"] else [ov_name'']
            Composite ov_names -> let
                    Composite fl_ov_names = flattenNames (Composite ov_names)
                in
                    map (\(Single ov_name'') -> if Map.member ov_name'' mainArgDecls then  ov_name''++"(idx)" else  ov_name'') fl_ov_names
        acc_vars_name_lst' =  map snd (nubTup $ zip (unwrapName sig_acc_args_lst) acc_vars_name_lst)            

        -- nms = getVarNames (Tuple nms_exps)
        -- vs_in = getVarNames v_exp
        Scalar _ _ acc_name = acc_exp
    in  
        (
            unlines [
         show acc_vars_name_lst',
         "! Fold",
        "    call "++fname++"("
        ++ mkArgList [nms_vars_lst,[acc_name] ,in_vars_name_lst',[out_vars_name_lst]] 
        ++")",        
        acc_name++" = "++out_vars_name_lst
            ]
        ,[])

-- for every stage:
-- stage_ast is the AST with only non-function-defs
generateStageKernel :: (Map.Map Name FSig) -> Int -> TyTraCLAST -> String
generateStageKernel functionSignatures ct stage_ast  =
    let   
        (generatedDecls,generatedStmts) = generateNonSubDefs functionSignatures stage_ast
        uniqueGeneratedDecls = nub generatedDecls
        -- now I need to extract all VI and VO from non_func_exprs
        -- best way to do that is with `everything` I think
        in_args = nub $ concatMap (\(lhs,rhs) -> getInputArgs rhs) stage_ast
        out_args = nub $ concatMap (\(lhs,rhs) -> getOutputArgs lhs) stage_ast
        -- and I need the declarations for these, so I guess I need to get the Exprs and then the names and decls from there
        -- also I need a mechanism to detect the accs that are passed between the stages
        arg_decl_lines = map (\arg_name -> case Map.lookup arg_name mainArgDecls of
                                    Just decl -> show decl
                                    Nothing -> error $ "No declaration for "++arg_name++ " in mainArgDecls"
                            ) (in_args++out_args)

    in unlines $
        [
            "subroutine stage_kernel_"++(show ct)++"("++(mkArgList [in_args, out_args])++")"
        ]
        ++(map ("    "++) arg_decl_lines)
        ++["\n"]
        ++(map ("    "++) uniqueGeneratedDecls)
        ++["\n"]
        ++[
            "    integer :: idx",
            "    call get_global_id(idx)"
        ]
        ++["\n"]
        ++generatedStmts
        ++[            
            "end subroutine stage_kernel_"++(show ct)
        ]


getInputArgs = everything (++) (mkQ [] (getInputArgs')) 

getInputArgs' :: Expr -> [Name]
getInputArgs' node = case node of
                            Vec VI dt -> [(\(Single vn) -> vn) $ getName dt] 
                            Scalar VI _ sn -> [sn]
                            _ -> []

getOutputArgs = everything (++) (mkQ [] (getOutputArgs')) 

getOutputArgs' :: Expr -> [Name]
getOutputArgs' node = case node of
                            Vec VO dt -> [(\(Single vn) -> vn) $ getName dt] 
                            Scalar VO _ sn -> [sn]
                            _ -> []                                    

getFSigs :: [Expr] -> Map.Map Name FSig -> [FSig] 
getFSigs fs functionSignatures = map (\(f_expr, idx) -> case f_expr of
        (Function fname _) -> case Map.lookup fname functionSignatures  of
            Just sig -> sig
            Nothing -> error $ "getFSigs: no entry for "++fname
        (Id fname dt) ->  case Map.lookup fname functionSignatures  of
            Just sig -> sig
            Nothing -> [Tuple [],Tuple [],Tuple []] -- error $ "getFSigs: no entry for Id "++fname            
            -- [Tuple [], setName ("id_in_"++(show idx)) dt, setName ("id_out_"++(show idx)) dt ]
    ) (zip fs [1..])

{-
TODO!!!
The problem with the stages is that not every "stage" is really a stage. Basically it is about dependencies.
Staging is only needed for folds. 
We have now already set it up such that any maps preceding a fold are part of the fold.
So any "stage" with a fold AND the last stage are real stages. The other should be combined with the last stage

So split out all Fold entries;
split out all function definitions and put them up front

What this returns is
- A list of ASTs of the function definitions
- A list of ASTs of the non-function-definition code for each stage

TODO: the accumulators of the folds are the dependencies, we need to work out which acc is used in which later stage

-}

createStages :: [TyTraCLAST] -> (TyTraCLAST,[TyTraCLAST])
createStages asts =
    let
        -- For every Map or Fold, a list of the decomposed function defs and a list of the rest
        -- These are always the same length
        -- But as we want a single superkernel we will always have all defs so I can combine them
        (asts_function_defs, asts_no_function_defs) = unzip $ map (partition isFunctionDef) asts
        -- All ASTs with Map can be combined as the Maps don't depend on one another
        (asts_with_fold,asts_without_fold) = partition hasFold asts_no_function_defs
        ast_without_fold = concat asts_without_fold

    in 
        -- error $ show (length asts_function_defs, length asts_no_function_defs, length asts_with_fold, length ast_without_fold)
        (concat asts_function_defs,asts_with_fold++[ast_without_fold])

hasFold ast = let
        fold_exprs = filter (\(lhs, rhs) -> case rhs of
            Fold _ _ _ -> True
            _ -> False
            ) ast
    in
        length fold_exprs > 0     

isFunctionDef ((Function _ _),_) = True
isFunctionDef _ = False

-- "real, dimension(1:252004), intent(in) :: eta_0" 
createMainProgramDecl decl = let
        chunks = words decl
        chunks' = case  chunks of
            [type_str,dim_str,intent_str,double_colon,var_name_str] -> [type_str,init dim_str,double_colon,var_name_str]
            [type_str,intent_str,double_colon,var_name_str] -> [init type_str,double_colon,var_name_str]        
    in
        unwords chunks'


generateMainProgram :: (Map.Map Name FSig) -> [TyTraCLAST] -> String
generateMainProgram functionSignatures ast_stages  =
    let
        generateStageKernel' functionSignatures  ct stage_ast  =
            let
                -- now I need to extract all VI and VO from non_func_exprs
                -- best way to do that is with `everything` I think
                in_args = nub $ concatMap (\(lhs,rhs) -> getInputArgs rhs) stage_ast
                out_args = nub $ concatMap (\(lhs,rhs) -> getOutputArgs lhs) stage_ast
                -- and I need the declarations for these, so I guess I need to get the Exprs and then the names and decls from there
                -- also I need a mechanism to detect the accs that are passed between the stages
                arg_decl_lines = map (\arg_name -> case Map.lookup arg_name mainArgDecls of
                                            Just decl -> show decl
                                            Nothing -> error $ "No declaration for "++arg_name++ " in mainArgDecls"
                                    ) (in_args++out_args)        
            in        
                (arg_decl_lines, 
                if genStages 
                    then 
                        "call stage_kernel_"++(show ct)++"("++(mkArgList [in_args, out_args])++")"
                    else
                        "! Stage kernel call code not generated"    
                )
    
        -- stage_kernel_info :: ([[String]],[String])
        (stage_kernel_decls, stage_kernel_calls) = unzip $ map (\(ast,ct) -> (generateStageKernel' functionSignatures) ct ast) (zip ast_stages [1..])
        unique_stage_kernel_decls = nub $ concat stage_kernel_decls
        main_program_decls = map createMainProgramDecl unique_stage_kernel_decls
        loops_over_calls = map (\call_str -> unlines [
            "do global_id=1,"++(show vSz), --VSZ",
            "  "++call_str,
            "end do"
            ]
            )stage_kernel_calls
        use_statements_for_opaques = map (\fname -> "use singleton_module_"++fname++", only : "++fname++"_scal") (Map.keys scalarisedArgs)
    in unlines $ [
        "program main",
        unlines use_statements_for_opaques,
        "integer :: global_id",
        "common /ocl/ global_id"
        ] ++
        main_program_decls ++
        loops_over_calls ++
        [
        "end program main  ",
        "",
        "subroutine get_global_id(idx)",
        "integer, intent(out) :: idx",
        "integer :: global_id",
        "common /ocl/ global_id",
        "idx = global_id",
        "end subroutine get_global_id"
        ]
       
generateFortranCode decomposed_ast functionSignaturesList idSigList =
    let
        functionSignatures' =  Map.fromList (functionSignaturesList++idSigList)
        (asts_function_defs,ast_stages) = createStages decomposed_ast
        functionSignatures = inferSignaturesMap functionSignatures' asts_function_defs
        generatedFunctionDefs = generateDefs functionSignatures asts_function_defs
        generatedStageKernels = map (\(ast,ct) -> (generateStageKernel functionSignatures) ct ast) (zip ast_stages [1..])
        mainProgramStr 
            | genMain = generateMainProgram functionSignatures ast_stages        
            | otherwise = "! Main code not generated"
        generatedOpaqueFunctionDefsStr = unlines generatedOpaqueFunctionDefs
        -- putStrLn "\n! Generate subroutine definitions"
        generatedFunctionDefsStr = unlines generatedFunctionDefs
        -- putStrLn "\n! Generated stage kernels"
        generatedStageKernelsStr
            | genStages =  unlines generatedStageKernels         
            | otherwise = "! Stage kernel code not generated"
    in
        unlines [
             mainProgramStr
            ,generatedOpaqueFunctionDefsStr
            ,generatedFunctionDefsStr
            ,generatedStageKernelsStr
        ]        

-- A helper which nubs a list of tuples based on uniqueness of the first element        
nubTup :: Ord a => [(a,b)]  -> [(a,b)] 
nubTup lst = fst $ foldl (\(nubbed_lst,occs) (e1,e2) -> 
    if Set.member e1 occs 
        then 
            (nubbed_lst, occs) 
        else
            (nubbed_lst++[(e1,e2)], Set.insert e1 occs) 
    ) ([],Set.empty) lst

-- The main loop upper bound is the size of the input vectors    
vSz = getVSz  mainArgDeclsList  

getVSz  :: [(String,FDecl)] -> Int
getVSz lst = maximum $ map (\(v,r) -> case dim r of 
            Nothing -> 0
            Just [sz] -> sz
            Just sz -> product sz
            ) lst   

            
fortranType :: Expr -> String    
fortranType (Scalar _ DInt _) = "integer"
fortranType (Scalar _ DInteger _) = "integer" 
fortranType (Scalar _ DReal _) = "real"
fortranType (Scalar _ DFloat _) = "real"       
fortranType (SVec sz dt) = (fortranType dt)++", dimension("++(show sz)++")"
fortranType dt = "! No equivalent Fortran type for "++(show dt)++" !!! "            