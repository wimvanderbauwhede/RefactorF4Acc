#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass svglobal3
\begin_preamble
\RequirePackage{fix-cm}

\smartqed  % flush right qed marks, e.g. at end of proof
\usepackage{minted}




\usepackage{babel}
\providecommand{\problemname}{Problem}
\providecommand{\solutionname}{Solution}
\providecommand{\theoremname}{Theorem}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding iso8859-15
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks false
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle false
\pdf_quoted_options "colorlinks"
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Reducing the memory utilisation of automatically parallelised stencil-based
 legacy scientific code
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Grants or other notes about the article that should go on the front page
 should be placed here.
 General acknowledgments should be placed at the end of the article.
\end_layout

\end_inset


\end_layout

\begin_layout Running Title
Reducing memory utilisation of stencil-based legacy scientific code
\end_layout

\begin_layout Author
Wim Vanderbauwhede 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Cristian Urlea
\end_layout

\begin_layout Running Author
Short form of author list
\end_layout

\begin_layout Institute
F.
 Author 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
at
\end_layout

\end_inset

 first address
\begin_inset Newline newline
\end_inset

 Tel.: +123-45-678910
\begin_inset Newline newline
\end_inset

 Fax: +123-45-678910
\begin_inset Newline newline
\end_inset

 
\begin_inset Flex Email
status collapsed

\begin_layout Plain Layout
fauthor@example.com
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

 
\emph on
Present address:
\emph default
 of F.
 Author if needed 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 S.
 Author 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
at
\end_layout

\end_inset

 second address
\end_layout

\begin_layout Date
Received: date / Accepted: date
\end_layout

\begin_layout Standard
 
\end_layout

\begin_layout Abstract
Insert your abstract here.
 Include keywords, PACS and mathematical subject classification numbers
 as needed.
\end_layout

\begin_layout Abstract
\begin_inset Flex Keywords
status collapsed

\begin_layout Plain Layout
First keyword 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Second keyword 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 More
\end_layout

\end_inset

 
\end_layout

\begin_layout Abstract
\begin_inset Flex PACS
status collapsed

\begin_layout Plain Layout
PACS code1 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 PACS code2 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 more
\end_layout

\end_inset

 
\end_layout

\begin_layout Abstract
\begin_inset Flex Subclass
status collapsed

\begin_layout Plain Layout
MSC code1 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 MSC code2 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 more
\end_layout

\end_inset

 
\end_layout

\begin_layout Section
Introduction
\begin_inset CommandInset label
LatexCommand label
name "sec:Introduction"

\end_inset


\end_layout

\begin_layout Standard
This work is part of our efforts to automatically parallelise legacy scientific
 code in FORTRAN 77 and and compile it to heterogeneous platforms.
 The term 
\begin_inset Quotes eld
\end_inset

legacy code
\begin_inset Quotes erd
\end_inset

 is rather loose because a lot of scientific code is still being developed
 in Fortran, and even though Fortran 90 syntax is more prevalent, in terms
 of features most of this code is actually FORTRAN 77.
 The considerable effort required for manual porting of such code to parallel
 platforms and –even more– accelerators such as GPUs means that it is often
 beyond the grasp of scientists.
 Out work aims to entirely automate this porting effort, so that more scientists
 can benefit from access to accelerators and parallel systems for their
 research.
 We have already reported our work on auto-parallelisation of FORTRAN 77
 code for GPUs in REF.
\end_layout

\begin_layout Standard
The focus of this paper is on a novel program transformation to reduce the
 memory utilisation of stencil-based scientific code after auto-parallelisation.
 For scientific computations, memory requirements are often the bottleneck,
 both in terms of the storage and of performance.
 Specifically the performance of stencil codes is often limited by memory
 bandwidth.
 Reducing memory utilisation allows simulations of larger problems or with
 higher resolution.
 Our main observation from real-life scientific code (in particular weather
 simulations and similar) is that many of the arrays used in typical simulation
 code are intermediate arrays, especially in the case of stencil computations.
 As an example, consider the Large Eddy Simulator for Urban Flows 
\begin_inset CommandInset citation
LatexCommand cite
literal "false"

\end_inset


\end_layout

\begin_layout Standard
This is a hurricane wind similator, so it simulates pressure and wind speed.
 Its actual inputs are the wind velocity in 3 dimensions (
\emph on
u,v,w
\emph default
) and the pressure (
\emph on
p
\emph default
), i.e.
\begin_inset space ~
\end_inset

four arrays for every domain.
 However, the code
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/wimvanderbauwhede/LES
\end_layout

\end_inset

 actually uses 15 arrays (Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Arrays-used-in"
plural "false"
caps "false"
noprefix "false"

\end_inset

): 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Fortran,float,mathescape=true,escapeinside={~~}"
inline false
status open

\begin_layout Plain Layout

real, dimension(im,jm,km) :: p
\end_layout

\begin_layout Plain Layout

real, dimension(im,jm,km) :: u,v,w
\end_layout

\begin_layout Plain Layout

real, dimension(im,jm,km) :: usum,vsum,wsum
\end_layout

\begin_layout Plain Layout

real, dimension(im,jm,km) :: f,g,h
\end_layout

\begin_layout Plain Layout

real, dimension(im,jm,km) :: fold,gold,hold
\end_layout

\begin_layout Plain Layout

real, dimension(im,jm,km) :: sm
\end_layout

\begin_layout Plain Layout

real, dimension(im,jm,km) :: rhs
\begin_inset Caption Standard

\begin_layout Plain Layout
Arrays used in the Fortran code of the  Large Eddy Simulator for Urban Flows
\begin_inset CommandInset label
LatexCommand label
name "lis:Arrays-used-in"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this particular case, 11 arrays are intermediate and can actually be
 replaced by scalar computations.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In total, the LES uses 57 3-D arrays for the GPU kernels.
 Of these, we really only need 4
\end_layout

\begin_layout Plain Layout
Of the 15 listed above, 11 are redundant.
\end_layout

\begin_layout Plain Layout
If we just consider a particular component of the simulation, the velocity
 calculation, we see that it uses 30 arrays.
 Of these 30, 27 are redundant.
 
\end_layout

\end_inset

If we could achieve this, the simulation could run on a 4 times larger domain
 with the same memory utilisation.
 In this paper we present a novel approach to aggressively reduce memory
 utilisation of stencil-based legacy scientific code that has been auto-parallel
ised for GPUs, through automatic program transformation.
 The problem with accelerators such as GPUs and FPGAs is that they use static
 memory allocation.
 Therefore, memory for intermediate arrays has to be allocated before a
 kernel runs and for the lifetime of all kernels that need access to this
 memory.
 This is quite different from e.g.
 temporary arrays in a subroutine call, where the compiler can allocate
 the memory at need using the dynamic allocation facility of the operating
 system.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
As a result of the staging, I am sure rhs cannot be removed.
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "related-work"

\end_inset


\end_layout

\begin_layout Itemize
The idea is to find some similar things but be able to say that nobody has
 done what we have done .
 Mainly because we do this on top of auto-parallelised code targetting GPUs
\end_layout

\begin_layout Itemize
Def cite the polyhaedral model
\end_layout

\begin_layout Itemize
Also def cite Lift
\end_layout

\begin_layout Section
Relationship to our existing work
\begin_inset CommandInset label
LatexCommand label
name "relationship-to-our-existing-work-and-contribution-of-this-work"

\end_inset


\end_layout

\begin_layout Standard
We have developed a compilation chain which can automatically transform
 legacy scientific code into GPU- and FPGA- accelerated variants 
\begin_inset CommandInset citation
LatexCommand cite
literal "false"

\end_inset

.
 In this work we make use of this compilation chain to transform the original
 code into a form that can be analysed for memory reduction.
 In particular, the code is refactored to remove global variables (
\family typewriter
COMMON
\family default
 in Fortran) and the loops are analysed in terms of 
\emph on
map
\emph default
 and 
\emph on
fold
\emph default
 higher-order functions.
 We have shown how to transform the code into map/fold based code for GPU
 acceleration 
\begin_inset CommandInset citation
LatexCommand cite
literal "false"

\end_inset

.
 Furthermore, motivated by the goal of accelerating code on FPGAs, we have
 developed a functional language, TyTraCL 
\begin_inset CommandInset citation
LatexCommand cite
literal "false"

\end_inset

.
 TyTraCL is used in our compilation chain as an intermediate language which
 expresses the program as as dataflow graph.
 This allows formal reasoning and and provably correct transformation of
 the code.
 Our source-to-source compiler can transform the map/fold based Fortran
 code into TyTraCL.
\end_layout

\begin_layout Standard
The program transformation which is the focus of this paper starts from
 the program in the TyTraCL language.
\end_layout

\begin_layout Section
Contribution of this work
\end_layout

\begin_layout Standard
The key contribution of this work is a program transformation on parallelised
 code targeted at GPUs which reduces memory utilisation by removal of intermedia
te arrays.
 
\end_layout

\begin_layout Standard
Specifically, the contributions of the current work are:
\end_layout

\begin_layout Itemize
An algorithm to detect stencils
\end_layout

\begin_layout Itemize
An algorithm to scalarise the kernels
\end_layout

\begin_layout Itemize
An algorithm to identify intermediate arrays
\end_layout

\begin_layout Itemize
A series of rewrite-rule-based program transformations to remove intermediate
 arrays
\end_layout

\begin_layout Standard
The key idea underpinning the current work is that we can trade memory storage
 for computation by recomputing values rather than reading them from memory.
 In particular our goal is to access only the actual input arrays and compute
 all intermediate values from these accesses.
 This reduces the memory requirements at the expense of additional computation.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
XXX Experiments will have to show if this is slower and by how much XXX
\end_layout

\end_inset


\end_layout

\begin_layout Section
The TyTraCL language
\begin_inset CommandInset label
LatexCommand label
name "the-tytracl-language"

\end_inset


\end_layout

\begin_layout Standard
Before we can discuss the contributions of the current work in detail, we
 first must introduce the TyTraCL language.
 Although TyTraCL is in practice an intermediate representation, the language
 has a concrete syntax to facilitate reasoning and proofs.
\end_layout

\begin_layout Subsection
TyTraCL concrete syntax
\begin_inset CommandInset label
LatexCommand label
name "tytracl-concrete-syntax"

\end_inset


\end_layout

\begin_layout Standard
The TyTraCL language is syntactically a subset of Haskell REF, with the
 addition of two types of vectors of fixed size, similar to the vector type
 in Idris REF.
 Purely for convenience we also define 
\family typewriter
zipt
\family default
, 
\family typewriter
unzipt
\family default
, 
\family typewriter
applyt
\family default
 and 
\family typewriter
elt
\family default
 which work on tuples of arbitrary size, as opposed to Haskell where an
 instance is needed for every tuple size.
\end_layout

\begin_layout Subsubsection
Types
\begin_inset CommandInset label
LatexCommand label
name "subsec:Types"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

v_i :: Vec n a
\end_layout

\begin_layout Plain Layout

s_i :: SVec k Int
\end_layout

\begin_layout Plain Layout

f_i :: a -> b
\end_layout

\end_inset

TyTraCL is a composition language, its aim is to express dataflow graphs.
 The actual input values and computations do not need to be defined, so
 instances of the above types are ony declared.
\end_layout

\begin_layout Subsubsection
Primitives
\begin_inset CommandInset label
LatexCommand label
name "subsec:Primitives"

\end_inset


\end_layout

\begin_layout Standard
The language has a small number of primitives, shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:TyTraCL-primitives"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

-- As in Haskell but on Vec rather than []
\end_layout

\begin_layout Plain Layout

map :: (a -> b) -> Vec n a -> Vec n b
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Haskell's foldl but on Vec rather than []
\end_layout

\begin_layout Plain Layout

fold :: (a -> b -> a) -> a -> Vec n b -> a
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Ordinary map but only works on SVec
\end_layout

\begin_layout Plain Layout

maps :: (a -> b) -> SVec k a -> SVec k b
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Every element of the vector is replaced by the stencil defined by the
 first argument
\end_layout

\begin_layout Plain Layout

stencil :: SVec k Int -> Vec n a -> Vec n (SVec k a)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Like Haskell's zip/unzip but takes a tuple as argument and works on Vec
\end_layout

\begin_layout Plain Layout

zipt :: Tup k (...,Vec n a_i,...)  -> Vec n $ Tup k (...,a_i,...)
\end_layout

\begin_layout Plain Layout

unzipt :: Vec n Tup k (...,a_i,...) -> Tup k (...,Vec n a_i,...)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Apply a tuple of functions to a tuple of values
\end_layout

\begin_layout Plain Layout

applyt :: Tup k (...,a_i -> b_i,...) -> Tup k (...,a_i,...) -> Tup k (...,b_i,...)
\end_layout

\begin_layout Plain Layout

applyt (...,f_i,...) (...,e_i,...) = 
\backslash
(...,e_i,...) -> (...,f_i e_i,...)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Generalisation of Haskell's fst/snd
\end_layout

\begin_layout Plain Layout

elt :: i:: Int -> (...,a_i,...) -> a_i
\end_layout

\begin_layout Plain Layout

elt i (...,e_i,...) = e_i
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Stencils can be combined using scomb
\end_layout

\begin_layout Plain Layout

scomb :: (SVec k_1 Int) -> (SVec k_2 Int) -> SVec k_1 (SVec k_2) Int
\end_layout

\begin_layout Plain Layout

stencil s2 (stencil s1 v1) = stencil (scomb s2 s1) v1
\begin_inset Caption Standard

\begin_layout Plain Layout
TyTraCL primitives
\begin_inset CommandInset label
LatexCommand label
name "lis:TyTraCL-primitives"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To formalise the definition of the 
\family typewriter
stencil
\family default
 primitive we present a possible Haskell implementation:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

stencil s v = map (
\backslash
idx -> map (
\backslash
delta ->(v !! (idx - 1 + delta)) s)) [1 ..
 length v]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For every element at position 
\emph on
idx
\emph default
 in the vector, this function returns a list of points at offsets 
\emph on
delta
\emph default
 from 
\emph on
idx
\emph default
, defined in the list 
\emph on
s
\emph default
.
 
\end_layout

\begin_layout Subsection
TyTraCL Abstract Syntax
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "tytracl-abstract-syntax"

\end_inset


\end_layout

\begin_layout Standard
In practice, the TyTraCL program transformations are implemented in Haskell.
 The abstract syntax for the untyped TyTraCL language, expressed as a Haskell
 type, is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:TyTraCL-AST-data"
plural "false"
caps "false"
noprefix "false"

\end_inset

 .
 
\begin_inset Quotes eld
\end_inset

Untyped
\begin_inset Quotes erd
\end_inset

 means that we are at this stage not concerned with the concrete types of
 the values contained in the input vectors or scalars.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

type Name = String
\end_layout

\begin_layout Plain Layout

    data VE = VI  | VO  | VS  | VT | VU
\end_layout

\begin_layout Plain Layout

        deriving (Show, Typeable, Data, Eq)            
\end_layout

\begin_layout Plain Layout

    type TyTraCLAST = [(Expr,Expr)]                      
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    data Expr =
\end_layout

\begin_layout Plain Layout

            -- Left-hand side:
\end_layout

\begin_layout Plain Layout

                          Scalar Name
\end_layout

\begin_layout Plain Layout

                        | Tuple [Expr] 
\end_layout

\begin_layout Plain Layout

                        | Vec VE Name
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            -- Right-hand side:
\end_layout

\begin_layout Plain Layout

                        | SVec Int Name -- Stencil vector
\end_layout

\begin_layout Plain Layout

                        | ZipT [Expr] -- generalised zip
\end_layout

\begin_layout Plain Layout

                        | UnzipT Expr -- generalised unzip
\end_layout

\begin_layout Plain Layout

                        | Elt Int Expr -- generalised tuple access
\end_layout

\begin_layout Plain Layout

                        | Map Expr Expr
\end_layout

\begin_layout Plain Layout

                        | Fold Expr Expr Expr
\end_layout

\begin_layout Plain Layout

                        | Stencil Expr Expr
\end_layout

\begin_layout Plain Layout

                        | Function Name Expr -- Expr contains args that
 are partially applied
\end_layout

\begin_layout Plain Layout

                        | Id
\end_layout

\begin_layout Plain Layout

                        | ApplyT [Expr] 
\end_layout

\begin_layout Plain Layout

                        | MapS Expr Expr
\end_layout

\begin_layout Plain Layout

                        | Comp Expr Expr -- function composition
\end_layout

\begin_layout Plain Layout

                        | FComp Expr Expr -- fold-map function composition
\end_layout

\begin_layout Plain Layout

                        | SComb Expr Expr
\end_layout

\begin_layout Plain Layout

                            deriving (Show, Typeable, Data, Eq)
\begin_inset Caption Standard

\begin_layout Plain Layout
TyTraCL AST data type in Haskell
\begin_inset CommandInset label
LatexCommand label
name "lis:TyTraCL-AST-data"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The property 
\family typewriter
VE
\family default
 encodes if a vector is an input 
\family typewriter
VI
\family default
, output 
\family typewriter
VO
\family default
, a vector of stencil vectors 
\family typewriter
VS
\family default
, or any other temporary 
\family typewriter
VT
\family default
.
 Initially this value is set to 
\family typewriter
VU
\family default
, 
\begin_inset Quotes eld
\end_inset

Unknown
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
For the 
\family typewriter
Function
\family default
 constructor, 
\family typewriter
[Expr]
\family default
 is a list of non-map/non-fold argument expressions, i.e.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

v_out = map (f x_1 ..
 x_m) v_in
\end_layout

\end_inset


\end_layout

\begin_layout Standard
is represented as
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

(Vec VO 
\begin_inset Quotes eld
\end_inset

v_out
\begin_inset Quotes erd
\end_inset

,Map (Function 
\begin_inset Quotes eld
\end_inset

f
\begin_inset Quotes erd
\end_inset

 [xe_1,...,xe_m]) (Vec VI 
\begin_inset Quotes eld
\end_inset

v
\begin_inset Quotes erd
\end_inset

))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $xe_{i}$
\end_inset

 is the expression corresponding to 
\begin_inset Formula $x_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
The typical use case is to pass constant arguments and scalars returned
 by 
\family typewriter
Fold
\family default
 operations.
 Furthermore, 
\family typewriter
Comp
\family default
 in the AST is function composition 
\begin_inset Formula $g\,\circ\,f$
\end_inset

, and 
\family typewriter
FComp
\family default
 is a convenience primitive which allows to rewrite a 
\emph on
fold
\emph default
 operating on a 
\emph on
map
\emph default
:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

fold g acc (map f v) = fold (g `fcomp` f) acc v
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
TyTraCL semantics
\begin_inset CommandInset label
LatexCommand label
name "tytracl-semantics"

\end_inset


\end_layout

\begin_layout Standard
TyTraCL can be viewed as a subset of Haskell with strict execution.
 This means that every 
\family typewriter
map
\family default
 call can be considered to return a new list, and therefore memory for this
 list will need to allocated.
 In this view, a 
\family typewriter
stencil
\family default
 of 
\emph on
k
\emph default
 points will require 
\emph on
k
\emph default
 times the memory allocation of the original vector.
\end_layout

\begin_layout Standard
However, it is also possible to view TyTraCl as a streaming language where
 a 
\family typewriter
map
\family default
 call consumes the elements of the input vector as a stream and the result
 is immediately passed on to the next call.
 In this view, the 
\family typewriter
stencil
\family default
 call creates a new stream of stencils around every given point in the original
 stream.
 To do so it buffers the stream until all elements of the stencil are in
 the buffer.
 A crucial observation here is that there is no need for additional buffering
 if we create a stencil from an input vector, as they are stored in the
 main memory.
\end_layout

\begin_layout Standard
It is clear that implementation of the stream-based view will require considerab
ly less memory than the strict vector-based view.
\end_layout

\begin_layout Section
From the original sequential code to auto-parallelised code
\begin_inset CommandInset label
LatexCommand label
name "from-the-original-fortan-code-to-auto-parallelised-code"

\end_inset


\end_layout

\begin_layout Standard
The typical pattern of stencil code is a sequential application of nested
 loops.
 Slightly simplified, our auto-parallelising compiler analyses the loop
 dependencies in terms of 
\emph on
map
\emph default
 (dependency-free loops) and 
\emph on
fold
\emph default
 (reductions) and refactors the code into separate subroutines for every
 loop nest, called 
\emph on
kernels
\emph default
.
 At this stage, these subroutines still perform indexed array accesses,
 i.e.
\begin_inset space ~
\end_inset

they are not yet pure functions 
\begin_inset Formula $a\rightarrow b$
\end_inset

 or 
\begin_inset Formula $a\rightarrow b\rightarrow a$
\end_inset

, but we already have the guarantee that they can be transformed into such
 pure functions.
 In other words, the program is semantically similar to programs in a functional
 array language such as Single-Assignment C (SaC, REF).
 This form is suitable for e.g.
\begin_inset space ~
\end_inset

parallelisation on CPU or GPU using OpenCL, as shown in REF.
 
\end_layout

\begin_layout Section
Preparatory transformations
\begin_inset CommandInset label
LatexCommand label
name "preparatory-transformations"

\end_inset


\end_layout

\begin_layout Standard
In this section we describe the program transformations which transform
 the code as generated by our auto-parallelising compiler into the TyTraCL
 code that will serve as our starting point.
\end_layout

\begin_layout Standard
To transform the kernels into the final scalar functions required by TyTraCL,
 we apply three additional transformations: stencil detection, scalarisation
 and argument grouping.
\end_layout

\begin_layout Subsection
Stencil detection
\begin_inset CommandInset label
LatexCommand label
name "stencil-detection"

\end_inset


\end_layout

\begin_layout Standard
Array accesses are divided into read and write access.
 Stencils are defined as patterns of read accesses with fixed offsets around
 the loop iterators.
 An array access pattern is a stencil if: 
\end_layout

\begin_layout Itemize
There is more than one read access to the array 
\end_layout

\begin_layout Itemize
At least one of these accesses has a non-zero offset
\end_layout

\begin_layout Itemize
The set of offsets is fixed for all iterations of the loop
\end_layout

\begin_layout Itemize
All points in the array are processed in order, i.e.
\begin_inset space ~
\end_inset

the loop iterators loop over a contiguous range 
\end_layout

\begin_layout Itemize
There can be no write access to the array.
\end_layout

\begin_layout Standard
We can express these requirements also using the TyTraCL primitives, specificall
y the 
\emph on
stencil
\emph default
 primitive defined above.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
s & ::\mbox{SVec}\,k\,\mbox{Int}\\
s & =[\Delta_{1},\dots,\Delta_{k}]\\
v_{in} & ::\mbox{Vec}\,n\,a\\
v_{s} & ::\mbox{Vec}\,n\,\mbox{SVec}\,k\,a\\
v_{s} & =\mbox{stencil}\,s\,v_{in}\\
f & ::\mbox{SVec}\,k\,a\rightarrow b\\
v_{out} & ::\mbox{Vec}\,n\,b\\
v_{out} & =\mbox{map}\,f\,v_{s}
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Scalarisation
\begin_inset CommandInset label
LatexCommand label
name "scalarisation"

\end_inset


\end_layout

\begin_layout Standard
Scalarisation refers to transforming the kernel functions into pure functions
 that can be mapped or folded.
 This is done by replacing all array accesses with scalars.
 The algorithm is surprisingly simple: 
\end_layout

\begin_layout Itemize
Transliterate every array access into a scalar variable name as follows
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

scalar_var_str = filter (/= ' ') (
\end_layout

\begin_layout Plain Layout

      map 
\backslash
c -> case c of 
\end_layout

\begin_layout Plain Layout

          '(' -> '_'
\end_layout

\begin_layout Plain Layout

          ',' -> '_'
\end_layout

\begin_layout Plain Layout

          '+' -> p
\end_layout

\begin_layout Plain Layout

          '-' -> m
\end_layout

\begin_layout Plain Layout

          '*' -> t
\end_layout

\begin_layout Plain Layout

          ')' -> ' '
\end_layout

\begin_layout Plain Layout

      ) array_access_string
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Replace the array arguments of the kernel subroutine with the scalarised
 names.
 In the case of a stencil, the array argument is replaced by the sequence
 of scalar variables in the stencil, ordered by the numeric offset of the
 stencil access.
 
\end_layout

\begin_layout Itemize
Needless to say, this operation is preceded by a constant propagation and
 folding pass to ensure that all index variables in the array are loop iterators.
\end_layout

\begin_layout Subsection
Argument grouping
\begin_inset CommandInset label
LatexCommand label
name "argument-grouping"

\end_inset


\end_layout

\begin_layout Standard
A Fortran subroutine takes and returns values via its argurment list.
 To obtain the final TyTraCL function signature, we must group the scalarised
 arguments to get the required type for mappable and foldable functions.
 In the most general case, a mappable kernel subroutine can take vector
 arguments to mapped and any other read-only scalar arguments, and return
 vector arguments; a foldable kernel subroutine can take vector arguments
 to folded, accumulator arguments which ar typically readabe and writeable,
 and any other read-only scalar arguments.
 Our previous analysis has already resolved if an argument is used for input,
 output or both (i.e.
 we infer the Fortran INTENT attribute), and of course we know which arguments
 originally were arrays, and which of these have stencil accesses.
 With this information, it is straightforward to transform the scalarised
 Fortran kernel signature into the correct signature for the TyTraCL by
 first grouping the stencil arguments into stencil vectors and then grouping
 the arguments into tuples.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Fortran,mathescape=true,escapeinside={~~}"
inline false
status open

\begin_layout Plain Layout

! original code
\end_layout

\begin_layout Plain Layout

subroutine f(a, v_in, v_out)
\end_layout

\begin_layout Plain Layout

	real, intent(in) :: a
\end_layout

\begin_layout Plain Layout

    real, dimension(im), intent(in) :: v_in
\end_layout

\begin_layout Plain Layout

    real, dimension(im), intent(out) :: v_out
\end_layout

\begin_layout Plain Layout

    integer :: i
\end_layout

\begin_layout Plain Layout

    do i=1,im
\end_layout

\begin_layout Plain Layout

    v_out(i)=a*(v_in(i-1)+v_in(i+1))/2
\end_layout

\begin_layout Plain Layout

    end do
\end_layout

\begin_layout Plain Layout

end subroutine f
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

! scalarised code
\end_layout

\begin_layout Plain Layout

subroutine f(a, v_in_im1, v_in_ip1, v_out)
\end_layout

\begin_layout Plain Layout

    real, intent(in) :: a,v_in_im1, v_in_ip1
\end_layout

\begin_layout Plain Layout

    real :: v_out
\end_layout

\begin_layout Plain Layout

    v_out=a*(v_in_im1+v_in_ip1)/2
\end_layout

\begin_layout Plain Layout

end subroutine f
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In TyTraCL the types and signature become:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

a :: Float
\end_layout

\begin_layout Plain Layout

sv_in :: SVec 2 Float
\end_layout

\begin_layout Plain Layout

v_out :: Float
\end_layout

\begin_layout Plain Layout

f :: Float -> SVec 2 Float -> Float
\end_layout

\begin_layout Plain Layout

v_out = f a sv_in
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Key transformation of stencil-based nested loops
\begin_inset CommandInset label
LatexCommand label
name "key-transformation-of-stencil-based-nested-loops"

\end_inset


\end_layout

\begin_layout Standard
The above analysis allows to extract the stencil pattern and transform any
 stencil computation into a combination of a 
\family typewriter
stencil
\family default
 call and a 
\family typewriter
map
\family default
 or 
\family typewriter
fold
\family default
 call.
 For example, the above code becomes 
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

s = [-1,1]
\end_layout

\begin_layout Plain Layout

sv_in = stencil s v
\end_layout

\begin_layout Plain Layout

v_out = map (f a) sv_in 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Intermediate vector removal, Part I: the easy part
\begin_inset CommandInset label
LatexCommand label
name "intermediate-vector-removal-part-i-the-easy-part"

\end_inset


\end_layout

\begin_layout Standard
The purpose of the program transformations that follow is to eliminate intermedi
ate vectors.
 These may occur because of the need for stencils; or they might be present
 in the original code.
 
\end_layout

\begin_layout Itemize
If an intermediate vector is present in the original code, we have something
 like 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

v1 = map f1 v0
\end_layout

\begin_layout Plain Layout

v2 = map f2 v1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and we can replace 
\family typewriter
v1
\family default
 with its definition (
\begin_inset Formula $\beta$
\end_inset

 reduction).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

v2 = map f2 $ map f1 v0
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
If there is a stencil, it can either occur between a 
\family typewriter
map
\family default
 and a 
\family typewriter
map
\family default
 or between a 
\family typewriter
map
\family default
 and a 
\family typewriter
fold
\family default
 but nowhere else, because stencils are only introduced before the operation
 that requires them, and that is always a 
\family typewriter
map
\family default
 or a 
\family typewriter
fold
\family default
.
 And the preceding computation can only be a map.
 Note also that a stencil call only ever operates on a vector of scalars
 or stencils, not on a vector of tuples E.g.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

v1 = map f1 v0
\end_layout

\begin_layout Plain Layout

  v1_s = stencil s1 v1
\end_layout

\begin_layout Plain Layout

  v2 = map f2 v1_s
\end_layout

\begin_layout Plain Layout

  
\end_layout

\end_inset

or 
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

v1 = map f1 v0
\end_layout

\begin_layout Plain Layout

  v1_s = stencil s1 v1
\end_layout

\begin_layout Plain Layout

  acc2 = fold f2 acc0 v1_s
\end_layout

\end_inset

Now, after the second pass this will become 
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

acc2 = fold f2 acc0 (stencil s1 (map f1 v0))
\end_layout

\end_inset

This will then be rewritten into 
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

acc2 = fold f2 acc0 (map (maps f1) (stencil s1 v0))
\end_layout

\end_inset

Thus we can always remove the intermediate vectors of stencils.
\end_layout

\end_deeper
\begin_layout Standard
With the program expressed in TyTraCL we perform first a normalisation transform
ation and then the actual intermediate vector removal.
 The intermediate vector identification is trivial: we know the input and
 output arrays as well as any vector resulting from a stencil application.
 Any remaining vector is an intermediate.
\end_layout

\begin_layout Subsection
AST Normalisation
\begin_inset CommandInset label
LatexCommand label
name "normalisation"

\end_inset


\end_layout

\begin_layout Standard
Recall that the TyTraCL AST is a list of tuples 
\emph on
[(Expr,Expr)]
\emph default
 where the elements of the tuple are the LHS and RHS of an assignment in
 a 
\emph on
let
\emph default
-binding.
\end_layout

\begin_layout Standard
First we normalise so the LHS of any element in the TyTraCLAST list is either
 Vec or Scalar.
 We do this by replacing all LHS 
\emph on
Tuple
\emph default
 occurrences with multiple expressions that apply 
\emph on
Elt
\emph default
 to the RHS:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

(Tuple [Vec ve1 
\begin_inset Quotes eld
\end_inset

v1
\begin_inset Quotes erd
\end_inset

, Vec ve2 
\begin_inset Quotes eld
\end_inset

v2
\begin_inset Quotes erd
\end_inset

], UnzipT expr)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
becomes
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

(Vec ve1 
\begin_inset Quotes eld
\end_inset

v1
\begin_inset Quotes erd
\end_inset

, (Elt 0 (UnzipT expr )))
\end_layout

\begin_layout Plain Layout

(Vec ve2 
\begin_inset Quotes eld
\end_inset

v2
\begin_inset Quotes erd
\end_inset

, (Elt 1 (UnzipT expr )))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a result, after this normalisation any LHS expression will be either
 
\emph on
Vec
\emph default
 or 
\emph on
Scalar
\emph default
, i.e.
 atomic expressions.
 
\end_layout

\begin_layout Subsection
Intermediate vector removal algorithm
\begin_inset CommandInset label
LatexCommand label
name "intermediate-vector-removal-algorithm"

\end_inset


\end_layout

\begin_layout Standard
After this normalisation we remove all vectors 
\emph on
Vec VT
\emph default
 and 
\emph on
Vec VS
\emph default
, and also 
\emph on
Vec VO
\emph default
 on the RHS, by recursive substitution, starting from the last expression
 in the list.
 The resulting AST has only 
\emph on
Vec VO
\emph default
 (or 
\emph on
Scalar
\emph default
) in the LHS, and the RHS expressions only contain 
\emph on
Vec VI
\emph default
.
\end_layout

\begin_layout Section
Intermediate vector removal, Part II: the hard part
\begin_inset CommandInset label
LatexCommand label
name "intermediate-vector-removal-part-ii-the-hard-part"

\end_inset


\end_layout

\begin_layout Standard
Although all intermediate vectors have been removed, this removal so far
 is purely in terms of the occurrences in the AST.
 Were we to run the program, it would require memory for implicit temporary
 vectors.
 This is because an intermediate stencil will require additional memory.
\end_layout

\begin_layout Standard
We have developed a system of rewrite rules that transforms the program
 into a sequence of dependent 
\emph on
fold
\emph default
 operations with no more than a single 
\emph on
map
\emph default
 operation.
 All stencils operate on input vectors only.
 Thus, the entire computation in the program is a chain of scalar functions,
 and does therefore not need any memory allocation for intermediate arrays;
 any stencils in the input vectors are constructed directly from the arrays
 in main memory, so that they again do not require any additional memory
 allocation.
\end_layout

\begin_layout Standard
This system of rewrite rules is the key contribution of this paper.
\end_layout

\begin_layout Subsection
Rewrite rules
\begin_inset CommandInset label
LatexCommand label
name "rewrite-rules-theorem"

\end_inset


\end_layout

\begin_layout Standard
Given the AST in normalised form and the rewrite rules shown in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Rewrite-rules-to"
plural "false"
caps "false"
noprefix "false"

\end_inset

: 
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

map f_2 (map f_1 v) = map (f_2 .
 f_1) v -- Map-Map
\end_layout

\begin_layout Plain Layout

fold f_1 acc (map f_2 v) = Fold (f1 `fcomp` f2) acc v -- Fold-Map
\end_layout

\begin_layout Plain Layout

stencil s_1 (map f_1) = map (maps f_1) (stencil s_1) -- Stencil-Map
\end_layout

\begin_layout Plain Layout

zipt (map f_1 v_1, map f_2 v_2, ..., map f_1 v_1, ...) 
\end_layout

\begin_layout Plain Layout

    = map (applyt (f_1,f_2, ..., f_i, ...)) (zipt (v_1, v_2, ..., v_i, ...)) -- ZipT-Map
 
\end_layout

\begin_layout Plain Layout

v = map id v -- Map-Id
\end_layout

\begin_layout Plain Layout

(elt i) .
 unzipt .
 (map f v) = map ((elt i) .
 f) v -- Elt-UnzipT-Map
\begin_inset Caption Standard

\begin_layout Plain Layout
Rewrite rules to obtain an expression with a single 
\emph on
map
\begin_inset CommandInset label
LatexCommand label
name "lis:Rewrite-rules-to"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Theorem
Applying the rewrite rules in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Rewrite-rules-to"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to the normalised AST, starting from the leaf nodes, always terminates
 with an expression which contains only a single map, as the outer function.
 
\end_layout

\begin_layout Subsubsection
Lemmas
\begin_inset CommandInset label
LatexCommand label
name "lemmas"

\end_inset


\end_layout

\begin_layout Standard
First we prove that the rewrite rules themselves are correct.
 The 
\emph on
Map-Map
\emph default
 rule is well-known; the 
\emph on
Map-Fold
\emph default
 rule is a trivial extension of the 
\emph on
Map-Map
\emph default
 rule; the 
\emph on
Map-Id
\emph default
 rule is trivial.
 
\end_layout

\begin_layout Proof
for the Stencil-Map rewrite rule
\begin_inset CommandInset label
LatexCommand label
name "proof-for-the-stencil-map-rewrite-rule"

\end_inset

 
\end_layout

\begin_layout Itemize
Given the vectors of size 
\emph on
n
\emph default
 
\emph on
v0
\emph default
 and 
\emph on
v1
\emph default
 and a scalar function 
\emph on
f1
\emph default
 :
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

v0 :: Vec n a
\end_layout

\begin_layout Plain Layout

v1 :: Vec n b
\end_layout

\begin_layout Plain Layout

f1 :: a -> b
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

v0 = [e0_0, e0_1, ..., e0_{n-1}]
\end_layout

\begin_layout Plain Layout

v1 = [f1 e0_0, f1 e0_1, ..., f1 e0_{n-1}]
\end_layout

\begin_layout Plain Layout

 = [e1_0, e1_1, ..., , e1_{n-1}] 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Given s1 an SVec of indices of size k
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

s1 :: SVec k Int
\end_layout

\begin_layout Plain Layout

s1 = [i_1,i_2,...,i_k]
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Rewriting the LHS:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

stencil s1 (map f1 v0) 
\end_layout

\begin_layout Plain Layout

= stencil s1 v1
\end_layout

\begin_layout Plain Layout

= v1s
\end_layout

\begin_layout Plain Layout

where 
\end_layout

\begin_layout Plain Layout

v1s = [e1s_0, e1s_1, ...]
\end_layout

\begin_layout Plain Layout

e1s_j = [e1_{j+i_1},e1_{j+i_2},...e1_{j+i_k},], ~$
\backslash
forall j 
\backslash
in [0 ..
 n-1]$~
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Rewriting the RHS:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

map (maps s1 f1) (stencil s1 v0) = map (maps s1 f1) v0s
\end_layout

\begin_layout Plain Layout

where
\end_layout

\begin_layout Plain Layout

v0s = [e0s_0, e0s_1, ...] e0s_j = [e0_{j+i_1},e0_{j+i_2},...e0_{j+i_k},]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rewriting the maps sub-expression
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

(maps s1 f1) e0s_j 
\end_layout

\begin_layout Plain Layout

= maps s1 f1 [e0_{j+i_1},e0_{j+i_2},...e0_{j+i_k},]
\end_layout

\begin_layout Plain Layout

= [f1 e0_{j+i_1},f1 e0_{j+i_2},...,f1 e0_{j+i_k},]
\end_layout

\begin_layout Plain Layout

= [e1_{j+i_1},e1_{j+i_2},..., e1_{j+i_k}]
\end_layout

\begin_layout Plain Layout

= e1s_j, for all j in 0 ..
 n-1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and thus
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

map (maps s1 f1) v0s = v1s
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Proof
for the ZipT-Map rewrite rule
\begin_inset CommandInset label
LatexCommand label
name "proof-for-the-zipt-map-rewrite-rule"

\end_inset

 
\end_layout

\begin_layout Itemize
Given that all exprs in the tuple are map expressions 
\end_layout

\begin_layout Itemize
Express the vectors in terms of their elements: 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

v_i = [e_i_0, ...]
\end_layout

\begin_layout Plain Layout

  (zipt (v_1, v_2) = [(e_1_0,e_2_0),...]
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Substitute in the LHS of the rule: 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

zipt (map f_1 v_1, map f_2 v_2) = zipt ([f_1 e_1_0, f_1 e_1_1, ...], [f_2 e_2_0,
 f_2 e_2_1, ...])
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Apply the 
\family typewriter
map
\family default
 and 
\family typewriter
zipt
\family default
 definitions 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

= [(f_1 e_1_0,f_2 e_2_0),(f_1 e_1_1,f_2 e_2_1),] 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Apply the 
\family typewriter
apply
\family default
 definition
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

= [ applyt (f1,f_2) (e_1_0,e_2_0),applyt (f1,f_2) (e_1_1,e_2_1), ] 
\end_layout

\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
Apply the 
\family typewriter
map
\family default
 definition 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

= map (applyt (f1,f_2)) [(e_1_0,e_2_0),(e_1_1,e_2_1),] 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Apply the 
\family typewriter
zipt
\family default
 definition
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

 = map (applyt (f1,f_2)) (zipt (v_1, v_2)) 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Proof(QED)
for the Elt-UnzipT-Map rewrite rule
\begin_inset CommandInset label
LatexCommand label
name "proof-for-the-elt-unzipt-map-rewrite-rule"

\end_inset

 
\end_layout

\begin_layout Itemize
Given 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

f :: a -> (a_1,a_2)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
On the LHS, writing out with elements and applying the definition of 
\family typewriter
map
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard
map f v = [f e_0, f e_1, \SpecialChar ldots
] = [(e_1_0, e_2_0),(e_1_1, e_2_1),\SpecialChar ldots
] 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

f :: a -> (a_1,a_2)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Applying the definition of 
\family typewriter
unzipt
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

unzipt (map f v) = unzipt [(e_1_0, e_2_0),(e_1_1, e_2_1),] = ([e_1_0, e_1_1,],[e
_2_0,e_2-1,]) 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Applying 
\family typewriter
elt
\begin_inset space \space{}
\end_inset

i
\family default
, e.g.
\begin_inset space ~
\end_inset

for i = 0
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

(elt i) (unzipt (map f v)) = [e_1_0, e_1_1,] = v_1 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
On the RHS, write the vector 
\family typewriter
v
\family default
 in terms of its elements:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

v = [e_0, e_1,  e_j, ] 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Apply 
\family typewriter
f
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

f e_j = (e_1_j, e_2_j) 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Apply 
\family typewriter
elt
\begin_inset space \space{}
\end_inset

i
\family default
, e.g.
\begin_inset space ~
\end_inset

for i = 0
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

elt 0 (f e_l) = elt 0 (e_1_j, e_2_j) = e_1_j 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Do this for all 
\emph on
j
\emph default
 by applying 
\family typewriter
map
\family default
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

= [e_1_0, e_1_1, , e_1_j, ] = v_1 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Proof of the Rewrite Rule Theorem
\begin_inset CommandInset label
LatexCommand label
name "proof-of-the-rewrite-rule-theorem"

\end_inset


\end_layout

\begin_layout Proof
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
The primitives in the language that return a 
\family typewriter
Vec
\family default
 type are the vector type constructor and the functions 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

map
\end_layout

\begin_layout Plain Layout

stencil
\end_layout

\begin_layout Plain Layout

zipt
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Apart from that, only the expression 
\begin_inset listings
lstparams "language=Haskell,mathescape=true,escapeinside={~~}"
inline true
status open

\begin_layout Plain Layout

(elt i) .
 unzipt
\end_layout

\end_inset

 also returns a vector.
 Because of the earlier normalisation, 
\family typewriter
unzipt
\family default
 will always be preceded by 
\family typewriter
(elt
\begin_inset space \space{}
\end_inset

i)
\family default
 so from the perspective of the rewrite rule this is a primitive.
\end_layout

\begin_deeper
\begin_layout Standard
Therefore, if any of these acts on a 
\family typewriter
map
\family default
 expression, one of the rules will fire and result in an expression with
 a single map as the outer function.
 
\end_layout

\end_deeper
\begin_layout Itemize
The 
\family typewriter
Map-ZipT
\family default
 rule entails an extra condition that all elements of the tuple must be
 
\family typewriter
map
\family default
 expressions, so any elements that can't be rewritten into a 
\family typewriter
map
\family default
 expressions using the other rules are turned into 
\family typewriter
map
\family default
 expressions by applying a 
\family typewriter
map
\family default
 over the identity function.
 
\end_layout

\begin_layout Itemize
If the an expression is of the form 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

map (~$
\backslash
hbox{expression without}$~ map) 
\end_layout

\end_inset

then none of the rules fires, so this is a fixed point for the rewrite system.
\end_layout

\end_deeper
\begin_layout Subsection
Fusing stencils
\begin_inset CommandInset label
LatexCommand label
name "corrolary-regarding-the-stencils"

\end_inset


\end_layout

\begin_layout Standard
We note that `all stencils operate on input vectors only' follows from the
 fact that stencils only operate on vectors; vectors can result from any
 of the expressions in the LHS or RHS of the above rules.
 But given that the system terminates, any LHS expression will have been
 rewritten into an RHS one, and there will ony be a single map application
 in this expression.
 A stencil will therefore operate on an expression consisting only of input
 vectors, 
\family typewriter
zipt
\family default
 and 
\family typewriter
stencil
\family default
.
 A 
\family typewriter
stencil
\family default
 operating on a 
\family typewriter
stencil
\family default
 expression can 
\emph on
per definition
\emph default
 be rewritten as a single stencil using of 
\family typewriter
scomb
\family default
: 
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

stencil s2 (stencil s1 v1) = stencil (scomb s2 s1) v1 -- SComb 
\end_layout

\end_inset

A 
\family typewriter
stencil
\family default
 operating on a 
\family typewriter
zipt
\family default
 expression can be rewritten as a 
\family typewriter
zipt
\family default
 operating on a tuple of stencil expressions: 
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

stencil s2 (zipt (v1,v2)) = zipt (stencil s2 v1,stencil s2 v2) -- Stencil-ZipT
\end_layout

\end_inset


\end_layout

\begin_layout Proof(QED)
for Stencil-ZipT
\end_layout

\begin_layout Proof(QED)
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

stencil s1 (zipt (stencil s2 v1,stencil s2 v2))
\end_layout

\begin_layout Plain Layout

    = stencil s1 $ stencil s2 (zipt (v1,v2))
\end_layout

\begin_layout Plain Layout

    = stencil (scomb s1 s2) (zipt (v1,v2))
\end_layout

\begin_layout Plain Layout

    = zipt (stencil (scomb s1 s2) v1,stencil (scomb s1 s2) v2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, if the initial vector expression is a 
\family typewriter
zipt
\family default
, we recursively apply the above rules on each element.
 The Haskell code for the algorithm is:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

fuseStencils (Stencil s_1 (Stencil s_2 v_expr)) = Stencil (SComb s_1 s_2)
 v_expr
\end_layout

\begin_layout Plain Layout

fuseStencils (Stencil s (ZipT v_exprs)) = ZipT (map (Stencil s) v_exprs)
\end_layout

\begin_layout Plain Layout

fuseStencils (ZipT v_exprs) = ZipT (map fuseStencils v_exprs)
\end_layout

\begin_layout Plain Layout

fuseStencils v_expr = v_expr
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Decomposing the expressions
\end_layout

\begin_layout Standard
At this stage the TyTraCL program has been transformed to meet our objective:
 stencils operate only on input vectors, and there is a sequence of dependent
 folds with at most a single map operation.
 Conceptually, this means that the map operation consumes a stream of input
 vectors, creating stencils as required, an applies to this composite stream
 a composite scalar function which performs the actual computations.
 The program is now an ordered list of expressions which each represent
 a self-contained loop nest, and which in principle can depend upon any
 of the previous expressions.
 As 
\emph on
Map
\emph default
 and 
\emph on
Fold
\emph default
 nodes can depend on results from earlier 
\emph on
Fold
\emph default
 nodes, and folds always cosnume the entire vector, the folds are executed
 in dependency order.
 In the final imperative code, the entries in this list are ordered to ensure
 that executing them sequentially satisfies the dependencies.
\end_layout

\begin_layout Standard
The next step is to transform the program into a form suitable for emitting
 code in an imperative language such as Fortran or C.
 A suitable representation for this purpose is Administrative Normal Form
 REF; we use a variant where rather than nested let-expressions there is
 a single let with all bindings in order of dependency.
 The algorithm is quite straightforward.
 We create new names to bind all sub expressions in an expression (i.e.
 the RHS element in the TyTraCL AST)  using a running counter, the type
 of the sub expression and the name of the output vector to which the expression
 is bound.
\end_layout

\begin_layout Itemize

\family typewriter
MapS
\family default
, 
\family typewriter
ApplyT
\family default
, 
\family typewriter
Comp
\family default
 are replaced by named functions, e.g.
 for 
\family typewriter
MapS
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

MapS _ _ -> let f_expr = Function ("f_maps_"++vec_name++"_"++(show ct))
 [] in ...
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
Stencil
\family default
 expressions replaced by a new 
\family typewriter
VS
\family default
 vector 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

Stencil (SVec n _) _ -> let var = Vec VS ("svec_"++vec_name++"_"++(show
 ct)) in ...
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
ZipT
\family default
 and 
\family typewriter
Elt .
 UnzipT
\family default
 are replaced by a new 
\family typewriter
VT
\family default
 vector
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

_ -> let var = Vec VT ("vec_"++vec_name++"_"++(show ct))
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
All other sub-expressions are left unchanged
\end_layout

\begin_layout Standard
The algorithm traverses the AST in bottom-up fashion and effectively replaces
 every node with a list of let bindings for its sub-expressions.
 The result is a lists of lists which has the correct order for imperative
 computation.
 
\end_layout

\begin_layout Subsection
Generating the intermediate function definitions
\end_layout

\begin_layout Standard
To generate imperative code from this representation, the final challenge
 is to generate the definitions for the intermediate functions.
 Given the signatures of the original functions and the expressions representing
 the abstract syntax of the intermediate functions, what we need is a set
 of rules to infer the signatures and logic.
 
\end_layout

\begin_layout Subsubsection
Stencil definition and application
\begin_inset CommandInset label
LatexCommand label
name "subsec:Stencils"

\end_inset


\end_layout

\begin_layout Standard
Generation of stencil vector expressions is straightforward, the stencil
 definition contains the offsets at which each of the values in the returned
 tuple are read from the original array.
 Stencils are composable: a stencil 
\begin_inset Formula $s_{1}$
\end_inset

 of size 
\begin_inset Formula $k_{1}$
\end_inset

 of a stencil 
\begin_inset Formula $s_{2}$
\end_inset

 of size 
\begin_inset Formula $k_{2}$
\end_inset

 becomes a new stencil 
\begin_inset Formula $s_{12}$
\end_inset

 of size 
\begin_inset Formula $k_{1}*k_{2}$
\end_inset

 consisting of the sums of the offsets in 
\begin_inset Formula $s_{1}$
\end_inset

 and 
\begin_inset Formula $s_{2}$
\end_inset

.
 We can implement the 
\family typewriter
SComb
\family default
 operation either by calculation the combined offset 
\emph on
in situ
\emph default
 or by creating a new stencil definition as 
\begin_inset Formula $[d_{1}+d_{2}\,|\,d_{1}\leftarrow s_{1}\,,\,d_{2}\leftarrow s_{2}]$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Intermediate functions
\end_layout

\begin_layout Standard
The first step in generation of the intermediate functions is infering the
 signature based on the signatures of the original functions and the higher-orde
r functions that operate on them.
 The types of these higher order functions are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathsf{maps} & ::(a\rightarrow b)\rightarrow\mbox{SVec}\,k\,a\rightarrow\mbox{SVec}\,k\,a\\
\mathsf{applyt} & ::\mbox{Tup}\,k\,(\dots,a_{i}\rightarrow b_{i},\dots)\rightarrow\mbox{Tup}\,k\,(\dots,a_{i},\dots)\rightarrow\mbox{Tup}\,k\,(\dots,b_{i},\dots)\\
\mathsf{comb} & ::(b\rightarrow c)\rightarrow(a\rightarrow b)\rightarrow(a\rightarrow c)\\
\mathsf{fcomb} & ::(c\rightarrow b\rightarrow c)\rightarrow(a\rightarrow b)\rightarrow(c\rightarrow a\rightarrow c)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
It is thus again straightforward to derive the types for the intermediate
 functions.
 The actual function definitions are of course the trivial applications
 of these higher-order functions, the only complexity is in converting this
 code into Fortran or C.
\end_layout

\begin_layout Section
Fortran-OpenCL implementation
\begin_inset CommandInset label
LatexCommand label
name "fortran-opencl-implementation"

\end_inset


\end_layout

\begin_layout Standard
To generate imperative code (in our case Fortran 90) from the TyTraCL AST,
 the main challenge is the generation of the intermediate functions.
 For this we need the actual concrete type information for the input and
 output vectors and scalars and the signatures of the original functions.
 This requires extending the following Expr type variants with a type field:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

data DType = 
\end_layout

\begin_layout Plain Layout

    DInt 
\end_layout

\begin_layout Plain Layout

  | DFloat 
\end_layout

\begin_layout Plain Layout

  | DSVec Int DType 
\end_layout

\begin_layout Plain Layout

  | DTuple [DType]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

data Expr =
\end_layout

\begin_layout Plain Layout

-- Left-hand side:
\end_layout

\begin_layout Plain Layout

              Scalar VE DType Name
\end_layout

\begin_layout Plain Layout

            | Vec VE DType Name
\end_layout

\begin_layout Plain Layout

			...
\end_layout

\begin_layout Plain Layout

-- Right-hand side:           
\end_layout

\begin_layout Plain Layout

            | Function Name [Expr] 
\end_layout

\begin_layout Plain Layout

            | Id DType
\end_layout

\begin_layout Plain Layout

			...
\begin_inset Caption Standard

\begin_layout Plain Layout
Extending the TyTraCL AST with concrete type information
\begin_inset CommandInset label
LatexCommand label
name "lis:Extending-the-TyTraCL"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We now present the code generation for each of the TyTraCL primitives, using
 examples from the 2-D shallow water simulation REF.
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Note Note
status open

\begin_layout Plain Layout
To recreate the Fortran code from the AST, I need the signatures for the
 original scalarised Fortran subroutines as well as the signatures for the
 TyTraCL functions.
 And I also need signatures for the generated functions.
 I will then need to generate wrapper functions to go between the TyTraCL
 functions and the Fortran routines.
 Essentially, packing/unpacking of stencil tuples.
 A lot of this has been done in 
\family typewriter
RefactorF4Acc::Translation::LlvmToTyTraIR
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SVec encoding
\begin_inset CommandInset label
LatexCommand label
name "svec-encoding"

\end_inset


\end_layout

\begin_layout Standard
The stencil 
\family typewriter
SVec
\begin_inset space \space{}
\end_inset

s_i_
\begin_inset space \space{}
\end_inset

sz
\begin_inset space \space{}
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

s_i
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset


\family default
 is encoded as a 1-D array which contains the index offset tuple for each
 stencil point.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
For a paper I think making this work for 2-D arrays is fine.
 For every global index value, we derive 
\family typewriter
j
\family default
 and 
\family typewriter
k
\family default
 as usual.
 Then we populate the array 
\family typewriter
v_s
\family default
 with the values at the points in 
\family typewriter
v
\family default
 references by the stencil around 
\family typewriter
(j,k)
\family default
.
\end_layout

\begin_layout Plain Layout
We can emit all of these from the stencil pattern info, see e.g.
\begin_inset space ~
\end_inset


\family typewriter
RefactorF4Acc::Translation::TyTraCL::generate_TyTraCL_stencils()
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Stencil
\begin_inset CommandInset label
LatexCommand label
name "stencil"

\end_inset


\end_layout

\begin_layout Standard
Given the stencil information, we can generate the stencil as a constant
 array.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

stencilDefs = [("s1" , [-502,-1,0,1,502] ), ...]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stencilAppl = (
\end_layout

\begin_layout Plain Layout

	Vec VS DInt "svec_eta_1_0",
\end_layout

\begin_layout Plain Layout

	Stencil (SVec 5 DInt "s1") (Vec VI DInt "wet_0")) 		
\end_layout

\begin_layout Plain Layout

	)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example:
\begin_inset listings
lstparams "language=Fortran"
inline false
status open

\begin_layout Plain Layout

integer, parameter, dimension(5) :: s1 = [-502,-1,0,1,502]
\end_layout

\begin_layout Plain Layout

integer, dimension(5) :: svec_eta_1_0
\end_layout

\begin_layout Plain Layout

do s_idx = 1,5
\end_layout

\begin_layout Plain Layout

    svec_eta_1_0(s_idx) = wet_0(idx+s1(s_idx))
\end_layout

\begin_layout Plain Layout

end do
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And a more complicated example with a combined stencil.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

stencilDefs = [("s1" , [-502,-1,0,1,502] ), 
\begin_inset Quotes eld
\end_inset

s5
\begin_inset Quotes erd
\end_inset

 = [0,1,502], ...]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stencilAppl = (
\end_layout

\begin_layout Plain Layout

	Vec VS DInt "svec_du_1_4",
\end_layout

\begin_layout Plain Layout

		Stencil (SComb (SVec 3 DInt "s5") (SVec 5 DInt "s1")) (Vec VI DInt "wet_0")
\end_layout

\begin_layout Plain Layout

	) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We add the two stencils offsets directly rather than constructing a new
 stencil definition.
 The actual value vector (svec_du_1_4 in the example) is a 2-D vector.
\begin_inset listings
lstparams "language=Fortran"
inline false
status open

\begin_layout Plain Layout

integer, dimension(3,5) :: svec_du_1_4
\end_layout

\begin_layout Plain Layout

do s_idx_1 = 1,3
\end_layout

\begin_layout Plain Layout

do s_idx_2 = 1,5
\end_layout

\begin_layout Plain Layout

    svec_du_1_4(s_idx_1, s_idx_2) = wet_0(idx+s5(s_idx1)+s1(s_idx2))
\end_layout

\begin_layout Plain Layout

end do
\end_layout

\begin_layout Plain Layout

end do
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
MapS
\begin_inset CommandInset label
LatexCommand label
name "maps"

\end_inset


\end_layout

\begin_layout Standard
The stencil computations are handled via MapS, which computes the values
 for its function for every point in the stencil.
 An interesting point is the type of 
\family typewriter
sv_shapiro_map_16_in
\family default
, which is a stencil vector of a tuple of stencil vectors.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

shapiro_Sig = [
\end_layout

\begin_layout Plain Layout

	Scalar VDC DFloat "eps_0",
\end_layout

\begin_layout Plain Layout

	Tuple [SVec 5 DInt "wet_s_0",SVec 5 DFloat "etan_s_0"],
\end_layout

\begin_layout Plain Layout

	Scalar VDC DFloat "eta_1")
\end_layout

\begin_layout Plain Layout

  ]
\end_layout

\begin_layout Plain Layout

f_maps_du_1_1_Sig = [
\end_layout

\begin_layout Plain Layout

	Scalar VDC DFloat "eps_0",
\end_layout

\begin_layout Plain Layout

	SVec 3 (DTuple [DSVec 5 DInt,DSVec 5 DFloat]) "sv_shapiro_map_16_in",
\end_layout

\begin_layout Plain Layout

	SVec 3 DFloat "sv_shapiro_map_16_out")
\end_layout

\begin_layout Plain Layout

  ]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mapS = (Function "f_maps_du_1_1" f_maps_du_1_1_Sig, 
\end_layout

\begin_layout Plain Layout

	MapS (SVec 3 DInt "s4") (Function "shapiro_map_16" shapiro_Sig))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code generation for 
\family typewriter
sv_shapiro_map_16_in
\family default
 results in two 2-D stencils.
 The Fortran array slice feature makes it easy to partially apply stencils.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Fortran"
inline false
status open

\begin_layout Plain Layout

subroutine f_maps_du_1_1(eps_0, sv_shapiro_map_16_in0, sv_shapiro_map_16_in1,
 sv_shapiro_map_16_out)
\end_layout

\begin_layout Plain Layout

    real :: eps_0
\end_layout

\begin_layout Plain Layout

    integer, dimension(3,5) :: sv_shapiro_map_16_in0
\end_layout

\begin_layout Plain Layout

    real, dimension(3,5) :: sv_shapiro_map_16_in1
\end_layout

\begin_layout Plain Layout

    real, dimension(3) :: sv_shapiro_map_16_out
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    do i=1,3
\end_layout

\begin_layout Plain Layout

        call shapiro_map_16(eps_0, sv_shapiro_map_16_in0(i,:), sv_shapiro_map_16
_in1(i,:), sv_shapiro_map_16_out(i))
\end_layout

\begin_layout Plain Layout

    end do
\end_layout

\begin_layout Plain Layout

end subroutine f_maps_du_1_1
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
ApplyT
\begin_inset CommandInset label
LatexCommand label
name "applyt"

\end_inset


\end_layout

\begin_layout Standard
ApplyT applies a tuple of functions to a tuple of values.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

f_applyt_du_1_2_Sig = [
\end_layout

\begin_layout Plain Layout

	Scalar VDC DFloat "eps_0",
\end_layout

\begin_layout Plain Layout

	Tuple [
\end_layout

\begin_layout Plain Layout

		SVec 3 (DTuple [DSVec 5 DInt,DSVec 5 DFloat]) "sv_shapiro_map_16_in",
\end_layout

\begin_layout Plain Layout

		Scalar VDC DFloat "id_in_2",
\end_layout

\begin_layout Plain Layout

		Scalar VDC (DSVec 3 DInt) "id_in_3",
\end_layout

\begin_layout Plain Layout

		Scalar VDC DFloat "id_in_4",
\end_layout

\begin_layout Plain Layout

		Scalar VDC (DSVec 5 DFloat) "id_in_5"
\end_layout

\begin_layout Plain Layout

	],
\end_layout

\begin_layout Plain Layout

	Tuple [
\end_layout

\begin_layout Plain Layout

		SVec 3 DFloat "sv_shapiro_map_16_out",
\end_layout

\begin_layout Plain Layout

		Scalar VDC DFloat "id_out_2",
\end_layout

\begin_layout Plain Layout

		Scalar VDC (DSVec 3 DInt) "id_out_3",
\end_layout

\begin_layout Plain Layout

		Scalar VDC DFloat "id_out_4",
\end_layout

\begin_layout Plain Layout

		Scalar VDC (DSVec 5 DFloat) "id_out_5"
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

  ] 
\end_layout

\begin_layout Plain Layout

f_maps_du_1_1_Sig = [
\end_layout

\begin_layout Plain Layout

	Scalar VDC DFloat "eps_0",
\end_layout

\begin_layout Plain Layout

	SVec 3 (DTuple [DSVec 5 DInt,DSVec 5 DFloat]) "sv_shapiro_map_16_in",
\end_layout

\begin_layout Plain Layout

	SVec 3 DFloat "sv_shapiro_map_16_out")
\end_layout

\begin_layout Plain Layout

  ]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

applyT = (Function "f_applyt_du_1_2" f_applyt_du_1_2_Sig,
\end_layout

\begin_layout Plain Layout

	ApplyT [
\end_layout

\begin_layout Plain Layout

		Function "f_maps_du_1_1" f_maps_du_1_1_Sig,
\end_layout

\begin_layout Plain Layout

		Id DFloat,Id (DSVec 3 DInt),Id DFloat,Id (DSVec 5 DFloat)
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ApplyT applies a tuple of functions to a tuple of values.
 The identity function becomes a simple assigment.
\begin_inset listings
lstparams "language=Fortran"
inline false
status open

\begin_layout Plain Layout

subroutine f_applyt_du_1_2( &
\end_layout

\begin_layout Plain Layout

	eps_0, sv_shapiro_map_16_in0, sv_shapiro_map_16_in1, &
\end_layout

\begin_layout Plain Layout

	id_in_2, id_in_3, id_in_4, id_in_5, sv_shapiro_map_16_out, &
\end_layout

\begin_layout Plain Layout

	id_out_2, id_out_3, id_out_4, id_out_5)
\end_layout

\begin_layout Plain Layout

    real :: eps_0
\end_layout

\begin_layout Plain Layout

    integer, dimension(3, 5) :: sv_shapiro_map_16_in0
\end_layout

\begin_layout Plain Layout

    real, dimension(3, 5) :: sv_shapiro_map_16_in1
\end_layout

\begin_layout Plain Layout

    real :: id_in_2
\end_layout

\begin_layout Plain Layout

    integer, dimension(3) :: id_in_3
\end_layout

\begin_layout Plain Layout

    real :: id_in_4
\end_layout

\begin_layout Plain Layout

    real, dimension(5) :: id_in_5
\end_layout

\begin_layout Plain Layout

    real, dimension(3) :: sv_shapiro_map_16_out
\end_layout

\begin_layout Plain Layout

    real :: id_out_2
\end_layout

\begin_layout Plain Layout

    integer, dimension(3) :: id_out_3
\end_layout

\begin_layout Plain Layout

    real :: id_out_4
\end_layout

\begin_layout Plain Layout

    real, dimension(5) :: id_out_5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    call f_maps_du_1_1(eps_0, sv_shapiro_map_16_in0, sv_shapiro_map_16_in1,
 sv_shapiro_map_16_out)
\end_layout

\begin_layout Plain Layout

    id_out_2 = id_in_2
\end_layout

\begin_layout Plain Layout

    id_out_3 = id_in_3
\end_layout

\begin_layout Plain Layout

    id_out_4 = id_in_4
\end_layout

\begin_layout Plain Layout

    id_out_5 = id_in_5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end subroutine f_applyt_du_1_2
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Comp
\begin_inset CommandInset label
LatexCommand label
name "comp"

\end_inset


\end_layout

\begin_layout Standard
Function composition 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

f_comp_dv_1_3_Sig = [
\end_layout

\begin_layout Plain Layout

	Tuple [
\end_layout

\begin_layout Plain Layout

		Tuple [
\end_layout

\begin_layout Plain Layout

			Scalar VDC DFloat "dt_0",Scalar VDC DFloat "g_0",Scalar VDC DFloat "dx_0",Sca
lar VDC DFloat "dy_0"
\end_layout

\begin_layout Plain Layout

		],
\end_layout

\begin_layout Plain Layout

		Scalar VDC DFloat "eps_0"],
\end_layout

\begin_layout Plain Layout

	Tuple [
\end_layout

\begin_layout Plain Layout

		SVec 3 (DTuple [DSVec 5 DInt,DSVec 5 DFloat]) "sv_shapiro_map_16_in",
\end_layout

\begin_layout Plain Layout

		Scalar VDC DFloat "id_in_2", Scalar VDC (DSVec 3 DInt) "id_in_3",
\end_layout

\begin_layout Plain Layout

		Scalar VDC DFloat "id_in_4", Scalar VDC (DSVec 5 DFloat) "id_in_5"
\end_layout

\begin_layout Plain Layout

	],
\end_layout

\begin_layout Plain Layout

	Scalar VDC DFloat "dv_1"
\end_layout

\begin_layout Plain Layout

  ]
\end_layout

\begin_layout Plain Layout

f_pelt_dv_1_Sig =[
\end_layout

\begin_layout Plain Layout

	Tuple [
\end_layout

\begin_layout Plain Layout

		Scalar VDC DFloat "dt_0",Scalar VDC DFloat "g_0",Scalar VDC DFloat "dx_0",Scal
ar VDC DFloat "dy_0"
\end_layout

\begin_layout Plain Layout

	],
\end_layout

\begin_layout Plain Layout

	Tuple [
\end_layout

\begin_layout Plain Layout

		SVec 3 DFloat "eta_s_0",Scalar VDC DFloat "u_0",SVec 3 DInt "wet_s_1",
\end_layout

\begin_layout Plain Layout

		Scalar VDC DFloat "v_0",SVec 5 DFloat "h_s_0"
\end_layout

\begin_layout Plain Layout

	],Scalar VDC DFloat "dv_1"
\end_layout

\begin_layout Plain Layout

  ]	
\end_layout

\begin_layout Plain Layout

f_applyt_dv_1_2_Sig = [
\end_layout

\begin_layout Plain Layout

	Scalar VDC DFloat "eps_0",
\end_layout

\begin_layout Plain Layout

	Tuple [
\end_layout

\begin_layout Plain Layout

		SVec 3 (DTuple [DSVec 5 DInt,DSVec 5 DFloat]) "sv_shapiro_map_16_in",
\end_layout

\begin_layout Plain Layout

		Scalar VDC DFloat "id_in_2",Scalar VDC (DSVec 3 DInt) "id_in_3",
\end_layout

\begin_layout Plain Layout

		Scalar VDC DFloat "id_in_4",Scalar VDC (DSVec 5 DFloat) "id_in_5"
\end_layout

\begin_layout Plain Layout

	],
\end_layout

\begin_layout Plain Layout

	Tuple [
\end_layout

\begin_layout Plain Layout

		SVec 3 DFloat "sv_shapiro_map_16_out",Scalar VDC DFloat "id_out_2",
\end_layout

\begin_layout Plain Layout

		Scalar VDC (DSVec 3 DInt) "id_out_3",Scalar VDC DFloat "id_out_4",
\end_layout

\begin_layout Plain Layout

		Scalar VDC (DSVec 5 DFloat) "id_out_5"
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

  ]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

comp = (Function "f_comp_dv_1_3" f_comp_dv_1_3_Sig,
\end_layout

\begin_layout Plain Layout

	Comp (Function "f_pelt_dv_1" f_pelt_dv_1_Sig) (Function "f_applyt_dv_1_2"
 f_applyt_dv_1_2_Sig)
\end_layout

\begin_layout Plain Layout

	)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset listings
lstparams "language=Fortran"
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

subroutine f_comp_dv_1_3(dt_0, g_0, dx_0, dy_0, eps_0, &
\end_layout

\begin_layout Plain Layout

	sv_shapiro_map_16_in0, sv_shapiro_map_16_in1, &
\end_layout

\begin_layout Plain Layout

	id_in_2, id_in_3, id_in_4, id_in_5, dv_1)
\end_layout

\begin_layout Plain Layout

    real :: dt_0
\end_layout

\begin_layout Plain Layout

    real :: g_0
\end_layout

\begin_layout Plain Layout

    real :: dx_0
\end_layout

\begin_layout Plain Layout

    real :: dy_0
\end_layout

\begin_layout Plain Layout

    real :: eps_0
\end_layout

\begin_layout Plain Layout

    integer, dimension(3, 5) :: sv_shapiro_map_16_in0
\end_layout

\begin_layout Plain Layout

    real, dimension(3, 5) :: sv_shapiro_map_16_in1
\end_layout

\begin_layout Plain Layout

    real :: id_in_2
\end_layout

\begin_layout Plain Layout

    integer, dimension(3) :: id_in_3
\end_layout

\begin_layout Plain Layout

    real :: id_in_4
\end_layout

\begin_layout Plain Layout

    real, dimension(5) :: id_in_5
\end_layout

\begin_layout Plain Layout

    real :: dv_1
\end_layout

\begin_layout Plain Layout

    real, dimension(3) :: eta_s_0
\end_layout

\begin_layout Plain Layout

    real :: u_0
\end_layout

\begin_layout Plain Layout

    integer, dimension(3) :: wet_s_1
\end_layout

\begin_layout Plain Layout

    real :: v_0
\end_layout

\begin_layout Plain Layout

    real, dimension(5) :: h_s_0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    call f_applyt_dv_1_2(eps_0, sv_shapiro_map_16_in0, sv_shapiro_map_16_in1,
 &
\end_layout

\begin_layout Plain Layout

		id_in_2, id_in_3, id_in_4, id_in_5, eta_s_0, u_0, wet_s_1, v_0, h_s_0)
\end_layout

\begin_layout Plain Layout

    call f_pelt_dv_1(dt_0, g_0, dx_0, dy_0, eta_s_0, u_0, wet_s_1, v_0,
 h_s_0, dv_1)
\end_layout

\begin_layout Plain Layout

end subroutine f_comp_dv_1_3
\end_layout

\end_inset

Example: 
\family typewriter
(Function
\begin_inset space \space{}
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

exp_h_1_3
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

,Comp
\begin_inset space \space{}
\end_inset

(Function
\begin_inset space \space{}
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

exp_h_1_0
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

)
\begin_inset space \space{}
\end_inset

(Function
\begin_inset space \space{}
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

exp_h_1_2
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

))
\family default
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

shapiro_Sig = [
\end_layout

\begin_layout Plain Layout

	Scalar VDC DFloat "eps_0",
\end_layout

\begin_layout Plain Layout

	Tuple [SVec 5 DInt "wet_s_0",
\end_layout

\begin_layout Plain Layout

	SVec 5 DFloat "etan_s_0"],Scalar VDC DFloat "eta_1")
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

f_maps_du_1_1_Sig = [
\end_layout

\begin_layout Plain Layout

	Scalar VDC DFloat "eps_0",
\end_layout

\begin_layout Plain Layout

	SVec 3 (DTuple [DSVec 5 DInt,DSVec 5 DFloat]) "sv_shapiro_map_16_in",
\end_layout

\begin_layout Plain Layout

	SVec 3 DFloat "sv_shapiro_map_16_out")
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mapS = (Function "f_maps_du_1_1" f_maps_du_1_1_Sig, 
\end_layout

\begin_layout Plain Layout

	MapS (SVec 3 DInt "s4") (Function "shapiro_map_16" shapiro_Sig))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Fortran"
inline false
status open

\begin_layout Plain Layout

! comp
\end_layout

\begin_layout Plain Layout

subroutine exp_h_1_3(t_i,t_o)        
\end_layout

\begin_layout Plain Layout

    real, intent(in) :: t_i
\end_layout

\begin_layout Plain Layout

    real, intent(out) :: t_o
\end_layout

\begin_layout Plain Layout

    real :: t_int        
\end_layout

\begin_layout Plain Layout

    call exp_h_1_0(t_i, t_int)
\end_layout

\begin_layout Plain Layout

    call exp_h_1_2(t_int,t_o)
\end_layout

\begin_layout Plain Layout

end subroutine exp_h_1_3
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Map
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

f_comp_u_1_3_Sig = [
\end_layout

\begin_layout Plain Layout

	Tuple [
\end_layout

\begin_layout Plain Layout

		Scalar VDC DFloat "hmin_0",Scalar VDC DFloat "eps_0"
\end_layout

\begin_layout Plain Layout

	],
\end_layout

\begin_layout Plain Layout

	Tuple [
\end_layout

\begin_layout Plain Layout

		Scalar VDC DFloat "id_in_1",
\end_layout

\begin_layout Plain Layout

		SVec 3 (DTuple [DSVec 5 DInt,DSVec 5 DFloat]) "sv_shapiro_map_16_in",
\end_layout

\begin_layout Plain Layout

		Scalar VDC (DSVec 2 DFloat) "id_in_3",Scalar VDC (DSVec 2 DFloat) "id_in_4"
\end_layout

\begin_layout Plain Layout

	],
\end_layout

\begin_layout Plain Layout

	Scalar VDC DFloat "u_1"
\end_layout

\begin_layout Plain Layout

  ]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

(
\end_layout

\begin_layout Plain Layout

Vec VO DFloat "u_1",
\end_layout

\begin_layout Plain Layout

Map (Function "f_comp_u_1_3" f_comp_u_1_3_Sig) 
\end_layout

\begin_layout Plain Layout

	(ZipT [
\end_layout

\begin_layout Plain Layout

		Vec VI DFloat "hzero_0",
\end_layout

\begin_layout Plain Layout

		ZipT [
\end_layout

\begin_layout Plain Layout

			Vec VS DInt "svec_u_1_4",
\end_layout

\begin_layout Plain Layout

			Vec VS DFloat "svec_u_1_5"
\end_layout

\begin_layout Plain Layout

		],
\end_layout

\begin_layout Plain Layout

		Vec VS DFloat "svec_u_1_6",
\end_layout

\begin_layout Plain Layout

		Vec VS DFloat "svec_u_1_7"
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

	)
\end_layout

\begin_layout Plain Layout

) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Fortran"
inline false
status open

\begin_layout Plain Layout

 call f_comp_u_1_3( &
\end_layout

\begin_layout Plain Layout

	hmin_0, eps_0, &
\end_layout

\begin_layout Plain Layout

	hzero_0(idx), svec_u_1_4, svec_u_1_5, &
\end_layout

\begin_layout Plain Layout

	svec_u_1_6, svec_u_1_7, &
\end_layout

\begin_layout Plain Layout

	u_1(idx))  
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Fold
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "mathescape=true,escapeinside={~~},language=Haskell"
inline false
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Fortran"
inline false
status open

\begin_layout Plain Layout

!
\end_layout

\end_inset


\end_layout

\begin_layout Acknowledgements
If you'd like to thank anyone, place your comments here.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "IEEEabrv,paper-memory-reduction-TyTraCL"
options "bibtotoc,spbasic"

\end_inset


\end_layout

\end_body
\end_document
