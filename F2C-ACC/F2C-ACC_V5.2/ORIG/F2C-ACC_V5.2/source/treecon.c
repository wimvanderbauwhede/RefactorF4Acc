
/* implementation of tree construction functions */

#include "node.h"

#include "nodecode.h"

#include "attrpredef.h"

#include "visitmap.h"

#include "treeact.h"

#ifdef MONITOR
#include "attr_mon_dapto.h"
#include "MONTblStack.h"
#endif

#include <stdlib.h>

#define _USE_OBSTACK 1

/* use of obstack: */

#if _USE_OBSTACK

#include "obstack.h"
static struct obstack TreeSpace;
static void *_TreeBase;

#ifdef __cplusplus
void* NODEPTR_struct::operator new(size_t size)
{
	return obstack_alloc(&TreeSpace, size);
}
#else
#if defined(__STDC__) || defined(__cplusplus)
char* TreeNodeAlloc(int size)
#else
char* TreeNodeAlloc(size) int size;
#endif
{
	return (char *)(obstack_alloc(&TreeSpace, size));
}
#endif

void InitTree()
{
	obstack_init(&TreeSpace);
	_TreeBase=obstack_alloc(&TreeSpace,0);
}

void FreeTree()
{
	obstack_free(&TreeSpace, _TreeBase);
	_TreeBase=obstack_alloc(&TreeSpace,0);
}

#else

#include <stdio.h>

#ifdef __cplusplus
void* NODEPTR_struct::operator new(size_t size)
{
	void *retval = malloc(size);
	if (retval) return retval;
	fprintf(stderr, "*** DEADLY: No more memory.\n");
	exit(1);
}
#else
#if defined(__STDC__) || defined(__cplusplus)
char* TreeNodeAlloc(int size)
#else
char* TreeNodeAlloc(size) int size;
#endif
{
	char *retval = (char *) malloc(size);
	if (retval) return retval;
	fprintf(stderr, "*** DEADLY: No more memory.\n");
	exit(1);
}
#endif

void InitTree() { }

void FreeTree() { }

#endif

#ifdef MONITOR
#define _SETCOORD(node) \
        node->_coord = _coordref ? *_coordref : NoCoord;
#define _COPYCOORD(node) \
        node->_coord = _currn->_desc1->_coord;
#else
#define _SETCOORD(node)
#define _COPYCOORD(node)
#endif
#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxParam (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxParam (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxParam)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_1072(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxParam */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSMSDirectives (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSMSDirectives (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSMSDirectives)) return (_currn);
if (IsSymb (_currn, SYMBGlobalReference)) return (Mkrule_1080(_coordref, _currn));
if (IsSymb (_currn, SYMBGlobalReferenceEnd)) return (Mkrule_1081(_coordref, _currn));
if (IsSymb (_currn, SYMBLocalReference)) return (Mkrule_1082(_coordref, _currn));
if (IsSymb (_currn, SYMBLocalReferenceEnd)) return (Mkrule_1083(_coordref, _currn));
if (IsSymb (_currn, SYMBxDirectiveName)) return (Mkrule_1084(_coordref, _currn));
if (IsSymb (_currn, SYMBxExchDirective)) return (Mkrule_1085(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxSMSDirectives */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxGPUDirectives (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxGPUDirectives (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxGPUDirectives)) return (_currn);
if (IsSymb (_currn, SYMBAccData)) return (Mkrule_1061(_coordref, _currn));
if (IsSymb (_currn, SYMBAccDo)) return (Mkrule_1062(_coordref, _currn));
if (IsSymb (_currn, SYMBAccSync)) return (Mkrule_1063(_coordref, _currn));
if (IsSymb (_currn, SYMBAccThread)) return (Mkrule_1064(_coordref, _currn));
if (IsSymb (_currn, SYMBKernelBegin)) return (Mkrule_1065(_coordref, _currn));
if (IsSymb (_currn, SYMBKernelEnd)) return (Mkrule_1066(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxGPUDirectives */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxExchangeVariable (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxExchangeVariable (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxExchangeVariable)) return (_currn);
return(NULLNODEPTR);
}/* MkxExchangeVariable */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxExchangeOptions (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxExchangeOptions (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxExchangeOptions)) return (_currn);
return(NULLNODEPTR);
}/* MkxExchangeOptions */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxExchangeVariables (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxExchangeVariables (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxExchangeVariables)) return (_currn);
if (IsSymb (_currn, SYMBxExchangeVariable)) return (Mkrule_1055(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxExchangeVariables */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxExchDirective (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxExchDirective (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxExchDirective)) return (_currn);
return(NULLNODEPTR);
}/* MkxExchDirective */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxParVariable (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxParVariable (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxParVariable)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_1068(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxParVariable */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxParVariables (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxParVariables (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxParVariables)) return (_currn);
if (IsSymb (_currn, SYMBxParVariable)) return (Mkrule_1070(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_1070(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxParVariables */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDirectiveParam (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDirectiveParam (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDirectiveParam)) return (_currn);
if (IsSymb (_currn, SYMBxParVariable)) return (Mkrule_1038(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_1038(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDirectiveParam */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDirectiveName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDirectiveName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDirectiveName)) return (_currn);
return(NULLNODEPTR);
}/* MkxDirectiveName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDirectiveEnd (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDirectiveEnd (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDirectiveEnd)) return (_currn);
return(NULLNODEPTR);
}/* MkxDirectiveEnd */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDirectiveParams (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDirectiveParams (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDirectiveParams)) return (_currn);
return(NULLNODEPTR);
}/* MkxDirectiveParams */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDirectiveBegin (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDirectiveBegin (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDirectiveBegin)) return (_currn);
return(NULLNODEPTR);
}/* MkxDirectiveBegin */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDecomp_Size (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDecomp_Size (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDecomp_Size)) return (_currn);
if (IsSymb (_currn, SYMBxDecomp_Expr)) return (Mkrule_1029(_coordref, _currn));
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_1029(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_1029(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_1029(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_1029(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_1029(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_1029(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_1029(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDecomp_Size */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDecompHalos (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDecompHalos (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDecompHalos)) return (_currn);
return(NULLNODEPTR);
}/* MkxDecompHalos */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDecompLowBounds (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDecompLowBounds (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDecompLowBounds)) return (_currn);
return(NULLNODEPTR);
}/* MkxDecompLowBounds */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDecomp_ActualSizes (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDecomp_ActualSizes (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDecomp_ActualSizes)) return (_currn);
if (IsSymb (_currn, SYMBDecompRank)) return (Mkrule_1023(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDecomp_ActualSizes */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDeclarePackedDecomp (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDeclarePackedDecomp (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDeclarePackedDecomp)) return (_currn);
return(NULLNODEPTR);
}/* MkxDeclarePackedDecomp */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDecompActuals (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDecompActuals (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDecompActuals)) return (_currn);
if (IsSymb (_currn, SYMBxDecompLowBounds)) return (Mkrule_1010(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDecompActuals */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDeclareDecomp (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDeclareDecomp (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDeclareDecomp)) return (_currn);
return(NULLNODEPTR);
}/* MkxDeclareDecomp */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDecomp_GlobalSizes (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDecomp_GlobalSizes (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDecomp_GlobalSizes)) return (_currn);
return(NULLNODEPTR);
}/* MkxDecomp_GlobalSizes */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDecompSizes (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDecompSizes (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDecompSizes)) return (_currn);
if (IsSymb (_currn, SYMBxDecomp_GlobalSizes)) return (Mkrule_1019(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDecompSizes */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSMS_ParRegion (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSMS_ParRegion (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSMS_ParRegion)) return (_currn);
return(NULLNODEPTR);
}/* MkxSMS_ParRegion */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxCreatePackedDecomp (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxCreatePackedDecomp (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxCreatePackedDecomp)) return (_currn);
return(NULLNODEPTR);
}/* MkxCreatePackedDecomp */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxCreateDecomp (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxCreateDecomp (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxCreateDecomp)) return (_currn);
return(NULLNODEPTR);
}/* MkxCreateDecomp */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxArrayAllocationList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxArrayAllocationList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxArrayAllocationList)) return (_currn);
if (IsSymb (_currn, SYMBxArrayName)) return (Mkrule_995(_coordref, _currn));
if (IsSymb (_currn, SYMBxArrayAllocation)) return (Mkrule_995(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxArrayAllocationList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDim (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDim (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDim)) return (_currn);
return(NULLNODEPTR);
}/* MkxDim */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkVariableCouplet (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkVariableCouplet (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBVariableCouplet)) return (_currn);
if (IsSymb (_currn, SYMBToLocalOption)) return (Mkrule_980(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_980(_coordref, _currn));
return(NULLNODEPTR);
}/* MkVariableCouplet */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkToLocalOptions (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkToLocalOptions (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBToLocalOptions)) return (_currn);
return(NULLNODEPTR);
}/* MkToLocalOptions */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkToLocalOption (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkToLocalOption (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBToLocalOption)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_976(_coordref, _currn));
return(NULLNODEPTR);
}/* MkToLocalOption */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkSpectralOption (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkSpectralOption (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBSpectralOption)) return (_currn);
if (IsSymb (_currn, SYMBScrambleStrategy)) return (Mkrule_969(_coordref, _currn));
return(NULLNODEPTR);
}/* MkSpectralOption */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkScrambleStrategy (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkScrambleStrategy (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBScrambleStrategy)) return (_currn);
return(NULLNODEPTR);
}/* MkScrambleStrategy */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkRefVariables (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkRefVariables (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBRefVariables)) return (_currn);
if (IsSymb (_currn, SYMBRefVariable)) return (Mkrule_965(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_965(_coordref, _currn));
return(NULLNODEPTR);
}/* MkRefVariables */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkRefVariable (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkRefVariable (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBRefVariable)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_963(_coordref, _currn));
return(NULLNODEPTR);
}/* MkRefVariable */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkPeriodicUpper (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkPeriodicUpper (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBPeriodicUpper)) return (_currn);
if (IsSymb (_currn, SYMBxDecomp_Expr)) return (Mkrule_961(_coordref, _currn));
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_961(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_961(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_961(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_961(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_961(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_961(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_961(_coordref, _currn));
return(NULLNODEPTR);
}/* MkPeriodicUpper */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDecomp_Expr (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDecomp_Expr (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDecomp_Expr)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_1024(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_1024(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_1024(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_1024(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_1024(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_1024(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_1024(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDecomp_Expr */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkPeriodicLower (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkPeriodicLower (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBPeriodicLower)) return (_currn);
if (IsSymb (_currn, SYMBxDecomp_Expr)) return (Mkrule_960(_coordref, _currn));
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_960(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_960(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_960(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_960(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_960(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_960(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_960(_coordref, _currn));
return(NULLNODEPTR);
}/* MkPeriodicLower */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkParentDecomp_Handle (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkParentDecomp_Handle (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBParentDecomp_Handle)) return (_currn);
if (IsSymb (_currn, SYMBxDecomp_Handle)) return (Mkrule_959(_coordref, _currn));
return(NULLNODEPTR);
}/* MkParentDecomp_Handle */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkPackedRowSizes (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkPackedRowSizes (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBPackedRowSizes)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_958(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_958(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_958(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_958(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_958(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_958(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_958(_coordref, _currn));
return(NULLNODEPTR);
}/* MkPackedRowSizes */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkSpecialPackedPropertyType (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkSpecialPackedPropertyType (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBSpecialPackedPropertyType)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_968(_coordref, _currn));
return(NULLNODEPTR);
}/* MkSpecialPackedPropertyType */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkSpecialPackedPropertyRow (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkSpecialPackedPropertyRow (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBSpecialPackedPropertyRow)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_967(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_967(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_967(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_967(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_967(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_967(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_967(_coordref, _currn));
return(NULLNODEPTR);
}/* MkSpecialPackedPropertyRow */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkPackedOption (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkPackedOption (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBPackedOption)) return (_currn);
return(NULLNODEPTR);
}/* MkPackedOption */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkNumPackedRows (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkNumPackedRows (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBNumPackedRows)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_950(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_950(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_950(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_950(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_950(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_950(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_950(_coordref, _currn));
return(NULLNODEPTR);
}/* MkNumPackedRows */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxRelHandle (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxRelHandle (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxRelHandle)) return (_currn);
return(NULLNODEPTR);
}/* MkxRelHandle */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkNumHandles (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkNumHandles (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBNumHandles)) return (_currn);
return(NULLNODEPTR);
}/* MkNumHandles */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkLocalReferenceEnd (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkLocalReferenceEnd (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBLocalReferenceEnd)) return (_currn);
return(NULLNODEPTR);
}/* MkLocalReferenceEnd */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkLocalReference (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkLocalReference (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBLocalReference)) return (_currn);
return(NULLNODEPTR);
}/* MkLocalReference */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkHaloVariable (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkHaloVariable (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBHaloVariable)) return (_currn);
if (IsSymb (_currn, SYMBxParam)) return (Mkrule_942(_coordref, _currn));
if (IsSymb (_currn, SYMBxParams)) return (Mkrule_942(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_942(_coordref, _currn));
return(NULLNODEPTR);
}/* MkHaloVariable */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkHaloThicks (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkHaloThicks (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBHaloThicks)) return (_currn);
return(NULLNODEPTR);
}/* MkHaloThicks */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxExchThick (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxExchThick (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxExchThick)) return (_currn);
return(NULLNODEPTR);
}/* MkxExchThick */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkHaloThick (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkHaloThick (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBHaloThick)) return (_currn);
return(NULLNODEPTR);
}/* MkHaloThick */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkHaloOptions (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkHaloOptions (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBHaloOptions)) return (_currn);
return(NULLNODEPTR);
}/* MkHaloOptions */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkHaloDirectiveName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkHaloDirectiveName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBHaloDirectiveName)) return (_currn);
return(NULLNODEPTR);
}/* MkHaloDirectiveName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkHaloVariables (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkHaloVariables (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBHaloVariables)) return (_currn);
return(NULLNODEPTR);
}/* MkHaloVariables */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkHaloCouplets (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkHaloCouplets (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBHaloCouplets)) return (_currn);
if (IsSymb (_currn, SYMBHaloVariables)) return (Mkrule_931(_coordref, _currn));
return(NULLNODEPTR);
}/* MkHaloCouplets */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkHaloAllDims (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkHaloAllDims (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBHaloAllDims)) return (_currn);
return(NULLNODEPTR);
}/* MkHaloAllDims */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkGlobalReferenceEnd (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkGlobalReferenceEnd (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBGlobalReferenceEnd)) return (_currn);
return(NULLNODEPTR);
}/* MkGlobalReferenceEnd */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkVariableCouplets (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkVariableCouplets (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBVariableCouplets)) return (_currn);
return(NULLNODEPTR);
}/* MkVariableCouplets */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkoDecomp (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkoDecomp (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBoDecomp)) return (_currn);
return(NULLNODEPTR);
}/* MkoDecomp */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkGlobalReference (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkGlobalReference (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBGlobalReference)) return (_currn);
return(NULLNODEPTR);
}/* MkGlobalReference */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkDecompRank (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkDecompRank (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBDecompRank)) return (_currn);
return(NULLNODEPTR);
}/* MkDecompRank */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkUnstructuredOption (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkUnstructuredOption (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBUnstructuredOption)) return (_currn);
return(NULLNODEPTR);
}/* MkUnstructuredOption */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkDecompOption (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkDecompOption (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBDecompOption)) return (_currn);
if (IsSymb (_currn, SYMBAlignedOption)) return (Mkrule_921(_coordref, _currn));
if (IsSymb (_currn, SYMBUnstructuredOption)) return (Mkrule_922(_coordref, _currn));
return(NULLNODEPTR);
}/* MkDecompOption */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkDecompLowBounds (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkDecompLowBounds (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBDecompLowBounds)) return (_currn);
return(NULLNODEPTR);
}/* MkDecompLowBounds */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxParams (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxParams (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxParams)) return (_currn);
if (IsSymb (_currn, SYMBxParam)) return (Mkrule_1075(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_1075(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxParams */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkDecompLowBound (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkDecompLowBound (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBDecompLowBound)) return (_currn);
if (IsSymb (_currn, SYMBxParam)) return (Mkrule_917(_coordref, _currn));
if (IsSymb (_currn, SYMBxParams)) return (Mkrule_917(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_917(_coordref, _currn));
return(NULLNODEPTR);
}/* MkDecompLowBound */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkPackedOptions (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkPackedOptions (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBPackedOptions)) return (_currn);
if (IsSymb (_currn, SYMBPackedOption)) return (Mkrule_957(_coordref, _currn));
return(NULLNODEPTR);
}/* MkPackedOptions */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkCreatePackedOptions (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkCreatePackedOptions (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBCreatePackedOptions)) return (_currn);
return(NULLNODEPTR);
}/* MkCreatePackedOptions */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkSpectralOptions (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkSpectralOptions (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBSpectralOptions)) return (_currn);
if (IsSymb (_currn, SYMBScrambleStrategy)) return (Mkrule_972(_coordref, _currn));
if (IsSymb (_currn, SYMBSpectralOption)) return (Mkrule_972(_coordref, _currn));
return(NULLNODEPTR);
}/* MkSpectralOptions */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkCreateOptions (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkCreateOptions (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBCreateOptions)) return (_currn);
return(NULLNODEPTR);
}/* MkCreateOptions */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkCornerDepth (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkCornerDepth (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBCornerDepth)) return (_currn);
return(NULLNODEPTR);
}/* MkCornerDepth */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkBoundaryTypes (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkBoundaryTypes (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBBoundaryTypes)) return (_currn);
if (IsSymb (_currn, SYMBBoundaryType)) return (Mkrule_909(_coordref, _currn));
return(NULLNODEPTR);
}/* MkBoundaryTypes */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxPeriodicOptions (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxPeriodicOptions (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxPeriodicOptions)) return (_currn);
return(NULLNODEPTR);
}/* MkxPeriodicOptions */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkBoundaryType (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkBoundaryType (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBBoundaryType)) return (_currn);
return(NULLNODEPTR);
}/* MkBoundaryType */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkAlignedOption (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkAlignedOption (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBAlignedOption)) return (_currn);
return(NULLNODEPTR);
}/* MkAlignedOption */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDecomp_Handle (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDecomp_Handle (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDecomp_Handle)) return (_currn);
return(NULLNODEPTR);
}/* MkxDecomp_Handle */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkAlignedDecomp (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkAlignedDecomp (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBAlignedDecomp)) return (_currn);
if (IsSymb (_currn, SYMBxDecomp_Handle)) return (Mkrule_902(_coordref, _currn));
return(NULLNODEPTR);
}/* MkAlignedDecomp */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkAccDoType (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkAccDoType (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBAccDoType)) return (_currn);
return(NULLNODEPTR);
}/* MkAccDoType */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkAccSync (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkAccSync (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBAccSync)) return (_currn);
return(NULLNODEPTR);
}/* MkAccSync */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkOptDim (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkOptDim (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBOptDim)) return (_currn);
return(NULLNODEPTR);
}/* MkOptDim */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkAccThread (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkAccThread (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBAccThread)) return (_currn);
return(NULLNODEPTR);
}/* MkAccThread */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkAccThreadBegin (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkAccThreadBegin (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBAccThreadBegin)) return (_currn);
return(NULLNODEPTR);
}/* MkAccThreadBegin */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkThreadStart (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkThreadStart (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBThreadStart)) return (_currn);
return(NULLNODEPTR);
}/* MkThreadStart */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkThreadRange (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkThreadRange (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBThreadRange)) return (_currn);
return(NULLNODEPTR);
}/* MkThreadRange */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkAccDoFunction (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkAccDoFunction (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBAccDoFunction)) return (_currn);
return(NULLNODEPTR);
}/* MkAccDoFunction */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkBinOp (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkBinOp (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBBinOp)) return (_currn);
return(NULLNODEPTR);
}/* MkBinOp */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkDim (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkDim (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBDim)) return (_currn);
return(NULLNODEPTR);
}/* MkDim */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkDoFunctionWidth (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkDoFunctionWidth (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBDoFunctionWidth)) return (_currn);
return(NULLNODEPTR);
}/* MkDoFunctionWidth */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkLogical (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkLogical (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBLogical)) return (_currn);
return(NULLNODEPTR);
}/* MkLogical */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkBlock (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkBlock (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBBlock)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_51(_coordref, _currn));
if (IsSymb (_currn, SYMBParam)) return (Mkrule_51(_coordref, _currn));
if (IsSymb (_currn, SYMBParams)) return (Mkrule_51(_coordref, _currn));
return(NULLNODEPTR);
}/* MkBlock */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkThread (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkThread (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBThread)) return (_currn);
return(NULLNODEPTR);
}/* MkThread */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkBlocks (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkBlocks (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBBlocks)) return (_currn);
if (IsSymb (_currn, SYMBBlock)) return (Mkrule_53(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_53(_coordref, _currn));
if (IsSymb (_currn, SYMBParam)) return (Mkrule_53(_coordref, _currn));
if (IsSymb (_currn, SYMBParams)) return (Mkrule_53(_coordref, _currn));
return(NULLNODEPTR);
}/* MkBlocks */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkNumBlocks (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkNumBlocks (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBNumBlocks)) return (_currn);
return(NULLNODEPTR);
}/* MkNumBlocks */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkThreads (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkThreads (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBThreads)) return (_currn);
if (IsSymb (_currn, SYMBThread)) return (Mkrule_56(_coordref, _currn));
return(NULLNODEPTR);
}/* MkThreads */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkThreadOption (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkThreadOption (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBThreadOption)) return (_currn);
return(NULLNODEPTR);
}/* MkThreadOption */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkSharedDim (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkSharedDim (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBSharedDim)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_59(_coordref, _currn));
return(NULLNODEPTR);
}/* MkSharedDim */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkSharedDims (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkSharedDims (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBSharedDims)) return (_currn);
if (IsSymb (_currn, SYMBSharedDim)) return (Mkrule_62(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_62(_coordref, _currn));
return(NULLNODEPTR);
}/* MkSharedDims */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkResidentName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkResidentName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBResidentName)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_64(_coordref, _currn));
return(NULLNODEPTR);
}/* MkResidentName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkDemoteDim (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkDemoteDim (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBDemoteDim)) return (_currn);
return(NULLNODEPTR);
}/* MkDemoteDim */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkDemoteDims (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkDemoteDims (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBDemoteDims)) return (_currn);
if (IsSymb (_currn, SYMBDemoteDim)) return (Mkrule_70(_coordref, _currn));
return(NULLNODEPTR);
}/* MkDemoteDims */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkParams (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkParams (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBParams)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_21(_coordref, _currn));
if (IsSymb (_currn, SYMBParam)) return (Mkrule_21(_coordref, _currn));
return(NULLNODEPTR);
}/* MkParams */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkPromoteLB (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkPromoteLB (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBPromoteLB)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_73(_coordref, _currn));
if (IsSymb (_currn, SYMBParam)) return (Mkrule_73(_coordref, _currn));
if (IsSymb (_currn, SYMBParams)) return (Mkrule_73(_coordref, _currn));
return(NULLNODEPTR);
}/* MkPromoteLB */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkPromoteVar (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkPromoteVar (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBPromoteVar)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_74(_coordref, _currn));
if (IsSymb (_currn, SYMBParam)) return (Mkrule_74(_coordref, _currn));
if (IsSymb (_currn, SYMBParams)) return (Mkrule_74(_coordref, _currn));
return(NULLNODEPTR);
}/* MkPromoteVar */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkPromoteDim (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkPromoteDim (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBPromoteDim)) return (_currn);
return(NULLNODEPTR);
}/* MkPromoteDim */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkPromoteExpr (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkPromoteExpr (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBPromoteExpr)) return (_currn);
return(NULLNODEPTR);
}/* MkPromoteExpr */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkPromoteType (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkPromoteType (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBPromoteType)) return (_currn);
return(NULLNODEPTR);
}/* MkPromoteType */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkPromoteDims (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkPromoteDims (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBPromoteDims)) return (_currn);
if (IsSymb (_currn, SYMBPromoteDim)) return (Mkrule_79(_coordref, _currn));
return(NULLNODEPTR);
}/* MkPromoteDims */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkGPUVariables (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkGPUVariables (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBGPUVariables)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_44(_coordref, _currn));
if (IsSymb (_currn, SYMBGPUVariable)) return (Mkrule_44(_coordref, _currn));
return(NULLNODEPTR);
}/* MkGPUVariables */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkParamOpt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkParamOpt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBParamOpt)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_50(_coordref, _currn));
if (IsSymb (_currn, SYMBLogical)) return (Mkrule_35(_coordref, _currn));
if (IsSymb (_currn, SYMBParam)) return (Mkrule_50(_coordref, _currn));
return(NULLNODEPTR);
}/* MkParamOpt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkCondOp (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkCondOp (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBCondOp)) return (_currn);
return(NULLNODEPTR);
}/* MkCondOp */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkParam (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkParam (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBParam)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_49(_coordref, _currn));
return(NULLNODEPTR);
}/* MkParam */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkOptionalCondition (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkOptionalCondition (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBOptionalCondition)) return (_currn);
return(NULLNODEPTR);
}/* MkOptionalCondition */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkSharedDecl (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkSharedDecl (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBSharedDecl)) return (_currn);
return(NULLNODEPTR);
}/* MkSharedDecl */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkDataOption (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkDataOption (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBDataOption)) return (_currn);
return(NULLNODEPTR);
}/* MkDataOption */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkDataUsageScope (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkDataUsageScope (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBDataUsageScope)) return (_currn);
return(NULLNODEPTR);
}/* MkDataUsageScope */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkDataUsageType (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkDataUsageType (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBDataUsageType)) return (_currn);
return(NULLNODEPTR);
}/* MkDataUsageType */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkDataUsage (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkDataUsage (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBDataUsage)) return (_currn);
return(NULLNODEPTR);
}/* MkDataUsage */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkOptionalArgs (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkOptionalArgs (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBOptionalArgs)) return (_currn);
return(NULLNODEPTR);
}/* MkOptionalArgs */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkTranslationType (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkTranslationType (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBTranslationType)) return (_currn);
return(NULLNODEPTR);
}/* MkTranslationType */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkDataUsages (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkDataUsages (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBDataUsages)) return (_currn);
if (IsSymb (_currn, SYMBDataUsage)) return (Mkrule_46(_coordref, _currn));
return(NULLNODEPTR);
}/* MkDataUsages */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkAccDoTypes (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkAccDoTypes (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBAccDoTypes)) return (_currn);
if (IsSymb (_currn, SYMBAccDoType)) return (Mkrule_900(_coordref, _currn));
return(NULLNODEPTR);
}/* MkAccDoTypes */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkAccDo (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkAccDo (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBAccDo)) return (_currn);
return(NULLNODEPTR);
}/* MkAccDo */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxWhereBodyConstruct (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxWhereBodyConstruct (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxWhereBodyConstruct)) return (_currn);
if (IsSymb (_currn, SYMBxAttrStmt)) return (Mkrule_114(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallStmt)) return (Mkrule_114(_coordref, _currn));
if (IsSymb (_currn, SYMBxStmt)) return (Mkrule_114(_coordref, _currn));
if (IsSymb (_currn, SYMBxWhereConstruct)) return (Mkrule_113(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxWhereBodyConstruct */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxTargetObjectList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxTargetObjectList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxTargetObjectList)) return (_currn);
if (IsSymb (_currn, SYMBxTargetName)) return (Mkrule_127(_coordref, _currn));
if (IsSymb (_currn, SYMBxTargetObject)) return (Mkrule_127(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxTargetObjectList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxTargetObject (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxTargetObject (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxTargetObject)) return (_currn);
if (IsSymb (_currn, SYMBxTargetName)) return (Mkrule_128(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxTargetObject */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxTargetName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxTargetName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxTargetName)) return (_currn);
return(NULLNODEPTR);
}/* MkxTargetName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSavedEntity (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSavedEntity (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSavedEntity)) return (_currn);
if (IsSymb (_currn, SYMBxComblock)) return (Mkrule_149(_coordref, _currn));
if (IsSymb (_currn, SYMBxVariableName)) return (Mkrule_148(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxSavedEntity */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxRename (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxRename (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxRename)) return (_currn);
return(NULLNODEPTR);
}/* MkxRename */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxRdUnitId (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxRdUnitId (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxRdUnitId)) return (_currn);
return(NULLNODEPTR);
}/* MkxRdUnitId */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxProcedureName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxProcedureName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxProcedureName)) return (_currn);
return(NULLNODEPTR);
}/* MkxProcedureName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxPointerStmtObject (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxPointerStmtObject (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxPointerStmtObject)) return (_currn);
if (IsSymb (_currn, SYMBxPointerName)) return (Mkrule_169(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxPointerStmtObject */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxPointerName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxPointerName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxPointerName)) return (_currn);
return(NULLNODEPTR);
}/* MkxPointerName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxOutputImpliedDo (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxOutputImpliedDo (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxOutputImpliedDo)) return (_currn);
return(NULLNODEPTR);
}/* MkxOutputImpliedDo */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxOptionalParList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxOptionalParList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxOptionalParList)) return (_currn);
if (IsSymb (_currn, SYMBxDummyArgName)) return (Mkrule_188(_coordref, _currn));
if (IsSymb (_currn, SYMBxOptionalPar)) return (Mkrule_188(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxOptionalParList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxOptionalPar (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxOptionalPar (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxOptionalPar)) return (_currn);
if (IsSymb (_currn, SYMBxDummyArgName)) return (Mkrule_189(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxOptionalPar */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxNamelistGroups (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxNamelistGroups (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxNamelistGroups)) return (_currn);
return(NULLNODEPTR);
}/* MkxNamelistGroups */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxNamelistGroupObject (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxNamelistGroupObject (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxNamelistGroupObject)) return (_currn);
if (IsSymb (_currn, SYMBxVariableName)) return (Mkrule_196(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxNamelistGroupObject */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxModuleSubprogram (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxModuleSubprogram (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxModuleSubprogram)) return (_currn);
if (IsSymb (_currn, SYMBxModule)) return (Mkrule_199(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndProgramStmt)) return (Mkrule_199(_coordref, _currn));
if (IsSymb (_currn, SYMBxMainRange)) return (Mkrule_199(_coordref, _currn));
if (IsSymb (_currn, SYMBxProgramUnit)) return (Mkrule_199(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxModuleSubprogram */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxProcedureNameList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxProcedureNameList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxProcedureNameList)) return (_currn);
if (IsSymb (_currn, SYMBxProcedureName)) return (Mkrule_161(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxProcedureNameList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxModuleBody (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxModuleBody (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxModuleBody)) return (_currn);
if (IsSymb (_currn, SYMBxCreateDecomp)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxCreatePackedDecomp)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxSMS_ParRegion)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBAccData)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBAccDo)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBAccSync)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBAccThread)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBKernelBegin)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBKernelEnd)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxGPUDirectives)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBGlobalReference)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBGlobalReferenceEnd)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBLocalReference)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBLocalReferenceEnd)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxDirectiveName)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxExchDirective)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxSMSDirectives)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxDeclareDecomp)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxDeclarePackedDecomp)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxModule)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxAttrStmt)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxDerivedTypeDef)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceBlock)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxCaseConstruct)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxDoConstruct)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxIfConstruct)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallConstruct)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallStmt)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallBodyConstruct)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceBody)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceSpecification)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndProgramStmt)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxMainRange)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxProgramUnit)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxModuleSubprogram)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxBodyConstruct)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxObsoleteExecutionPartConstruct)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxStmt)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxWhereConstruct)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxWhereBodyConstruct)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndWhereStmt)) return (Mkrule_201(_coordref, _currn));
if (IsSymb (_currn, SYMBxBody)) return (Mkrule_201(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxModuleBody */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxModuleBlock (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxModuleBlock (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxModuleBlock)) return (_currn);
if (IsSymb (_currn, SYMBxEndModuleStmt)) return (Mkrule_204(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxModuleBlock */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxNamelistGroupName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxNamelistGroupName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxNamelistGroupName)) return (_currn);
return(NULLNODEPTR);
}/* MkxNamelistGroupName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxInterfaceSpecification (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxInterfaceSpecification (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxInterfaceSpecification)) return (_currn);
if (IsSymb (_currn, SYMBxAttrStmt)) return (Mkrule_231(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallStmt)) return (Mkrule_231(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceBody)) return (Mkrule_232(_coordref, _currn));
if (IsSymb (_currn, SYMBxStmt)) return (Mkrule_231(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxInterfaceSpecification */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxInterfaceRange (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxInterfaceRange (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxInterfaceRange)) return (_currn);
return(NULLNODEPTR);
}/* MkxInterfaceRange */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxInterfaceStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxInterfaceStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxInterfaceStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxInterfaceStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxIntentParList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxIntentParList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxIntentParList)) return (_currn);
if (IsSymb (_currn, SYMBxIntentPar)) return (Mkrule_242(_coordref, _currn));
if (IsSymb (_currn, SYMBxDummyArgName)) return (Mkrule_242(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxIntentParList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxIntentPar (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxIntentPar (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxIntentPar)) return (_currn);
if (IsSymb (_currn, SYMBxDummyArgName)) return (Mkrule_243(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxIntentPar */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxInputItem (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxInputItem (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxInputItem)) return (_currn);
if (IsSymb (_currn, SYMBxDataRef)) return (Mkrule_266(_coordref, _currn));
if (IsSymb (_currn, SYMBxInputImpliedDo)) return (Mkrule_267(_coordref, _currn));
if (IsSymb (_currn, SYMBxVariable)) return (Mkrule_266(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_266(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxInputItem */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxInputImpliedDo (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxInputImpliedDo (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxInputImpliedDo)) return (_currn);
return(NULLNODEPTR);
}/* MkxInputImpliedDo */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSubscript (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSubscript (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSubscript)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_137(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_137(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_137(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_137(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_137(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_137(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_137(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxSubscript */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxScalarMaskExpr (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxScalarMaskExpr (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxScalarMaskExpr)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_145(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_145(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_145(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_145(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_145(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_145(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_145(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxScalarMaskExpr */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxForallTripletSpecList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxForallTripletSpecList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxForallTripletSpecList)) return (_currn);
return(NULLNODEPTR);
}/* MkxForallTripletSpecList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxForallBodyConstruct (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxForallBodyConstruct (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxForallBodyConstruct)) return (_currn);
if (IsSymb (_currn, SYMBxAttrStmt)) return (Mkrule_296(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallConstruct)) return (Mkrule_295(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallStmt)) return (Mkrule_294(_coordref, _currn));
if (IsSymb (_currn, SYMBxStmt)) return (Mkrule_296(_coordref, _currn));
if (IsSymb (_currn, SYMBxWhereConstruct)) return (Mkrule_293(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxForallBodyConstruct */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxObsoleteExecutionPartConstruct (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxObsoleteExecutionPartConstruct (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxObsoleteExecutionPartConstruct)) return (_currn);
if (IsSymb (_currn, SYMBxAttrStmt)) return (Mkrule_190(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallStmt)) return (Mkrule_190(_coordref, _currn));
if (IsSymb (_currn, SYMBxStmt)) return (Mkrule_190(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxObsoleteExecutionPartConstruct */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxWhereConstruct (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxWhereConstruct (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxWhereConstruct)) return (_currn);
return(NULLNODEPTR);
}/* MkxWhereConstruct */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxIfConstruct (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxIfConstruct (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxIfConstruct)) return (_currn);
return(NULLNODEPTR);
}/* MkxIfConstruct */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxForallConstruct (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxForallConstruct (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxForallConstruct)) return (_currn);
return(NULLNODEPTR);
}/* MkxForallConstruct */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEquivalenceSet (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEquivalenceSet (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEquivalenceSet)) return (_currn);
return(NULLNODEPTR);
}/* MkxEquivalenceSet */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEquivalenceObjectList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEquivalenceObjectList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEquivalenceObjectList)) return (_currn);
if (IsSymb (_currn, SYMBxDataRef)) return (Mkrule_320(_coordref, _currn));
if (IsSymb (_currn, SYMBxEquivalenceObject)) return (Mkrule_320(_coordref, _currn));
if (IsSymb (_currn, SYMBxVariable)) return (Mkrule_320(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_320(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxEquivalenceObjectList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEquivalenceObject (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEquivalenceObject (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEquivalenceObject)) return (_currn);
if (IsSymb (_currn, SYMBxDataRef)) return (Mkrule_321(_coordref, _currn));
if (IsSymb (_currn, SYMBxVariable)) return (Mkrule_321(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_321(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxEquivalenceObject */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEndInterfaceStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEndInterfaceStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEndInterfaceStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxEndInterfaceStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxElsewherePart (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxElsewherePart (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxElsewherePart)) return (_currn);
if (IsSymb (_currn, SYMBxEndWhereStmt)) return (Mkrule_345(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxElsewherePart */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxThenPart (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxThenPart (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxThenPart)) return (_currn);
if (IsSymb (_currn, SYMBxElseConstruct)) return (Mkrule_120(_coordref, _currn));
if (IsSymb (_currn, SYMBxElseIfConstruct)) return (Mkrule_119(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndIfStmt)) return (Mkrule_118(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxThenPart */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxElseIfConstruct (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxElseIfConstruct (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxElseIfConstruct)) return (_currn);
return(NULLNODEPTR);
}/* MkxElseIfConstruct */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxElsePart (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxElsePart (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxElsePart)) return (_currn);
if (IsSymb (_currn, SYMBxEndIfStmt)) return (Mkrule_347(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxElsePart */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxElseConstruct (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxElseConstruct (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxElseConstruct)) return (_currn);
return(NULLNODEPTR);
}/* MkxElseConstruct */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDoConstruct (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDoConstruct (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDoConstruct)) return (_currn);
if (IsSymb (_currn, SYMBxCreateDecomp)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxCreatePackedDecomp)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxSMS_ParRegion)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBAccData)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBAccDo)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBAccSync)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBAccThread)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBKernelBegin)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBKernelEnd)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxGPUDirectives)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBGlobalReference)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBGlobalReferenceEnd)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBLocalReference)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBLocalReferenceEnd)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxDirectiveName)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxExchDirective)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxSMSDirectives)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxDeclareDecomp)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxDeclarePackedDecomp)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxModule)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxAttrStmt)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxDerivedTypeDef)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceBlock)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxCaseConstruct)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxDoConstruct)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxIfConstruct)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallConstruct)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallStmt)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallBodyConstruct)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceBody)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceSpecification)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndProgramStmt)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxMainRange)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxProgramUnit)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxModuleSubprogram)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxBodyConstruct)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxObsoleteExecutionPartConstruct)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxStmt)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxWhereConstruct)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxWhereBodyConstruct)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndWhereStmt)) return (Mkrule_355(_coordref, _currn));
if (IsSymb (_currn, SYMBxBody)) return (Mkrule_355(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDoConstruct */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxPrivateSequenceStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxPrivateSequenceStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxPrivateSequenceStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxPrivateSequenceStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDerivedTypeBodyConstruct (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDerivedTypeBodyConstruct (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDerivedTypeBodyConstruct)) return (_currn);
if (IsSymb (_currn, SYMBxDeclareDecomp)) return (Mkrule_1030(_coordref, _currn));
if (IsSymb (_currn, SYMBxComponentDefStmt)) return (Mkrule_359(_coordref, _currn));
if (IsSymb (_currn, SYMBxPrivateSequenceStmt)) return (Mkrule_358(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDerivedTypeBodyConstruct */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDefinedUnaryOp (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDefinedUnaryOp (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDefinedUnaryOp)) return (_currn);
return(NULLNODEPTR);
}/* MkxDefinedUnaryOp */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDefinedOperator (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDefinedOperator (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDefinedOperator)) return (_currn);
if (IsSymb (_currn, SYMBxBinOp)) return (Mkrule_365(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnOp)) return (Mkrule_363(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDefinedOperator */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDefinedBinaryOp (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDefinedBinaryOp (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDefinedBinaryOp)) return (_currn);
return(NULLNODEPTR);
}/* MkxDefinedBinaryOp */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxInterfaceBlock (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxInterfaceBlock (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxInterfaceBlock)) return (_currn);
return(NULLNODEPTR);
}/* MkxInterfaceBlock */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDataIDoObjectList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDataIDoObjectList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDataIDoObjectList)) return (_currn);
if (IsSymb (_currn, SYMBxDataImpliedDo)) return (Mkrule_373(_coordref, _currn));
if (IsSymb (_currn, SYMBxStructureComponent)) return (Mkrule_373(_coordref, _currn));
if (IsSymb (_currn, SYMBxDataRef)) return (Mkrule_373(_coordref, _currn));
if (IsSymb (_currn, SYMBxDataStmtObject)) return (Mkrule_373(_coordref, _currn));
if (IsSymb (_currn, SYMBxVariable)) return (Mkrule_373(_coordref, _currn));
if (IsSymb (_currn, SYMBxArrayElement)) return (Mkrule_373(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_373(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDataIDoObjectList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxComponentInitialization (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxComponentInitialization (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxComponentInitialization)) return (_currn);
return(NULLNODEPTR);
}/* MkxComponentInitialization */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxComponentAttrSpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxComponentAttrSpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxComponentAttrSpec)) return (_currn);
return(NULLNODEPTR);
}/* MkxComponentAttrSpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxCommonBlockObject (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxCommonBlockObject (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxCommonBlockObject)) return (_currn);
if (IsSymb (_currn, SYMBxArrayDeclarator)) return (Mkrule_397(_coordref, _currn));
if (IsSymb (_currn, SYMBxVariableName)) return (Mkrule_396(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxCommonBlockObject */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxCaseValueRange (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxCaseValueRange (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxCaseValueRange)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_416(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_416(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_416(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_416(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_416(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_416(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_416(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxCaseValueRange */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxCaseValueRangeList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxCaseValueRangeList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxCaseValueRangeList)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_415(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_415(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_415(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_415(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_415(_coordref, _currn));
if (IsSymb (_currn, SYMBxCaseValueRange)) return (Mkrule_415(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_415(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_415(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxCaseValueRangeList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSelectCaseRange (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSelectCaseRange (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSelectCaseRange)) return (_currn);
if (IsSymb (_currn, SYMBxEndSelectStmt)) return (Mkrule_141(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxSelectCaseRange */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxCaseConstruct (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxCaseConstruct (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxCaseConstruct)) return (_currn);
return(NULLNODEPTR);
}/* MkxCaseConstruct */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxCaseBodyConstruct (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxCaseBodyConstruct (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxCaseBodyConstruct)) return (_currn);
if (IsSymb (_currn, SYMBxCreateDecomp)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxCreatePackedDecomp)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxSMS_ParRegion)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBAccData)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBAccDo)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBAccSync)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBAccThread)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBKernelBegin)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBKernelEnd)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxGPUDirectives)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBGlobalReference)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBGlobalReferenceEnd)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBLocalReference)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBLocalReferenceEnd)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxDirectiveName)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxExchDirective)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxSMSDirectives)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxDeclareDecomp)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxDeclarePackedDecomp)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxModule)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxAttrStmt)) return (Mkrule_424(_coordref, _currn));
if (IsSymb (_currn, SYMBxDerivedTypeDef)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceBlock)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxCaseConstruct)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxDoConstruct)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxIfConstruct)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallConstruct)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallStmt)) return (Mkrule_424(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallBodyConstruct)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceBody)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceSpecification)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndProgramStmt)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxMainRange)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxProgramUnit)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxModuleSubprogram)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxBodyConstruct)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxObsoleteExecutionPartConstruct)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxStmt)) return (Mkrule_424(_coordref, _currn));
if (IsSymb (_currn, SYMBxWhereConstruct)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxWhereBodyConstruct)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndWhereStmt)) return (Mkrule_423(_coordref, _currn));
if (IsSymb (_currn, SYMBxBody)) return (Mkrule_423(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxCaseBodyConstruct */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDerivedVar (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDerivedVar (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDerivedVar)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_356(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDerivedVar */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxInternalSubprogram (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxInternalSubprogram (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxInternalSubprogram)) return (_currn);
if (IsSymb (_currn, SYMBxModule)) return (Mkrule_227(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndProgramStmt)) return (Mkrule_227(_coordref, _currn));
if (IsSymb (_currn, SYMBxMainRange)) return (Mkrule_227(_coordref, _currn));
if (IsSymb (_currn, SYMBxProgramUnit)) return (Mkrule_227(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxInternalSubprogram */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxBodyConstruct (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxBodyConstruct (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxBodyConstruct)) return (_currn);
if (IsSymb (_currn, SYMBxCreateDecomp)) return (Mkrule_1002(_coordref, _currn));
if (IsSymb (_currn, SYMBxCreatePackedDecomp)) return (Mkrule_1003(_coordref, _currn));
if (IsSymb (_currn, SYMBxSMS_ParRegion)) return (Mkrule_1004(_coordref, _currn));
if (IsSymb (_currn, SYMBAccData)) return (Mkrule_1057(_coordref, _currn));
if (IsSymb (_currn, SYMBAccDo)) return (Mkrule_1057(_coordref, _currn));
if (IsSymb (_currn, SYMBAccSync)) return (Mkrule_1057(_coordref, _currn));
if (IsSymb (_currn, SYMBAccThread)) return (Mkrule_1057(_coordref, _currn));
if (IsSymb (_currn, SYMBKernelBegin)) return (Mkrule_1057(_coordref, _currn));
if (IsSymb (_currn, SYMBKernelEnd)) return (Mkrule_1057(_coordref, _currn));
if (IsSymb (_currn, SYMBxGPUDirectives)) return (Mkrule_1057(_coordref, _currn));
if (IsSymb (_currn, SYMBGlobalReference)) return (Mkrule_1058(_coordref, _currn));
if (IsSymb (_currn, SYMBGlobalReferenceEnd)) return (Mkrule_1058(_coordref, _currn));
if (IsSymb (_currn, SYMBLocalReference)) return (Mkrule_1058(_coordref, _currn));
if (IsSymb (_currn, SYMBLocalReferenceEnd)) return (Mkrule_1058(_coordref, _currn));
if (IsSymb (_currn, SYMBxDirectiveName)) return (Mkrule_1058(_coordref, _currn));
if (IsSymb (_currn, SYMBxExchDirective)) return (Mkrule_1058(_coordref, _currn));
if (IsSymb (_currn, SYMBxSMSDirectives)) return (Mkrule_1058(_coordref, _currn));
if (IsSymb (_currn, SYMBxDeclareDecomp)) return (Mkrule_1087(_coordref, _currn));
if (IsSymb (_currn, SYMBxDeclarePackedDecomp)) return (Mkrule_1088(_coordref, _currn));
if (IsSymb (_currn, SYMBxModule)) return (Mkrule_198(_coordref, _currn));
if (IsSymb (_currn, SYMBxAttrStmt)) return (Mkrule_367(_coordref, _currn));
if (IsSymb (_currn, SYMBxDerivedTypeDef)) return (Mkrule_369(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceBlock)) return (Mkrule_368(_coordref, _currn));
if (IsSymb (_currn, SYMBxCaseConstruct)) return (Mkrule_315(_coordref, _currn));
if (IsSymb (_currn, SYMBxDoConstruct)) return (Mkrule_314(_coordref, _currn));
if (IsSymb (_currn, SYMBxIfConstruct)) return (Mkrule_312(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallConstruct)) return (Mkrule_313(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallStmt)) return (Mkrule_367(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallBodyConstruct)) return (Mkrule_314(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceBody)) return (Mkrule_314(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceSpecification)) return (Mkrule_314(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndProgramStmt)) return (Mkrule_198(_coordref, _currn));
if (IsSymb (_currn, SYMBxMainRange)) return (Mkrule_198(_coordref, _currn));
if (IsSymb (_currn, SYMBxProgramUnit)) return (Mkrule_198(_coordref, _currn));
if (IsSymb (_currn, SYMBxModuleSubprogram)) return (Mkrule_198(_coordref, _currn));
if (IsSymb (_currn, SYMBxBodyConstruct)) return (Mkrule_314(_coordref, _currn));
if (IsSymb (_currn, SYMBxObsoleteExecutionPartConstruct)) return (Mkrule_308(_coordref, _currn));
if (IsSymb (_currn, SYMBxStmt)) return (Mkrule_367(_coordref, _currn));
if (IsSymb (_currn, SYMBxWhereConstruct)) return (Mkrule_311(_coordref, _currn));
if (IsSymb (_currn, SYMBxWhereBodyConstruct)) return (Mkrule_314(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndWhereStmt)) return (Mkrule_314(_coordref, _currn));
if (IsSymb (_currn, SYMBxBody)) return (Mkrule_314(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxBodyConstruct */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxAccessIdList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxAccessIdList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxAccessIdList)) return (_currn);
if (IsSymb (_currn, SYMBxGenericName)) return (Mkrule_446(_coordref, _currn));
if (IsSymb (_currn, SYMBxGenericSpec)) return (Mkrule_446(_coordref, _currn));
if (IsSymb (_currn, SYMBxAccessId)) return (Mkrule_446(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxAccessIdList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxGenericName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxGenericName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxGenericName)) return (_currn);
return(NULLNODEPTR);
}/* MkxGenericName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxAccessId (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxAccessId (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxAccessId)) return (_currn);
if (IsSymb (_currn, SYMBxGenericName)) return (Mkrule_448(_coordref, _currn));
if (IsSymb (_currn, SYMBxGenericSpec)) return (Mkrule_447(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxAccessId */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxIntentSpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxIntentSpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxIntentSpec)) return (_currn);
return(NULLNODEPTR);
}/* MkxIntentSpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEndModuleStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEndModuleStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEndModuleStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxEndModuleStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxHeader (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxHeader (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxHeader)) return (_currn);
return(NULLNODEPTR);
}/* MkxHeader */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxPrefixSpecList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxPrefixSpecList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxPrefixSpecList)) return (_currn);
if (IsSymb (_currn, SYMBxTypeSpec)) return (Mkrule_532(_coordref, _currn));
if (IsSymb (_currn, SYMBxPrefixSpec)) return (Mkrule_532(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxPrefixSpecList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSubroutinePrefix (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSubroutinePrefix (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSubroutinePrefix)) return (_currn);
return(NULLNODEPTR);
}/* MkxSubroutinePrefix */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxComplexConst (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxComplexConst (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxComplexConst)) return (_currn);
return(NULLNODEPTR);
}/* MkxComplexConst */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxArg (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxArg (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxArg)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_547(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_547(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_547(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_547(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_547(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_547(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_547(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxArg */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkAccData (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkAccData (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBAccData)) return (_currn);
return(NULLNODEPTR);
}/* MkAccData */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkKernelEnd (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkKernelEnd (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBKernelEnd)) return (_currn);
return(NULLNODEPTR);
}/* MkKernelEnd */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkDataSection (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkDataSection (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBDataSection)) return (_currn);
return(NULLNODEPTR);
}/* MkDataSection */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkBlockSpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkBlockSpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBBlockSpec)) return (_currn);
return(NULLNODEPTR);
}/* MkBlockSpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkThreadSpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkThreadSpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBThreadSpec)) return (_currn);
return(NULLNODEPTR);
}/* MkThreadSpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkKernelBegin (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkKernelBegin (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBKernelBegin)) return (_currn);
return(NULLNODEPTR);
}/* MkKernelBegin */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxRenameList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxRenameList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxRenameList)) return (_currn);
if (IsSymb (_currn, SYMBxRename)) return (Mkrule_152(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxRenameList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkGPUVariable (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkGPUVariable (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBGPUVariable)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_66(_coordref, _currn));
return(NULLNODEPTR);
}/* MkGPUVariable */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxFormalParameter (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxFormalParameter (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxFormalParameter)) return (_currn);
if (IsSymb (_currn, SYMBxDummyArgName)) return (Mkrule_561(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxFormalParameter */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDataStmtConstant (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDataStmtConstant (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDataStmtConstant)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_565(_coordref, _currn));
if (IsSymb (_currn, SYMBxBozLiteralConstant)) return (Mkrule_565(_coordref, _currn));
if (IsSymb (_currn, SYMBxStructureConstructor)) return (Mkrule_565(_coordref, _currn));
if (IsSymb (_currn, SYMBxConstant)) return (Mkrule_565(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_565(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_565(_coordref, _currn));
if (IsSymb (_currn, SYMBxNamedConstantUse)) return (Mkrule_565(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDataStmtConstant */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDataStmtValue (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDataStmtValue (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDataStmtValue)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_570(_coordref, _currn));
if (IsSymb (_currn, SYMBxBozLiteralConstant)) return (Mkrule_570(_coordref, _currn));
if (IsSymb (_currn, SYMBxStructureConstructor)) return (Mkrule_570(_coordref, _currn));
if (IsSymb (_currn, SYMBxConstant)) return (Mkrule_570(_coordref, _currn));
if (IsSymb (_currn, SYMBxDataStmtConstant)) return (Mkrule_570(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_570(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_570(_coordref, _currn));
if (IsSymb (_currn, SYMBxNamedConstantUse)) return (Mkrule_570(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDataStmtValue */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxArrayElement (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxArrayElement (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxArrayElement)) return (_currn);
return(NULLNODEPTR);
}/* MkxArrayElement */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDataStmtObject (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDataStmtObject (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDataStmtObject)) return (_currn);
if (IsSymb (_currn, SYMBxDataImpliedDo)) return (Mkrule_574(_coordref, _currn));
if (IsSymb (_currn, SYMBxStructureComponent)) return (Mkrule_573(_coordref, _currn));
if (IsSymb (_currn, SYMBxDataRef)) return (Mkrule_576(_coordref, _currn));
if (IsSymb (_currn, SYMBxVariable)) return (Mkrule_576(_coordref, _currn));
if (IsSymb (_currn, SYMBxArrayElement)) return (Mkrule_575(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_576(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDataStmtObject */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDataStmtValueList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDataStmtValueList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDataStmtValueList)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_572(_coordref, _currn));
if (IsSymb (_currn, SYMBxBozLiteralConstant)) return (Mkrule_572(_coordref, _currn));
if (IsSymb (_currn, SYMBxStructureConstructor)) return (Mkrule_572(_coordref, _currn));
if (IsSymb (_currn, SYMBxDataStmtValue)) return (Mkrule_572(_coordref, _currn));
if (IsSymb (_currn, SYMBxConstant)) return (Mkrule_572(_coordref, _currn));
if (IsSymb (_currn, SYMBxDataStmtConstant)) return (Mkrule_572(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_572(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_572(_coordref, _currn));
if (IsSymb (_currn, SYMBxNamedConstantUse)) return (Mkrule_572(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDataStmtValueList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDataStmtObjectList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDataStmtObjectList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDataStmtObjectList)) return (_currn);
if (IsSymb (_currn, SYMBxDataImpliedDo)) return (Mkrule_578(_coordref, _currn));
if (IsSymb (_currn, SYMBxStructureComponent)) return (Mkrule_578(_coordref, _currn));
if (IsSymb (_currn, SYMBxDataRef)) return (Mkrule_578(_coordref, _currn));
if (IsSymb (_currn, SYMBxDataStmtObject)) return (Mkrule_578(_coordref, _currn));
if (IsSymb (_currn, SYMBxVariable)) return (Mkrule_578(_coordref, _currn));
if (IsSymb (_currn, SYMBxArrayElement)) return (Mkrule_578(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_578(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDataStmtObjectList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDataStmtSet (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDataStmtSet (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDataStmtSet)) return (_currn);
return(NULLNODEPTR);
}/* MkxDataStmtSet */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxAccessSpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxAccessSpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxAccessSpec)) return (_currn);
return(NULLNODEPTR);
}/* MkxAccessSpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxAcValueList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxAcValueList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxAcValueList)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_595(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_595(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_595(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_595(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_595(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_595(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_595(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxAcValueList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxFormalParameterList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxFormalParameterList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxFormalParameterList)) return (_currn);
if (IsSymb (_currn, SYMBxFormalParameter)) return (Mkrule_541(_coordref, _currn));
if (IsSymb (_currn, SYMBxDummyArgName)) return (Mkrule_541(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxFormalParameterList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxFunctionPrefix (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxFunctionPrefix (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxFunctionPrefix)) return (_currn);
return(NULLNODEPTR);
}/* MkxFunctionPrefix */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxInvalidEntityDecl (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxInvalidEntityDecl (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxInvalidEntityDecl)) return (_currn);
return(NULLNODEPTR);
}/* MkxInvalidEntityDecl */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxPrefixSpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxPrefixSpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxPrefixSpec)) return (_currn);
if (IsSymb (_currn, SYMBxTypeSpec)) return (Mkrule_603(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxPrefixSpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxStructureConstructor (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxStructureConstructor (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxStructureConstructor)) return (_currn);
return(NULLNODEPTR);
}/* MkxStructureConstructor */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxBozLiteralConstant (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxBozLiteralConstant (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxBozLiteralConstant)) return (_currn);
return(NULLNODEPTR);
}/* MkxBozLiteralConstant */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxConstant (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxConstant (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxConstant)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_611(_coordref, _currn));
if (IsSymb (_currn, SYMBxBozLiteralConstant)) return (Mkrule_609(_coordref, _currn));
if (IsSymb (_currn, SYMBxStructureConstructor)) return (Mkrule_604(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_612(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_612(_coordref, _currn));
if (IsSymb (_currn, SYMBxNamedConstantUse)) return (Mkrule_605(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxConstant */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxCharLenParamValue (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxCharLenParamValue (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxCharLenParamValue)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_616(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_616(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_616(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_616(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_616(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_616(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_616(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxCharLenParamValue */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxNamedConstantDef (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxNamedConstantDef (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxNamedConstantDef)) return (_currn);
return(NULLNODEPTR);
}/* MkxNamedConstantDef */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxAttrSpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxAttrSpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxAttrSpec)) return (_currn);
if (IsSymb (_currn, SYMBxAccessSpec)) return (Mkrule_582(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxAttrSpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxAllocation (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxAllocation (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxAllocation)) return (_currn);
if (IsSymb (_currn, SYMBxAllocateObject)) return (Mkrule_991(_coordref, _currn));
if (IsSymb (_currn, SYMBxVariableName)) return (Mkrule_991(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxAllocation */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkAllocateDeclarators (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkAllocateDeclarators (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBAllocateDeclarators)) return (_currn);
if (IsSymb (_currn, SYMBxSubscriptTriplet)) return (Mkrule_638(_coordref, _currn));
if (IsSymb (_currn, SYMBxSectionSubscriptList)) return (Mkrule_638(_coordref, _currn));
if (IsSymb (_currn, SYMBxSectionSubscript)) return (Mkrule_638(_coordref, _currn));
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_638(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_638(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_638(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_638(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_638(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_638(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_638(_coordref, _currn));
return(NULLNODEPTR);
}/* MkAllocateDeclarators */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxAttrArraySpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxAttrArraySpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxAttrArraySpec)) return (_currn);
if (IsSymb (_currn, SYMBxDeferredShapeSpec)) return (Mkrule_639(_coordref, _currn));
if (IsSymb (_currn, SYMBxUpperBound)) return (Mkrule_639(_coordref, _currn));
if (IsSymb (_currn, SYMBxExplicitShapeSpec)) return (Mkrule_639(_coordref, _currn));
if (IsSymb (_currn, SYMBxArraySpec)) return (Mkrule_639(_coordref, _currn));
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_639(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_639(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_639(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_639(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_639(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_639(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_639(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxAttrArraySpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxInitialization (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxInitialization (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxInitialization)) return (_currn);
return(NULLNODEPTR);
}/* MkxInitialization */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxArrayAllocation (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxArrayAllocation (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxArrayAllocation)) return (_currn);
if (IsSymb (_currn, SYMBxArrayName)) return (Mkrule_994(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxArrayAllocation */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxAllocatedShape (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxAllocatedShape (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxAllocatedShape)) return (_currn);
return(NULLNODEPTR);
}/* MkxAllocatedShape */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxModuleName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxModuleName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxModuleName)) return (_currn);
return(NULLNODEPTR);
}/* MkxModuleName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxGenericSpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxGenericSpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxGenericSpec)) return (_currn);
return(NULLNODEPTR);
}/* MkxGenericSpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxOnly (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxOnly (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxOnly)) return (_currn);
if (IsSymb (_currn, SYMBxUseName)) return (Mkrule_653(_coordref, _currn));
if (IsSymb (_currn, SYMBxGenericSpec)) return (Mkrule_652(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxOnly */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxOnlyList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxOnlyList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxOnlyList)) return (_currn);
if (IsSymb (_currn, SYMBxUseName)) return (Mkrule_655(_coordref, _currn));
if (IsSymb (_currn, SYMBxOnly)) return (Mkrule_655(_coordref, _currn));
if (IsSymb (_currn, SYMBxGenericSpec)) return (Mkrule_655(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxOnlyList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEndBlockDataStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEndBlockDataStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEndBlockDataStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxEndBlockDataStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxBody (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxBody (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxBody)) return (_currn);
if (IsSymb (_currn, SYMBxCreateDecomp)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxCreatePackedDecomp)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxSMS_ParRegion)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBAccData)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBAccDo)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBAccSync)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBAccThread)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBKernelBegin)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBKernelEnd)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxGPUDirectives)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBGlobalReference)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBGlobalReferenceEnd)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBLocalReference)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBLocalReferenceEnd)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxDirectiveName)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxExchDirective)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxSMSDirectives)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxDeclareDecomp)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxDeclarePackedDecomp)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxModule)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxAttrStmt)) return (Mkrule_432(_coordref, _currn));
if (IsSymb (_currn, SYMBxDerivedTypeDef)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceBlock)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxCaseConstruct)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxDoConstruct)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxIfConstruct)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallConstruct)) return (Mkrule_297(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallStmt)) return (Mkrule_297(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallBodyConstruct)) return (Mkrule_297(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceBody)) return (Mkrule_236(_coordref, _currn));
if (IsSymb (_currn, SYMBxInterfaceSpecification)) return (Mkrule_236(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndProgramStmt)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxMainRange)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxProgramUnit)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxModuleSubprogram)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxBodyConstruct)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxObsoleteExecutionPartConstruct)) return (Mkrule_436(_coordref, _currn));
if (IsSymb (_currn, SYMBxStmt)) return (Mkrule_432(_coordref, _currn));
if (IsSymb (_currn, SYMBxWhereConstruct)) return (Mkrule_297(_coordref, _currn));
if (IsSymb (_currn, SYMBxWhereBodyConstruct)) return (Mkrule_112(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndWhereStmt)) return (Mkrule_109(_coordref, _currn));
if (IsSymb (_currn, SYMBxBody)) return (Mkrule_436(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxBody */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxBlockDataStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxBlockDataStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxBlockDataStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxBlockDataStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxMainRange (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxMainRange (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxMainRange)) return (_currn);
if (IsSymb (_currn, SYMBxEndProgramStmt)) return (Mkrule_207(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxMainRange */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxProgramStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxProgramStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxProgramStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxProgramStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSubroutineStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSubroutineStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSubroutineStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxSubroutineStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSFDataRef (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSFDataRef (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSFDataRef)) return (_currn);
return(NULLNODEPTR);
}/* MkxSFDataRef */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSubscriptTriplet (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSubscriptTriplet (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSubscriptTriplet)) return (_currn);
return(NULLNODEPTR);
}/* MkxSubscriptTriplet */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSectionSubscript (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSectionSubscript (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSectionSubscript)) return (_currn);
if (IsSymb (_currn, SYMBxSubscriptTriplet)) return (Mkrule_666(_coordref, _currn));
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_635(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_635(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_635(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_635(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_635(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_635(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_635(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxSectionSubscript */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkAccRoutine (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkAccRoutine (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBAccRoutine)) return (_currn);
return(NULLNODEPTR);
}/* MkAccRoutine */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxModule (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxModule (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxModule)) return (_currn);
return(NULLNODEPTR);
}/* MkxModule */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSubprogramRange (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSubprogramRange (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSubprogramRange)) return (_currn);
if (IsSymb (_currn, SYMBxEndFunctionStmt)) return (Mkrule_1059(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndSubroutineStmt)) return (Mkrule_1089(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxSubprogramRange */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxFunctionStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxFunctionStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxFunctionStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxFunctionStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxComblock (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxComblock (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxComblock)) return (_currn);
return(NULLNODEPTR);
}/* MkxComblock */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDataImpliedDo (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDataImpliedDo (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDataImpliedDo)) return (_currn);
return(NULLNODEPTR);
}/* MkxDataImpliedDo */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxExecutableProgram (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxExecutableProgram (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxExecutableProgram)) return (_currn);
if (IsSymb (_currn, SYMBxModule)) return (Mkrule_309(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndProgramStmt)) return (Mkrule_309(_coordref, _currn));
if (IsSymb (_currn, SYMBxMainRange)) return (Mkrule_309(_coordref, _currn));
if (IsSymb (_currn, SYMBxProgramUnit)) return (Mkrule_309(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxExecutableProgram */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxImplicitSpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxImplicitSpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxImplicitSpec)) return (_currn);
return(NULLNODEPTR);
}/* MkxImplicitSpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxAttrSpecSeq (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxAttrSpecSeq (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxAttrSpecSeq)) return (_currn);
return(NULLNODEPTR);
}/* MkxAttrSpecSeq */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxAttrStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxAttrStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxAttrStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxAttrStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxCharSelector (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxCharSelector (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxCharSelector)) return (_currn);
return(NULLNODEPTR);
}/* MkxCharSelector */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxKindSelector (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxKindSelector (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxKindSelector)) return (_currn);
return(NULLNODEPTR);
}/* MkxKindSelector */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxComponentDeclList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxComponentDeclList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxComponentDeclList)) return (_currn);
if (IsSymb (_currn, SYMBxComponentName)) return (Mkrule_387(_coordref, _currn));
if (IsSymb (_currn, SYMBxComponentDecl)) return (Mkrule_387(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxComponentDeclList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxComponentAttrSpecList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxComponentAttrSpecList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxComponentAttrSpecList)) return (_currn);
if (IsSymb (_currn, SYMBxComponentAttrSpec)) return (Mkrule_391(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxComponentAttrSpecList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxComponentDefStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxComponentDefStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxComponentDefStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxComponentDefStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEntityDeclList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEntityDeclList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEntityDeclList)) return (_currn);
if (IsSymb (_currn, SYMBxObjectName)) return (Mkrule_1048(_coordref, _currn));
if (IsSymb (_currn, SYMBxInvalidEntityDecl)) return (Mkrule_1048(_coordref, _currn));
if (IsSymb (_currn, SYMBxEntityDecl)) return (Mkrule_1048(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxEntityDeclList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEndWhereStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEndWhereStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEndWhereStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxEndWhereStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxPointerObjectList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxPointerObjectList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxPointerObjectList)) return (_currn);
if (IsSymb (_currn, SYMBxPointerObject)) return (Mkrule_172(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_172(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxPointerObjectList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxCaseSelector (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxCaseSelector (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxCaseSelector)) return (_currn);
return(NULLNODEPTR);
}/* MkxCaseSelector */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEndSelectStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEndSelectStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEndSelectStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxEndSelectStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxAllocateObjectList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxAllocateObjectList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxAllocateObjectList)) return (_currn);
if (IsSymb (_currn, SYMBxAllocateObject)) return (Mkrule_989(_coordref, _currn));
if (IsSymb (_currn, SYMBxVariableName)) return (Mkrule_989(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxAllocateObjectList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxVariable (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxVariable (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxVariable)) return (_currn);
if (IsSymb (_currn, SYMBxDataRef)) return (Mkrule_503(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_503(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxVariable */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxAllocationList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxAllocationList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxAllocationList)) return (_currn);
if (IsSymb (_currn, SYMBxAllocation)) return (Mkrule_992(_coordref, _currn));
if (IsSymb (_currn, SYMBxAllocateObject)) return (Mkrule_992(_coordref, _currn));
if (IsSymb (_currn, SYMBxVariableName)) return (Mkrule_992(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxAllocationList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxPointerStmtObjectList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxPointerStmtObjectList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxPointerStmtObjectList)) return (_currn);
if (IsSymb (_currn, SYMBxPointerName)) return (Mkrule_168(_coordref, _currn));
if (IsSymb (_currn, SYMBxPointerStmtObject)) return (Mkrule_168(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxPointerStmtObjectList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEndForallStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEndForallStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEndForallStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxEndForallStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxForallStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxForallStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxForallStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxForallStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxForallHeader (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxForallHeader (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxForallHeader)) return (_currn);
return(NULLNODEPTR);
}/* MkxForallHeader */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxForallConstructStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxForallConstructStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxForallConstructStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxForallConstructStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDataRef (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDataRef (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDataRef)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_502(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDataRef */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxCompDataRef (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxCompDataRef (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxCompDataRef)) return (_currn);
if (IsSymb (_currn, SYMBxDataRef)) return (Mkrule_393(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_393(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxCompDataRef */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEndSubroutineStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEndSubroutineStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEndSubroutineStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxEndSubroutineStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEndFunctionStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEndFunctionStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEndFunctionStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxEndFunctionStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEndProgramStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEndProgramStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEndProgramStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxEndProgramStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEndName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEndName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEndName)) return (_currn);
return(NULLNODEPTR);
}/* MkxEndName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEndIfStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEndIfStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEndIfStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxEndIfStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDeferredShapeSpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDeferredShapeSpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDeferredShapeSpec)) return (_currn);
return(NULLNODEPTR);
}/* MkxDeferredShapeSpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxAssumedShapeSpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxAssumedShapeSpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxAssumedShapeSpec)) return (_currn);
return(NULLNODEPTR);
}/* MkxAssumedShapeSpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxExplicitShapeSpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxExplicitShapeSpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxExplicitShapeSpec)) return (_currn);
if (IsSymb (_currn, SYMBxUpperBound)) return (Mkrule_645(_coordref, _currn));
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_645(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_645(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_645(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_645(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_645(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_645(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_645(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxExplicitShapeSpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxArraySpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxArraySpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxArraySpec)) return (_currn);
if (IsSymb (_currn, SYMBxDeferredShapeSpec)) return (Mkrule_778(_coordref, _currn));
if (IsSymb (_currn, SYMBxUpperBound)) return (Mkrule_785(_coordref, _currn));
if (IsSymb (_currn, SYMBxExplicitShapeSpec)) return (Mkrule_785(_coordref, _currn));
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_785(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_785(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_785(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_785(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_785(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_785(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_785(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxArraySpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxComponentDecl (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxComponentDecl (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxComponentDecl)) return (_currn);
if (IsSymb (_currn, SYMBxComponentName)) return (Mkrule_789(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxComponentDecl */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxCharLength (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxCharLength (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxCharLength)) return (_currn);
return(NULLNODEPTR);
}/* MkxCharLength */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEntityDecl (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEntityDecl (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEntityDecl)) return (_currn);
if (IsSymb (_currn, SYMBxObjectName)) return (Mkrule_643(_coordref, _currn));
if (IsSymb (_currn, SYMBxInvalidEntityDecl)) return (Mkrule_600(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxEntityDecl */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkDimensionDeclarators (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkDimensionDeclarators (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBDimensionDeclarators)) return (_currn);
if (IsSymb (_currn, SYMBxDeferredShapeSpec)) return (Mkrule_788(_coordref, _currn));
if (IsSymb (_currn, SYMBxUpperBound)) return (Mkrule_788(_coordref, _currn));
if (IsSymb (_currn, SYMBxExplicitShapeSpec)) return (Mkrule_788(_coordref, _currn));
if (IsSymb (_currn, SYMBxArraySpec)) return (Mkrule_788(_coordref, _currn));
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_788(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_788(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_788(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_788(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_788(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_788(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_788(_coordref, _currn));
return(NULLNODEPTR);
}/* MkDimensionDeclarators */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxArrayDeclarator (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxArrayDeclarator (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxArrayDeclarator)) return (_currn);
return(NULLNODEPTR);
}/* MkxArrayDeclarator */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSubstringRange (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSubstringRange (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSubstringRange)) return (_currn);
return(NULLNODEPTR);
}/* MkxSubstringRange */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxLblRefList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxLblRefList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxLblRefList)) return (_currn);
if (IsSymb (_currn, SYMBxLabel)) return (Mkrule_211(_coordref, _currn));
if (IsSymb (_currn, SYMBxLblRef)) return (Mkrule_211(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxLblRefList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkGoToKw (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkGoToKw (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBGoToKw)) return (_currn);
return(NULLNODEPTR);
}/* MkGoToKw */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxComma (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxComma (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxComma)) return (_currn);
return(NULLNODEPTR);
}/* MkxComma */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxIoControlSpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxIoControlSpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxIoControlSpec)) return (_currn);
if (IsSymb (_currn, SYMBxRdUnitId)) return (Mkrule_157(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxIoControlSpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxInputItemList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxInputItemList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxInputItemList)) return (_currn);
if (IsSymb (_currn, SYMBxDataRef)) return (Mkrule_265(_coordref, _currn));
if (IsSymb (_currn, SYMBxInputImpliedDo)) return (Mkrule_265(_coordref, _currn));
if (IsSymb (_currn, SYMBxVariable)) return (Mkrule_265(_coordref, _currn));
if (IsSymb (_currn, SYMBxInputItem)) return (Mkrule_265(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_265(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxInputItemList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxFormatIdentifier (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxFormatIdentifier (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxFormatIdentifier)) return (_currn);
if (IsSymb (_currn, SYMBxLabel)) return (Mkrule_284(_coordref, _currn));
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_285(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_285(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_285(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_285(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_285(_coordref, _currn));
if (IsSymb (_currn, SYMBxLblRef)) return (Mkrule_284(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_285(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_285(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxFormatIdentifier */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxOutputItemList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxOutputItemList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxOutputItemList)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_175(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_175(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_175(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_175(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_175(_coordref, _currn));
if (IsSymb (_currn, SYMBxOutputImpliedDo)) return (Mkrule_178(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_175(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_175(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxOutputItemList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxScalarVariable (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxScalarVariable (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxScalarVariable)) return (_currn);
if (IsSymb (_currn, SYMBxArrayElement)) return (Mkrule_144(_coordref, _currn));
if (IsSymb (_currn, SYMBxVariableName)) return (Mkrule_143(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxScalarVariable */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxLoopControl (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxLoopControl (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxLoopControl)) return (_currn);
return(NULLNODEPTR);
}/* MkxLoopControl */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxArgList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxArgList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxArgList)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_552(_coordref, _currn));
if (IsSymb (_currn, SYMBxArg)) return (Mkrule_552(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_552(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_552(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_552(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_552(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_552(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_552(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxArgList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxUnitIdentifier (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxUnitIdentifier (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxUnitIdentifier)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_115(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_115(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_115(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_115(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_115(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_115(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_115(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxUnitIdentifier */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxIoControlSpecList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxIoControlSpecList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxIoControlSpecList)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_407(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_407(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_407(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_407(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_407(_coordref, _currn));
if (IsSymb (_currn, SYMBxRdUnitId)) return (Mkrule_409(_coordref, _currn));
if (IsSymb (_currn, SYMBxIoControlSpec)) return (Mkrule_409(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_407(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnitIdentifier)) return (Mkrule_407(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_407(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxIoControlSpecList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxStmtFunctionRange (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxStmtFunctionRange (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxStmtFunctionRange)) return (_currn);
return(NULLNODEPTR);
}/* MkxStmtFunctionRange */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSavedEntityList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSavedEntityList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSavedEntityList)) return (_currn);
if (IsSymb (_currn, SYMBxComblock)) return (Mkrule_147(_coordref, _currn));
if (IsSymb (_currn, SYMBxSavedEntity)) return (Mkrule_147(_coordref, _currn));
if (IsSymb (_currn, SYMBxVariableName)) return (Mkrule_147(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxSavedEntityList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxIntrinsicList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxIntrinsicList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxIntrinsicList)) return (_currn);
if (IsSymb (_currn, SYMBxIntrinsicProcedureName)) return (Mkrule_225(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxIntrinsicList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxExternalNameList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxExternalNameList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxExternalNameList)) return (_currn);
if (IsSymb (_currn, SYMBxExternalName)) return (Mkrule_305(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxExternalNameList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEquivalenceSetList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEquivalenceSetList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEquivalenceSetList)) return (_currn);
if (IsSymb (_currn, SYMBxEquivalenceSet)) return (Mkrule_317(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxEquivalenceSetList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxArrayDeclaratorList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxArrayDeclaratorList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxArrayDeclaratorList)) return (_currn);
if (IsSymb (_currn, SYMBxArrayDeclarator)) return (Mkrule_997(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxArrayDeclaratorList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxComlist (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxComlist (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxComlist)) return (_currn);
if (IsSymb (_currn, SYMBxArrayDeclarator)) return (Mkrule_401(_coordref, _currn));
if (IsSymb (_currn, SYMBxCommonBlockObject)) return (Mkrule_401(_coordref, _currn));
if (IsSymb (_currn, SYMBxVariableName)) return (Mkrule_401(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxComlist */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxImplicitSpecList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxImplicitSpecList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxImplicitSpecList)) return (_currn);
if (IsSymb (_currn, SYMBxImplicitSpec)) return (Mkrule_272(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxImplicitSpecList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDatalist (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDatalist (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDatalist)) return (_currn);
if (IsSymb (_currn, SYMBxDataStmtSet)) return (Mkrule_564(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDatalist */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxNamedConstantDefList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxNamedConstantDefList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxNamedConstantDefList)) return (_currn);
if (IsSymb (_currn, SYMBxNamedConstantDef)) return (Mkrule_631(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxNamedConstantDefList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxFmtSpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxFmtSpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxFmtSpec)) return (_currn);
return(NULLNODEPTR);
}/* MkxFmtSpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxStmt)) return (_currn);
if (IsSymb (_currn, SYMBxAttrStmt)) return (Mkrule_597(_coordref, _currn));
if (IsSymb (_currn, SYMBxForallStmt)) return (Mkrule_441(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxLabel (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxLabel (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxLabel)) return (_currn);
return(NULLNODEPTR);
}/* MkxLabel */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxInterfaceBody (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxInterfaceBody (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxInterfaceBody)) return (_currn);
return(NULLNODEPTR);
}/* MkxInterfaceBody */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSourceFile (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSourceFile (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSourceFile)) return (_currn);
if (IsSymb (_currn, SYMBxModule)) return (Mkrule_139(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndProgramStmt)) return (Mkrule_139(_coordref, _currn));
if (IsSymb (_currn, SYMBxMainRange)) return (Mkrule_139(_coordref, _currn));
if (IsSymb (_currn, SYMBxProgramUnit)) return (Mkrule_139(_coordref, _currn));
if (IsSymb (_currn, SYMBxExecutableProgram)) return (Mkrule_139(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxSourceFile */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxPointerObject (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxPointerObject (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxPointerObject)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_856(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxPointerObject */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxExprList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxExprList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxExprList)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_494(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_494(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_494(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_494(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_494(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_494(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_494(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxExprList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSFDummyArgNameList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSFDummyArgNameList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSFDummyArgNameList)) return (_currn);
if (IsSymb (_currn, SYMBxSFDummyArgName)) return (Mkrule_490(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxSFDummyArgNameList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDerivedName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDerivedName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDerivedName)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_858(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDerivedName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxStructureComponent (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxStructureComponent (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxStructureComponent)) return (_currn);
return(NULLNODEPTR);
}/* MkxStructureComponent */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxAllocateObject (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxAllocateObject (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxAllocateObject)) return (_currn);
if (IsSymb (_currn, SYMBxVariableName)) return (Mkrule_864(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxAllocateObject */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkSMSVariable (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkSMSVariable (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBSMSVariable)) return (_currn);
if (IsSymb (_currn, SYMBxName)) return (Mkrule_866(_coordref, _currn));
return(NULLNODEPTR);
}/* MkSMSVariable */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSectionSubscriptList (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSectionSubscriptList (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSectionSubscriptList)) return (_currn);
if (IsSymb (_currn, SYMBxSubscriptTriplet)) return (Mkrule_667(_coordref, _currn));
if (IsSymb (_currn, SYMBxSectionSubscript)) return (Mkrule_667(_coordref, _currn));
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_667(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_667(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_667(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_667(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_667(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_667(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_667(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxSectionSubscriptList */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxFieldSelector (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxFieldSelector (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxFieldSelector)) return (_currn);
return(NULLNODEPTR);
}/* MkxFieldSelector */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxCompName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxCompName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxCompName)) return (_currn);
return(NULLNODEPTR);
}/* MkxCompName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEndTypeStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEndTypeStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEndTypeStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxEndTypeStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDerivedTypeStmt (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDerivedTypeStmt (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDerivedTypeStmt)) return (_currn);
return(NULLNODEPTR);
}/* MkxDerivedTypeStmt */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDerivedTypeDef (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDerivedTypeDef (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDerivedTypeDef)) return (_currn);
return(NULLNODEPTR);
}/* MkxDerivedTypeDef */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDerivedTypeBody (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDerivedTypeBody (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDerivedTypeBody)) return (_currn);
if (IsSymb (_currn, SYMBxDeclareDecomp)) return (Mkrule_360(_coordref, _currn));
if (IsSymb (_currn, SYMBxComponentDefStmt)) return (Mkrule_360(_coordref, _currn));
if (IsSymb (_currn, SYMBxPrivateSequenceStmt)) return (Mkrule_360(_coordref, _currn));
if (IsSymb (_currn, SYMBxDerivedTypeBodyConstruct)) return (Mkrule_360(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDerivedTypeBody */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDerivedBody (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDerivedBody (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDerivedBody)) return (_currn);
if (IsSymb (_currn, SYMBxDeclareDecomp)) return (Mkrule_870(_coordref, _currn));
if (IsSymb (_currn, SYMBxDerivedTypeBody)) return (Mkrule_870(_coordref, _currn));
if (IsSymb (_currn, SYMBxComponentDefStmt)) return (Mkrule_870(_coordref, _currn));
if (IsSymb (_currn, SYMBxPrivateSequenceStmt)) return (Mkrule_870(_coordref, _currn));
if (IsSymb (_currn, SYMBxDerivedTypeBodyConstruct)) return (Mkrule_870(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxDerivedBody */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxTypeSpec (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxTypeSpec (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxTypeSpec)) return (_currn);
return(NULLNODEPTR);
}/* MkxTypeSpec */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxTypeName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxTypeName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxTypeName)) return (_currn);
return(NULLNODEPTR);
}/* MkxTypeName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxTypeUseName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxTypeUseName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxTypeUseName)) return (_currn);
if (IsSymb (_currn, SYMBxTypeName)) return (Mkrule_872(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxTypeUseName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxProgramUnit (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxProgramUnit (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxProgramUnit)) return (_currn);
if (IsSymb (_currn, SYMBxModule)) return (Mkrule_669(_coordref, _currn));
if (IsSymb (_currn, SYMBxEndProgramStmt)) return (Mkrule_659(_coordref, _currn));
if (IsSymb (_currn, SYMBxMainRange)) return (Mkrule_659(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxProgramUnit */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxLblRef (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxLblRef (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxLblRef)) return (_currn);
if (IsSymb (_currn, SYMBxLabel)) return (Mkrule_851(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxLblRef */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxLblDef (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxLblDef (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxLblDef)) return (_currn);
if (IsSymb (_currn, SYMBxLabel)) return (Mkrule_853(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxLblDef */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxUseName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxUseName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxUseName)) return (_currn);
return(NULLNODEPTR);
}/* MkxUseName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxComponentName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxComponentName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxComponentName)) return (_currn);
return(NULLNODEPTR);
}/* MkxComponentName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxArrayName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxArrayName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxArrayName)) return (_currn);
return(NULLNODEPTR);
}/* MkxArrayName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxVariableName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxVariableName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxVariableName)) return (_currn);
return(NULLNODEPTR);
}/* MkxVariableName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSubroutineNameUse (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSubroutineNameUse (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSubroutineNameUse)) return (_currn);
return(NULLNODEPTR);
}/* MkxSubroutineNameUse */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSubroutineName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSubroutineName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSubroutineName)) return (_currn);
return(NULLNODEPTR);
}/* MkxSubroutineName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSFVarName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSFVarName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSFVarName)) return (_currn);
return(NULLNODEPTR);
}/* MkxSFVarName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxSFDummyArgName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxSFDummyArgName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxSFDummyArgName)) return (_currn);
return(NULLNODEPTR);
}/* MkxSFDummyArgName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxProgramName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxProgramName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxProgramName)) return (_currn);
return(NULLNODEPTR);
}/* MkxProgramName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxObjectName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxObjectName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxObjectName)) return (_currn);
return(NULLNODEPTR);
}/* MkxObjectName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxNamedConstantUse (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxNamedConstantUse (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxNamedConstantUse)) return (_currn);
return(NULLNODEPTR);
}/* MkxNamedConstantUse */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxNamedConstant (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxNamedConstant (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxNamedConstant)) return (_currn);
return(NULLNODEPTR);
}/* MkxNamedConstant */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxIntrinsicProcedureName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxIntrinsicProcedureName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxIntrinsicProcedureName)) return (_currn);
return(NULLNODEPTR);
}/* MkxIntrinsicProcedureName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxImpliedDoVariable (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxImpliedDoVariable (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxImpliedDoVariable)) return (_currn);
return(NULLNODEPTR);
}/* MkxImpliedDoVariable */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxFunctionName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxFunctionName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxFunctionName)) return (_currn);
return(NULLNODEPTR);
}/* MkxFunctionName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxExternalName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxExternalName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxExternalName)) return (_currn);
return(NULLNODEPTR);
}/* MkxExternalName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxEntryName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxEntryName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxEntryName)) return (_currn);
return(NULLNODEPTR);
}/* MkxEntryName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxDummyArgName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxDummyArgName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxDummyArgName)) return (_currn);
return(NULLNODEPTR);
}/* MkxDummyArgName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxCommonBlockName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxCommonBlockName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxCommonBlockName)) return (_currn);
return(NULLNODEPTR);
}/* MkxCommonBlockName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxBlockDataName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxBlockDataName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxBlockDataName)) return (_currn);
return(NULLNODEPTR);
}/* MkxBlockDataName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxBinOp (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxBinOp (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxBinOp)) return (_currn);
return(NULLNODEPTR);
}/* MkxBinOp */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxUnOp (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxUnOp (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxUnOp)) return (_currn);
return(NULLNODEPTR);
}/* MkxUnOp */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxName (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxName (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxName)) return (_currn);
return(NULLNODEPTR);
}/* MkxName */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxKindParam (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxKindParam (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxKindParam)) return (_currn);
if (IsSymb (_currn, SYMBxNamedConstantUse)) return (Mkrule_510(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxKindParam */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxLogicalConstant (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxLogicalConstant (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxLogicalConstant)) return (_currn);
return(NULLNODEPTR);
}/* MkxLogicalConstant */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxUnsignedArithmeticConstant (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxUnsignedArithmeticConstant (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (_currn);
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_546(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxUnsignedArithmeticConstant */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxUpperBound (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxUpperBound (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxUpperBound)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_896(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_896(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_896(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_896(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_896(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_896(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_896(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxUpperBound */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxExpr (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxExpr (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxExpr)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_610(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_884(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_884(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_495(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_472(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_883(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxExpr */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR MkxLowerBound (POSITION *_coordref, NODEPTR _currn)
#else
NODEPTR MkxLowerBound (_coordref, _currn)
	POSITION *_coordref; NODEPTR _currn;
#endif
{
if (_currn == NULLNODEPTR) return NULLNODEPTR;
if (IsSymb (_currn, SYMBxLowerBound)) return (_currn);
if (IsSymb (_currn, SYMBxLogicalConstant)) return (Mkrule_897(_coordref, _currn));
if (IsSymb (_currn, SYMBxComplexConst)) return (Mkrule_897(_coordref, _currn));
if (IsSymb (_currn, SYMBxUnsignedArithmeticConstant)) return (Mkrule_897(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFVarName)) return (Mkrule_897(_coordref, _currn));
if (IsSymb (_currn, SYMBxSFDataRef)) return (Mkrule_897(_coordref, _currn));
if (IsSymb (_currn, SYMBxExpr)) return (Mkrule_897(_coordref, _currn));
if (IsSymb (_currn, SYMBxName)) return (Mkrule_897(_coordref, _currn));
return(NULLNODEPTR);
}/* MkxLowerBound */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1 (POSITION *_coordref)
#else
NODEPTR Mkrule_1 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_1 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1;
#else
_currn = (_TPPrule_1) TreeNodeAlloc (sizeof (struct _TPrule_1));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1;
_SETCOORD(_currn)
_TERMACT_rule_1;
return ( (NODEPTR) _currn);
}/* Mkrule_1 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_2 (POSITION *_coordref)
#else
NODEPTR Mkrule_2 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_2 _currn;
#ifdef __cplusplus
_currn = new _TPrule_2;
#else
_currn = (_TPPrule_2) TreeNodeAlloc (sizeof (struct _TPrule_2));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_2;
_SETCOORD(_currn)
_TERMACT_rule_2;
return ( (NODEPTR) _currn);
}/* Mkrule_2 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_3 (POSITION *_coordref)
#else
NODEPTR Mkrule_3 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_3 _currn;
#ifdef __cplusplus
_currn = new _TPrule_3;
#else
_currn = (_TPPrule_3) TreeNodeAlloc (sizeof (struct _TPrule_3));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_3;
_SETCOORD(_currn)
_TERMACT_rule_3;
return ( (NODEPTR) _currn);
}/* Mkrule_3 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_4 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_4 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_4 _currn;
#ifdef __cplusplus
_currn = new _TPrule_4;
#else
_currn = (_TPPrule_4) TreeNodeAlloc (sizeof (struct _TPrule_4));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_4;
_SETCOORD(_currn)
_TERMACT_rule_4;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_4 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_5 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_5 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_5 _currn;
#ifdef __cplusplus
_currn = new _TPrule_5;
#else
_currn = (_TPPrule_5) TreeNodeAlloc (sizeof (struct _TPrule_5));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_5;
_SETCOORD(_currn)
_TERMACT_rule_5;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_5 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_6 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_6 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_6 _currn;
#ifdef __cplusplus
_currn = new _TPrule_6;
#else
_currn = (_TPPrule_6) TreeNodeAlloc (sizeof (struct _TPrule_6));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_6;
_currn->_desc1 = (_TSPParams) MkParams (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_6: root of subtree no. 1 can not be made a Params node ", 0, _coordref);
_currn->_desc2 = (_TSPOptDim) MkOptDim (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_6: root of subtree no. 2 can not be made a OptDim node ", 0, _coordref);
_currn->_desc3 = (_TSPAccThreadBegin) MkAccThreadBegin (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_6: root of subtree no. 3 can not be made a AccThreadBegin node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_6;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_6 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_7 (POSITION *_coordref)
#else
NODEPTR Mkrule_7 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_7 _currn;
#ifdef __cplusplus
_currn = new _TPrule_7;
#else
_currn = (_TPPrule_7) TreeNodeAlloc (sizeof (struct _TPrule_7));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_7;
_SETCOORD(_currn)
_TERMACT_rule_7;
return ( (NODEPTR) _currn);
}/* Mkrule_7 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_8 (POSITION *_coordref)
#else
NODEPTR Mkrule_8 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_8 _currn;
#ifdef __cplusplus
_currn = new _TPrule_8;
#else
_currn = (_TPPrule_8) TreeNodeAlloc (sizeof (struct _TPrule_8));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_8;
_SETCOORD(_currn)
_TERMACT_rule_8;
return ( (NODEPTR) _currn);
}/* Mkrule_8 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_9 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_9 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_9 _currn;
#ifdef __cplusplus
_currn = new _TPrule_9;
#else
_currn = (_TPPrule_9) TreeNodeAlloc (sizeof (struct _TPrule_9));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_9;
_currn->_desc1 = (_TSPParams) MkParams (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_9: root of subtree no. 1 can not be made a Params node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_9;
return ( (NODEPTR) _currn);
}/* Mkrule_9 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_10 (POSITION *_coordref)
#else
NODEPTR Mkrule_10 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_10 _currn;
#ifdef __cplusplus
_currn = new _TPrule_10;
#else
_currn = (_TPPrule_10) TreeNodeAlloc (sizeof (struct _TPrule_10));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_10;
_SETCOORD(_currn)
_TERMACT_rule_10;
return ( (NODEPTR) _currn);
}/* Mkrule_10 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_11 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_11 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_11 _currn;
#ifdef __cplusplus
_currn = new _TPrule_11;
#else
_currn = (_TPPrule_11) TreeNodeAlloc (sizeof (struct _TPrule_11));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_11;
_currn->_desc1 = (_TSPParams) MkParams (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_11: root of subtree no. 1 can not be made a Params node ", 0, _coordref);
_currn->_desc2 = (_TSPParams) MkParams (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_11: root of subtree no. 2 can not be made a Params node ", 0, _coordref);
_currn->_desc3 = (_TSPThreadStart) MkThreadStart (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_11: root of subtree no. 3 can not be made a ThreadStart node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_11;
return ( (NODEPTR) _currn);
}/* Mkrule_11 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_12 (POSITION *_coordref)
#else
NODEPTR Mkrule_12 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_12 _currn;
#ifdef __cplusplus
_currn = new _TPrule_12;
#else
_currn = (_TPPrule_12) TreeNodeAlloc (sizeof (struct _TPrule_12));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_12;
_SETCOORD(_currn)
_TERMACT_rule_12;
return ( (NODEPTR) _currn);
}/* Mkrule_12 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_13 (POSITION *_coordref)
#else
NODEPTR Mkrule_13 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_13 _currn;
#ifdef __cplusplus
_currn = new _TPrule_13;
#else
_currn = (_TPPrule_13) TreeNodeAlloc (sizeof (struct _TPrule_13));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_13;
_SETCOORD(_currn)
_TERMACT_rule_13;
return ( (NODEPTR) _currn);
}/* Mkrule_13 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_14 (POSITION *_coordref)
#else
NODEPTR Mkrule_14 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_14 _currn;
#ifdef __cplusplus
_currn = new _TPrule_14;
#else
_currn = (_TPPrule_14) TreeNodeAlloc (sizeof (struct _TPrule_14));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_14;
_SETCOORD(_currn)
_TERMACT_rule_14;
return ( (NODEPTR) _currn);
}/* Mkrule_14 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_15 (POSITION *_coordref)
#else
NODEPTR Mkrule_15 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_15 _currn;
#ifdef __cplusplus
_currn = new _TPrule_15;
#else
_currn = (_TPPrule_15) TreeNodeAlloc (sizeof (struct _TPrule_15));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_15;
_SETCOORD(_currn)
_TERMACT_rule_15;
return ( (NODEPTR) _currn);
}/* Mkrule_15 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_16 (POSITION *_coordref)
#else
NODEPTR Mkrule_16 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_16 _currn;
#ifdef __cplusplus
_currn = new _TPrule_16;
#else
_currn = (_TPPrule_16) TreeNodeAlloc (sizeof (struct _TPrule_16));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_16;
_SETCOORD(_currn)
_TERMACT_rule_16;
return ( (NODEPTR) _currn);
}/* Mkrule_16 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_17 (POSITION *_coordref)
#else
NODEPTR Mkrule_17 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_17 _currn;
#ifdef __cplusplus
_currn = new _TPrule_17;
#else
_currn = (_TPPrule_17) TreeNodeAlloc (sizeof (struct _TPrule_17));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_17;
_SETCOORD(_currn)
_TERMACT_rule_17;
return ( (NODEPTR) _currn);
}/* Mkrule_17 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_18 (POSITION *_coordref)
#else
NODEPTR Mkrule_18 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_18 _currn;
#ifdef __cplusplus
_currn = new _TPrule_18;
#else
_currn = (_TPPrule_18) TreeNodeAlloc (sizeof (struct _TPrule_18));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_18;
_SETCOORD(_currn)
_TERMACT_rule_18;
return ( (NODEPTR) _currn);
}/* Mkrule_18 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_19 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_19 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_19 _currn;
#ifdef __cplusplus
_currn = new _TPrule_19;
#else
_currn = (_TPPrule_19) TreeNodeAlloc (sizeof (struct _TPrule_19));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_19;
_SETCOORD(_currn)
_TERMACT_rule_19;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_19 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_20 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_20 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_20 _currn;
#ifdef __cplusplus
_currn = new _TPrule_20;
#else
_currn = (_TPPrule_20) TreeNodeAlloc (sizeof (struct _TPrule_20));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_20;
_currn->_desc1 = (_TSPParams) MkParams (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_20: root of subtree no. 1 can not be made a Params node ", 0, _coordref);
_currn->_desc2 = (_TSPBinOp) MkBinOp (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_20: root of subtree no. 2 can not be made a BinOp node ", 0, _coordref);
_currn->_desc3 = (_TSPParam) MkParam (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_20: root of subtree no. 3 can not be made a Param node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_20;
return ( (NODEPTR) _currn);
}/* Mkrule_20 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_21 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_21 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_21 _currn;
#ifdef __cplusplus
_currn = new _TPrule_21;
#else
_currn = (_TPPrule_21) TreeNodeAlloc (sizeof (struct _TPrule_21));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_21;
_currn->_desc1 = (_TSPParam) MkParam (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_21: root of subtree no. 1 can not be made a Param node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_21;
return ( (NODEPTR) _currn);
}/* Mkrule_21 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_22 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_22 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_22 _currn;
#ifdef __cplusplus
_currn = new _TPrule_22;
#else
_currn = (_TPPrule_22) TreeNodeAlloc (sizeof (struct _TPrule_22));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_22;
_currn->_desc1 = (_TSPParams) MkParams (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_22: root of subtree no. 1 can not be made a Params node ", 0, _coordref);
_currn->_desc2 = (_TSPBinOp) MkBinOp (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_22: root of subtree no. 2 can not be made a BinOp node ", 0, _coordref);
_currn->_desc3 = (_TSPParam) MkParam (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_22: root of subtree no. 3 can not be made a Param node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_22;
return ( (NODEPTR) _currn);
}/* Mkrule_22 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_23 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_23 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_23 _currn;
#ifdef __cplusplus
_currn = new _TPrule_23;
#else
_currn = (_TPPrule_23) TreeNodeAlloc (sizeof (struct _TPrule_23));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_23;
_SETCOORD(_currn)
_TERMACT_rule_23;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_23 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_24 (POSITION *_coordref)
#else
NODEPTR Mkrule_24 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_24 _currn;
#ifdef __cplusplus
_currn = new _TPrule_24;
#else
_currn = (_TPPrule_24) TreeNodeAlloc (sizeof (struct _TPrule_24));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_24;
_SETCOORD(_currn)
_TERMACT_rule_24;
return ( (NODEPTR) _currn);
}/* Mkrule_24 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_25 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_25 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_25 _currn;
#ifdef __cplusplus
_currn = new _TPrule_25;
#else
_currn = (_TPPrule_25) TreeNodeAlloc (sizeof (struct _TPrule_25));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_25;
_currn->_desc1 = (_TSPThreadSpec) MkThreadSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_25: root of subtree no. 1 can not be made a ThreadSpec node ", 0, _coordref);
_currn->_desc2 = (_TSPBlockSpec) MkBlockSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_25: root of subtree no. 2 can not be made a BlockSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPDataSection) MkDataSection (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_25: root of subtree no. 3 can not be made a DataSection node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_25;
return ( (NODEPTR) _currn);
}/* Mkrule_25 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_26 (POSITION *_coordref)
#else
NODEPTR Mkrule_26 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_26 _currn;
#ifdef __cplusplus
_currn = new _TPrule_26;
#else
_currn = (_TPPrule_26) TreeNodeAlloc (sizeof (struct _TPrule_26));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_26;
_SETCOORD(_currn)
_TERMACT_rule_26;
return ( (NODEPTR) _currn);
}/* Mkrule_26 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_27 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_27 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_27 _currn;
#ifdef __cplusplus
_currn = new _TPrule_27;
#else
_currn = (_TPPrule_27) TreeNodeAlloc (sizeof (struct _TPrule_27));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_27;
_SETCOORD(_currn)
_TERMACT_rule_27;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_27 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_28 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_28 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_28 _currn;
#ifdef __cplusplus
_currn = new _TPrule_28;
#else
_currn = (_TPPrule_28) TreeNodeAlloc (sizeof (struct _TPrule_28));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_28;
_currn->_desc1 = (_TSPNumBlocks) MkNumBlocks (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_28: root of subtree no. 1 can not be made a NumBlocks node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_28;
return ( (NODEPTR) _currn);
}/* Mkrule_28 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_29 (POSITION *_coordref)
#else
NODEPTR Mkrule_29 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_29 _currn;
#ifdef __cplusplus
_currn = new _TPrule_29;
#else
_currn = (_TPPrule_29) TreeNodeAlloc (sizeof (struct _TPrule_29));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_29;
_SETCOORD(_currn)
_TERMACT_rule_29;
return ( (NODEPTR) _currn);
}/* Mkrule_29 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_30 (POSITION *_coordref)
#else
NODEPTR Mkrule_30 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_30 _currn;
#ifdef __cplusplus
_currn = new _TPrule_30;
#else
_currn = (_TPPrule_30) TreeNodeAlloc (sizeof (struct _TPrule_30));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_30;
_SETCOORD(_currn)
_TERMACT_rule_30;
return ( (NODEPTR) _currn);
}/* Mkrule_30 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_31 (POSITION *_coordref)
#else
NODEPTR Mkrule_31 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_31 _currn;
#ifdef __cplusplus
_currn = new _TPrule_31;
#else
_currn = (_TPPrule_31) TreeNodeAlloc (sizeof (struct _TPrule_31));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_31;
_SETCOORD(_currn)
_TERMACT_rule_31;
return ( (NODEPTR) _currn);
}/* Mkrule_31 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_32 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_32 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_32 _currn;
#ifdef __cplusplus
_currn = new _TPrule_32;
#else
_currn = (_TPPrule_32) TreeNodeAlloc (sizeof (struct _TPrule_32));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_32;
_currn->_desc1 = (_TSPSharedDims) MkSharedDims (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_32: root of subtree no. 1 can not be made a SharedDims node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_32;
return ( (NODEPTR) _currn);
}/* Mkrule_32 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_33 (POSITION *_coordref)
#else
NODEPTR Mkrule_33 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_33 _currn;
#ifdef __cplusplus
_currn = new _TPrule_33;
#else
_currn = (_TPPrule_33) TreeNodeAlloc (sizeof (struct _TPrule_33));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_33;
_SETCOORD(_currn)
_TERMACT_rule_33;
return ( (NODEPTR) _currn);
}/* Mkrule_33 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_34 (POSITION *_coordref)
#else
NODEPTR Mkrule_34 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_34 _currn;
#ifdef __cplusplus
_currn = new _TPrule_34;
#else
_currn = (_TPPrule_34) TreeNodeAlloc (sizeof (struct _TPrule_34));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_34;
_SETCOORD(_currn)
_TERMACT_rule_34;
return ( (NODEPTR) _currn);
}/* Mkrule_34 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_35 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_35 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_35 _currn;
#ifdef __cplusplus
_currn = new _TPrule_35;
#else
_currn = (_TPPrule_35) TreeNodeAlloc (sizeof (struct _TPrule_35));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_35;
_currn->_desc1 = (_TSPLogical) MkLogical (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_35: root of subtree no. 1 can not be made a Logical node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_35;
return ( (NODEPTR) _currn);
}/* Mkrule_35 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_36 (POSITION *_coordref)
#else
NODEPTR Mkrule_36 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_36 _currn;
#ifdef __cplusplus
_currn = new _TPrule_36;
#else
_currn = (_TPPrule_36) TreeNodeAlloc (sizeof (struct _TPrule_36));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_36;
_SETCOORD(_currn)
_TERMACT_rule_36;
return ( (NODEPTR) _currn);
}/* Mkrule_36 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_37 (POSITION *_coordref)
#else
NODEPTR Mkrule_37 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_37 _currn;
#ifdef __cplusplus
_currn = new _TPrule_37;
#else
_currn = (_TPPrule_37) TreeNodeAlloc (sizeof (struct _TPrule_37));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_37;
_SETCOORD(_currn)
_TERMACT_rule_37;
return ( (NODEPTR) _currn);
}/* Mkrule_37 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_38 (POSITION *_coordref)
#else
NODEPTR Mkrule_38 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_38 _currn;
#ifdef __cplusplus
_currn = new _TPrule_38;
#else
_currn = (_TPPrule_38) TreeNodeAlloc (sizeof (struct _TPrule_38));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_38;
_SETCOORD(_currn)
_TERMACT_rule_38;
return ( (NODEPTR) _currn);
}/* Mkrule_38 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_39 (POSITION *_coordref)
#else
NODEPTR Mkrule_39 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_39 _currn;
#ifdef __cplusplus
_currn = new _TPrule_39;
#else
_currn = (_TPPrule_39) TreeNodeAlloc (sizeof (struct _TPrule_39));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_39;
_SETCOORD(_currn)
_TERMACT_rule_39;
return ( (NODEPTR) _currn);
}/* Mkrule_39 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_40 (POSITION *_coordref)
#else
NODEPTR Mkrule_40 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_40 _currn;
#ifdef __cplusplus
_currn = new _TPrule_40;
#else
_currn = (_TPPrule_40) TreeNodeAlloc (sizeof (struct _TPrule_40));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_40;
_SETCOORD(_currn)
_TERMACT_rule_40;
return ( (NODEPTR) _currn);
}/* Mkrule_40 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_41 (POSITION *_coordref)
#else
NODEPTR Mkrule_41 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_41 _currn;
#ifdef __cplusplus
_currn = new _TPrule_41;
#else
_currn = (_TPPrule_41) TreeNodeAlloc (sizeof (struct _TPrule_41));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_41;
_SETCOORD(_currn)
_TERMACT_rule_41;
return ( (NODEPTR) _currn);
}/* Mkrule_41 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_42 (POSITION *_coordref)
#else
NODEPTR Mkrule_42 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_42 _currn;
#ifdef __cplusplus
_currn = new _TPrule_42;
#else
_currn = (_TPPrule_42) TreeNodeAlloc (sizeof (struct _TPrule_42));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_42;
_SETCOORD(_currn)
_TERMACT_rule_42;
return ( (NODEPTR) _currn);
}/* Mkrule_42 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_43 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_43 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_43 _currn;
#ifdef __cplusplus
_currn = new _TPrule_43;
#else
_currn = (_TPPrule_43) TreeNodeAlloc (sizeof (struct _TPrule_43));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_43;
_currn->_desc1 = (_TSPGPUVariables) MkGPUVariables (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_43: root of subtree no. 1 can not be made a GPUVariables node ", 0, _coordref);
_currn->_desc2 = (_TSPGPUVariable) MkGPUVariable (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_43: root of subtree no. 2 can not be made a GPUVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_43;
return ( (NODEPTR) _currn);
}/* Mkrule_43 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_44 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_44 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_44 _currn;
#ifdef __cplusplus
_currn = new _TPrule_44;
#else
_currn = (_TPPrule_44) TreeNodeAlloc (sizeof (struct _TPrule_44));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_44;
_currn->_desc1 = (_TSPGPUVariable) MkGPUVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_44: root of subtree no. 1 can not be made a GPUVariable node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_44;
return ( (NODEPTR) _currn);
}/* Mkrule_44 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_45 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_45 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_45 _currn;
#ifdef __cplusplus
_currn = new _TPrule_45;
#else
_currn = (_TPPrule_45) TreeNodeAlloc (sizeof (struct _TPrule_45));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_45;
_currn->_desc1 = (_TSPDataUsages) MkDataUsages (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_45: root of subtree no. 1 can not be made a DataUsages node ", 0, _coordref);
_currn->_desc2 = (_TSPDataUsage) MkDataUsage (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_45: root of subtree no. 2 can not be made a DataUsage node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_45;
return ( (NODEPTR) _currn);
}/* Mkrule_45 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_46 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_46 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_46 _currn;
#ifdef __cplusplus
_currn = new _TPrule_46;
#else
_currn = (_TPPrule_46) TreeNodeAlloc (sizeof (struct _TPrule_46));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_46;
_currn->_desc1 = (_TSPDataUsage) MkDataUsage (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_46: root of subtree no. 1 can not be made a DataUsage node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_46;
return ( (NODEPTR) _currn);
}/* Mkrule_46 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_47 (POSITION *_coordref)
#else
NODEPTR Mkrule_47 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_47 _currn;
#ifdef __cplusplus
_currn = new _TPrule_47;
#else
_currn = (_TPPrule_47) TreeNodeAlloc (sizeof (struct _TPrule_47));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_47;
_SETCOORD(_currn)
_TERMACT_rule_47;
return ( (NODEPTR) _currn);
}/* Mkrule_47 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_48 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_48 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_48 _currn;
#ifdef __cplusplus
_currn = new _TPrule_48;
#else
_currn = (_TPPrule_48) TreeNodeAlloc (sizeof (struct _TPrule_48));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_48;
_currn->_desc1 = (_TSPDataUsages) MkDataUsages (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_48: root of subtree no. 1 can not be made a DataUsages node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_48;
return ( (NODEPTR) _currn);
}/* Mkrule_48 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_49 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_49 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_49 _currn;
#ifdef __cplusplus
_currn = new _TPrule_49;
#else
_currn = (_TPPrule_49) TreeNodeAlloc (sizeof (struct _TPrule_49));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_49;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_49: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_49;
return ( (NODEPTR) _currn);
}/* Mkrule_49 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_50 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_50 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_50 _currn;
#ifdef __cplusplus
_currn = new _TPrule_50;
#else
_currn = (_TPPrule_50) TreeNodeAlloc (sizeof (struct _TPrule_50));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_50;
_currn->_desc1 = (_TSPParam) MkParam (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_50: root of subtree no. 1 can not be made a Param node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_50;
return ( (NODEPTR) _currn);
}/* Mkrule_50 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_51 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_51 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_51 _currn;
#ifdef __cplusplus
_currn = new _TPrule_51;
#else
_currn = (_TPPrule_51) TreeNodeAlloc (sizeof (struct _TPrule_51));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_51;
_currn->_desc1 = (_TSPParams) MkParams (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_51: root of subtree no. 1 can not be made a Params node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_51;
return ( (NODEPTR) _currn);
}/* Mkrule_51 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_52 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_52 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_52 _currn;
#ifdef __cplusplus
_currn = new _TPrule_52;
#else
_currn = (_TPPrule_52) TreeNodeAlloc (sizeof (struct _TPrule_52));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_52;
_currn->_desc1 = (_TSPParams) MkParams (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_52: root of subtree no. 1 can not be made a Params node ", 0, _coordref);
_currn->_desc2 = (_TSPThreadOption) MkThreadOption (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_52: root of subtree no. 2 can not be made a ThreadOption node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_52;
return ( (NODEPTR) _currn);
}/* Mkrule_52 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_53 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_53 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_53 _currn;
#ifdef __cplusplus
_currn = new _TPrule_53;
#else
_currn = (_TPPrule_53) TreeNodeAlloc (sizeof (struct _TPrule_53));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_53;
_currn->_desc1 = (_TSPBlock) MkBlock (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_53: root of subtree no. 1 can not be made a Block node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_53;
return ( (NODEPTR) _currn);
}/* Mkrule_53 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_54 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_54 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_54 _currn;
#ifdef __cplusplus
_currn = new _TPrule_54;
#else
_currn = (_TPPrule_54) TreeNodeAlloc (sizeof (struct _TPrule_54));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_54;
_currn->_desc1 = (_TSPBlock) MkBlock (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_54: root of subtree no. 1 can not be made a Block node ", 0, _coordref);
_currn->_desc2 = (_TSPBlock) MkBlock (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_54: root of subtree no. 2 can not be made a Block node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_54;
return ( (NODEPTR) _currn);
}/* Mkrule_54 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_55 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_55 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_55 _currn;
#ifdef __cplusplus
_currn = new _TPrule_55;
#else
_currn = (_TPPrule_55) TreeNodeAlloc (sizeof (struct _TPrule_55));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_55;
_currn->_desc1 = (_TSPBlock) MkBlock (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_55: root of subtree no. 1 can not be made a Block node ", 0, _coordref);
_currn->_desc2 = (_TSPBlock) MkBlock (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_55: root of subtree no. 2 can not be made a Block node ", 0, _coordref);
_currn->_desc3 = (_TSPBlock) MkBlock (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_55: root of subtree no. 3 can not be made a Block node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_55;
return ( (NODEPTR) _currn);
}/* Mkrule_55 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_56 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_56 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_56 _currn;
#ifdef __cplusplus
_currn = new _TPrule_56;
#else
_currn = (_TPPrule_56) TreeNodeAlloc (sizeof (struct _TPrule_56));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_56;
_currn->_desc1 = (_TSPThread) MkThread (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_56: root of subtree no. 1 can not be made a Thread node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_56;
return ( (NODEPTR) _currn);
}/* Mkrule_56 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_57 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_57 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_57 _currn;
#ifdef __cplusplus
_currn = new _TPrule_57;
#else
_currn = (_TPPrule_57) TreeNodeAlloc (sizeof (struct _TPrule_57));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_57;
_currn->_desc1 = (_TSPThread) MkThread (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_57: root of subtree no. 1 can not be made a Thread node ", 0, _coordref);
_currn->_desc2 = (_TSPThread) MkThread (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_57: root of subtree no. 2 can not be made a Thread node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_57;
return ( (NODEPTR) _currn);
}/* Mkrule_57 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_58 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_58 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_58 _currn;
#ifdef __cplusplus
_currn = new _TPrule_58;
#else
_currn = (_TPPrule_58) TreeNodeAlloc (sizeof (struct _TPrule_58));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_58;
_currn->_desc1 = (_TSPThread) MkThread (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_58: root of subtree no. 1 can not be made a Thread node ", 0, _coordref);
_currn->_desc2 = (_TSPThread) MkThread (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_58: root of subtree no. 2 can not be made a Thread node ", 0, _coordref);
_currn->_desc3 = (_TSPThread) MkThread (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_58: root of subtree no. 3 can not be made a Thread node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_58;
return ( (NODEPTR) _currn);
}/* Mkrule_58 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_59 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_59 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_59 _currn;
#ifdef __cplusplus
_currn = new _TPrule_59;
#else
_currn = (_TPPrule_59) TreeNodeAlloc (sizeof (struct _TPrule_59));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_59;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_59: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_59;
return ( (NODEPTR) _currn);
}/* Mkrule_59 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_60 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_60 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_60 _currn;
#ifdef __cplusplus
_currn = new _TPrule_60;
#else
_currn = (_TPPrule_60) TreeNodeAlloc (sizeof (struct _TPrule_60));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_60;
_SETCOORD(_currn)
_TERMACT_rule_60;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_60 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_61 (POSITION *_coordref)
#else
NODEPTR Mkrule_61 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_61 _currn;
#ifdef __cplusplus
_currn = new _TPrule_61;
#else
_currn = (_TPPrule_61) TreeNodeAlloc (sizeof (struct _TPrule_61));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_61;
_SETCOORD(_currn)
_TERMACT_rule_61;
return ( (NODEPTR) _currn);
}/* Mkrule_61 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_62 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_62 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_62 _currn;
#ifdef __cplusplus
_currn = new _TPrule_62;
#else
_currn = (_TPPrule_62) TreeNodeAlloc (sizeof (struct _TPrule_62));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_62;
_currn->_desc1 = (_TSPSharedDim) MkSharedDim (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_62: root of subtree no. 1 can not be made a SharedDim node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_62;
return ( (NODEPTR) _currn);
}/* Mkrule_62 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_63 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_63 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_63 _currn;
#ifdef __cplusplus
_currn = new _TPrule_63;
#else
_currn = (_TPPrule_63) TreeNodeAlloc (sizeof (struct _TPrule_63));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_63;
_currn->_desc1 = (_TSPSharedDim) MkSharedDim (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_63: root of subtree no. 1 can not be made a SharedDim node ", 0, _coordref);
_currn->_desc2 = (_TSPSharedDim) MkSharedDim (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_63: root of subtree no. 2 can not be made a SharedDim node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_63;
return ( (NODEPTR) _currn);
}/* Mkrule_63 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_64 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_64 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_64 _currn;
#ifdef __cplusplus
_currn = new _TPrule_64;
#else
_currn = (_TPPrule_64) TreeNodeAlloc (sizeof (struct _TPrule_64));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_64;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_64: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_64;
return ( (NODEPTR) _currn);
}/* Mkrule_64 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_65 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_65 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_65 _currn;
#ifdef __cplusplus
_currn = new _TPrule_65;
#else
_currn = (_TPPrule_65) TreeNodeAlloc (sizeof (struct _TPrule_65));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_65;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_65: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_currn->_desc2 = (_TSPResidentName) MkResidentName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_65: root of subtree no. 2 can not be made a ResidentName node ", 0, _coordref);
_currn->_desc3 = (_TSPOptionalCondition) MkOptionalCondition (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_65: root of subtree no. 3 can not be made a OptionalCondition node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_65;
return ( (NODEPTR) _currn);
}/* Mkrule_65 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_66 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_66 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_66 _currn;
#ifdef __cplusplus
_currn = new _TPrule_66;
#else
_currn = (_TPPrule_66) TreeNodeAlloc (sizeof (struct _TPrule_66));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_66;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_66: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_66;
return ( (NODEPTR) _currn);
}/* Mkrule_66 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_67 (POSITION *_coordref)
#else
NODEPTR Mkrule_67 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_67 _currn;
#ifdef __cplusplus
_currn = new _TPrule_67;
#else
_currn = (_TPPrule_67) TreeNodeAlloc (sizeof (struct _TPrule_67));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_67;
_SETCOORD(_currn)
_TERMACT_rule_67;
return ( (NODEPTR) _currn);
}/* Mkrule_67 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_68 (POSITION *_coordref)
#else
NODEPTR Mkrule_68 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_68 _currn;
#ifdef __cplusplus
_currn = new _TPrule_68;
#else
_currn = (_TPPrule_68) TreeNodeAlloc (sizeof (struct _TPrule_68));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_68;
_SETCOORD(_currn)
_TERMACT_rule_68;
return ( (NODEPTR) _currn);
}/* Mkrule_68 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_69 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_69 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_69 _currn;
#ifdef __cplusplus
_currn = new _TPrule_69;
#else
_currn = (_TPPrule_69) TreeNodeAlloc (sizeof (struct _TPrule_69));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_69;
_SETCOORD(_currn)
_TERMACT_rule_69;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_69 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_70 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_70 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_70 _currn;
#ifdef __cplusplus
_currn = new _TPrule_70;
#else
_currn = (_TPPrule_70) TreeNodeAlloc (sizeof (struct _TPrule_70));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_70;
_currn->_desc1 = (_TSPDemoteDim) MkDemoteDim (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_70: root of subtree no. 1 can not be made a DemoteDim node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_70;
return ( (NODEPTR) _currn);
}/* Mkrule_70 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_71 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_71 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_71 _currn;
#ifdef __cplusplus
_currn = new _TPrule_71;
#else
_currn = (_TPPrule_71) TreeNodeAlloc (sizeof (struct _TPrule_71));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_71;
_currn->_desc1 = (_TSPDemoteDim) MkDemoteDim (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_71: root of subtree no. 1 can not be made a DemoteDim node ", 0, _coordref);
_currn->_desc2 = (_TSPDemoteDim) MkDemoteDim (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_71: root of subtree no. 2 can not be made a DemoteDim node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_71;
return ( (NODEPTR) _currn);
}/* Mkrule_71 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_72 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_72 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_72 _currn;
#ifdef __cplusplus
_currn = new _TPrule_72;
#else
_currn = (_TPPrule_72) TreeNodeAlloc (sizeof (struct _TPrule_72));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_72;
_currn->_desc1 = (_TSPDemoteDims) MkDemoteDims (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_72: root of subtree no. 1 can not be made a DemoteDims node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_72;
return ( (NODEPTR) _currn);
}/* Mkrule_72 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_73 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_73 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_73 _currn;
#ifdef __cplusplus
_currn = new _TPrule_73;
#else
_currn = (_TPPrule_73) TreeNodeAlloc (sizeof (struct _TPrule_73));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_73;
_currn->_desc1 = (_TSPParams) MkParams (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_73: root of subtree no. 1 can not be made a Params node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_73;
return ( (NODEPTR) _currn);
}/* Mkrule_73 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_74 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_74 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_74 _currn;
#ifdef __cplusplus
_currn = new _TPrule_74;
#else
_currn = (_TPPrule_74) TreeNodeAlloc (sizeof (struct _TPrule_74));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_74;
_currn->_desc1 = (_TSPParams) MkParams (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_74: root of subtree no. 1 can not be made a Params node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_74;
return ( (NODEPTR) _currn);
}/* Mkrule_74 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_75 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_75 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_75 _currn;
#ifdef __cplusplus
_currn = new _TPrule_75;
#else
_currn = (_TPPrule_75) TreeNodeAlloc (sizeof (struct _TPrule_75));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_75;
_currn->_desc1 = (_TSPPromoteVar) MkPromoteVar (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_75: root of subtree no. 1 can not be made a PromoteVar node ", 0, _coordref);
_currn->_desc2 = (_TSPPromoteLB) MkPromoteLB (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_75: root of subtree no. 2 can not be made a PromoteLB node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_75;
return ( (NODEPTR) _currn);
}/* Mkrule_75 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_76 (POSITION *_coordref)
#else
NODEPTR Mkrule_76 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_76 _currn;
#ifdef __cplusplus
_currn = new _TPrule_76;
#else
_currn = (_TPPrule_76) TreeNodeAlloc (sizeof (struct _TPrule_76));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_76;
_SETCOORD(_currn)
_TERMACT_rule_76;
return ( (NODEPTR) _currn);
}/* Mkrule_76 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_77 (POSITION *_coordref)
#else
NODEPTR Mkrule_77 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_77 _currn;
#ifdef __cplusplus
_currn = new _TPrule_77;
#else
_currn = (_TPPrule_77) TreeNodeAlloc (sizeof (struct _TPrule_77));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_77;
_SETCOORD(_currn)
_TERMACT_rule_77;
return ( (NODEPTR) _currn);
}/* Mkrule_77 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_78 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_78 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_78 _currn;
#ifdef __cplusplus
_currn = new _TPrule_78;
#else
_currn = (_TPPrule_78) TreeNodeAlloc (sizeof (struct _TPrule_78));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_78;
_SETCOORD(_currn)
_TERMACT_rule_78;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_78 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_79 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_79 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_79 _currn;
#ifdef __cplusplus
_currn = new _TPrule_79;
#else
_currn = (_TPPrule_79) TreeNodeAlloc (sizeof (struct _TPrule_79));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_79;
_currn->_desc1 = (_TSPPromoteDim) MkPromoteDim (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_79: root of subtree no. 1 can not be made a PromoteDim node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_79;
return ( (NODEPTR) _currn);
}/* Mkrule_79 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_80 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_80 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_80 _currn;
#ifdef __cplusplus
_currn = new _TPrule_80;
#else
_currn = (_TPPrule_80) TreeNodeAlloc (sizeof (struct _TPrule_80));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_80;
_currn->_desc1 = (_TSPPromoteDim) MkPromoteDim (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_80: root of subtree no. 1 can not be made a PromoteDim node ", 0, _coordref);
_currn->_desc2 = (_TSPPromoteDim) MkPromoteDim (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_80: root of subtree no. 2 can not be made a PromoteDim node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_80;
return ( (NODEPTR) _currn);
}/* Mkrule_80 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_81 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_81 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_81 _currn;
#ifdef __cplusplus
_currn = new _TPrule_81;
#else
_currn = (_TPPrule_81) TreeNodeAlloc (sizeof (struct _TPrule_81));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_81;
_currn->_desc1 = (_TSPPromoteDims) MkPromoteDims (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_81: root of subtree no. 1 can not be made a PromoteDims node ", 0, _coordref);
_currn->_desc2 = (_TSPPromoteType) MkPromoteType (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_81: root of subtree no. 2 can not be made a PromoteType node ", 0, _coordref);
_currn->_desc3 = (_TSPPromoteExpr) MkPromoteExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_81: root of subtree no. 3 can not be made a PromoteExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_81;
return ( (NODEPTR) _currn);
}/* Mkrule_81 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_82 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_82 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_82 _currn;
#ifdef __cplusplus
_currn = new _TPrule_82;
#else
_currn = (_TPPrule_82) TreeNodeAlloc (sizeof (struct _TPrule_82));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_82;
_currn->_desc1 = (_TSPGPUVariables) MkGPUVariables (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_82: root of subtree no. 1 can not be made a GPUVariables node ", 0, _coordref);
_currn->_desc2 = (_TSPDataUsageType) MkDataUsageType (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_82: root of subtree no. 2 can not be made a DataUsageType node ", 0, _coordref);
_currn->_desc3 = (_TSPDataUsageScope) MkDataUsageScope (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_82: root of subtree no. 3 can not be made a DataUsageScope node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_82;
return ( (NODEPTR) _currn);
}/* Mkrule_82 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_83 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_83 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_83 _currn;
#ifdef __cplusplus
_currn = new _TPrule_83;
#else
_currn = (_TPPrule_83) TreeNodeAlloc (sizeof (struct _TPrule_83));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_83;
_currn->_desc1 = (_TSPParam) MkParam (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_83: root of subtree no. 1 can not be made a Param node ", 0, _coordref);
_currn->_desc2 = (_TSPCondOp) MkCondOp (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_83: root of subtree no. 2 can not be made a CondOp node ", 0, _coordref);
_currn->_desc3 = (_TSPParamOpt) MkParamOpt (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_83: root of subtree no. 3 can not be made a ParamOpt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_83;
return ( (NODEPTR) _currn);
}/* Mkrule_83 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_84 (POSITION *_coordref)
#else
NODEPTR Mkrule_84 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_84 _currn;
#ifdef __cplusplus
_currn = new _TPrule_84;
#else
_currn = (_TPPrule_84) TreeNodeAlloc (sizeof (struct _TPrule_84));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_84;
_SETCOORD(_currn)
_TERMACT_rule_84;
return ( (NODEPTR) _currn);
}/* Mkrule_84 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_85 (POSITION *_coordref)
#else
NODEPTR Mkrule_85 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_85 _currn;
#ifdef __cplusplus
_currn = new _TPrule_85;
#else
_currn = (_TPPrule_85) TreeNodeAlloc (sizeof (struct _TPrule_85));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_85;
_SETCOORD(_currn)
_TERMACT_rule_85;
return ( (NODEPTR) _currn);
}/* Mkrule_85 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_86 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_86 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_86 _currn;
#ifdef __cplusplus
_currn = new _TPrule_86;
#else
_currn = (_TPPrule_86) TreeNodeAlloc (sizeof (struct _TPrule_86));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_86;
_currn->_desc1 = (_TSPSharedDecl) MkSharedDecl (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_86: root of subtree no. 1 can not be made a SharedDecl node ", 0, _coordref);
_currn->_desc2 = (_TSPDataOption) MkDataOption (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_86: root of subtree no. 2 can not be made a DataOption node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_86;
return ( (NODEPTR) _currn);
}/* Mkrule_86 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_87 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_87 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_87 _currn;
#ifdef __cplusplus
_currn = new _TPrule_87;
#else
_currn = (_TPPrule_87) TreeNodeAlloc (sizeof (struct _TPrule_87));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_87;
_currn->_desc1 = (_TSPDataOption) MkDataOption (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_87: root of subtree no. 1 can not be made a DataOption node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_87;
return ( (NODEPTR) _currn);
}/* Mkrule_87 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_88 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_88 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_88 _currn;
#ifdef __cplusplus
_currn = new _TPrule_88;
#else
_currn = (_TPPrule_88) TreeNodeAlloc (sizeof (struct _TPrule_88));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_88;
_currn->_desc1 = (_TSPDataOption) MkDataOption (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_88: root of subtree no. 1 can not be made a DataOption node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_88;
return ( (NODEPTR) _currn);
}/* Mkrule_88 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_89 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_89 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_89 _currn;
#ifdef __cplusplus
_currn = new _TPrule_89;
#else
_currn = (_TPPrule_89) TreeNodeAlloc (sizeof (struct _TPrule_89));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_89;
_currn->_desc1 = (_TSPDataOption) MkDataOption (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_89: root of subtree no. 1 can not be made a DataOption node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_89;
return ( (NODEPTR) _currn);
}/* Mkrule_89 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_90 (POSITION *_coordref)
#else
NODEPTR Mkrule_90 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_90 _currn;
#ifdef __cplusplus
_currn = new _TPrule_90;
#else
_currn = (_TPPrule_90) TreeNodeAlloc (sizeof (struct _TPrule_90));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_90;
_SETCOORD(_currn)
_TERMACT_rule_90;
return ( (NODEPTR) _currn);
}/* Mkrule_90 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_91 (POSITION *_coordref)
#else
NODEPTR Mkrule_91 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_91 _currn;
#ifdef __cplusplus
_currn = new _TPrule_91;
#else
_currn = (_TPPrule_91) TreeNodeAlloc (sizeof (struct _TPrule_91));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_91;
_SETCOORD(_currn)
_TERMACT_rule_91;
return ( (NODEPTR) _currn);
}/* Mkrule_91 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_92 (POSITION *_coordref)
#else
NODEPTR Mkrule_92 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_92 _currn;
#ifdef __cplusplus
_currn = new _TPrule_92;
#else
_currn = (_TPPrule_92) TreeNodeAlloc (sizeof (struct _TPrule_92));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_92;
_SETCOORD(_currn)
_TERMACT_rule_92;
return ( (NODEPTR) _currn);
}/* Mkrule_92 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_93 (POSITION *_coordref)
#else
NODEPTR Mkrule_93 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_93 _currn;
#ifdef __cplusplus
_currn = new _TPrule_93;
#else
_currn = (_TPPrule_93) TreeNodeAlloc (sizeof (struct _TPrule_93));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_93;
_SETCOORD(_currn)
_TERMACT_rule_93;
return ( (NODEPTR) _currn);
}/* Mkrule_93 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_94 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_94 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_94 _currn;
#ifdef __cplusplus
_currn = new _TPrule_94;
#else
_currn = (_TPPrule_94) TreeNodeAlloc (sizeof (struct _TPrule_94));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_94;
_currn->_desc1 = (_TSPTranslationType) MkTranslationType (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_94: root of subtree no. 1 can not be made a TranslationType node ", 0, _coordref);
_currn->_desc2 = (_TSPOptionalArgs) MkOptionalArgs (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_94: root of subtree no. 2 can not be made a OptionalArgs node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_94;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_94 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_95 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_95 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_95 _currn;
#ifdef __cplusplus
_currn = new _TPrule_95;
#else
_currn = (_TPPrule_95) TreeNodeAlloc (sizeof (struct _TPrule_95));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_95;
_currn->_desc1 = (_TSPDataUsages) MkDataUsages (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_95: root of subtree no. 1 can not be made a DataUsages node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_95;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_95 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_96 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_96 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_96 _currn;
#ifdef __cplusplus
_currn = new _TPrule_96;
#else
_currn = (_TPPrule_96) TreeNodeAlloc (sizeof (struct _TPrule_96));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_96;
_currn->_desc1 = (_TSPAccDoTypes) MkAccDoTypes (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_96: root of subtree no. 1 can not be made a AccDoTypes node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_96;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_96 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_97 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_97 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_97 _currn;
#ifdef __cplusplus
_currn = new _TPrule_97;
#else
_currn = (_TPPrule_97) TreeNodeAlloc (sizeof (struct _TPrule_97));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_97;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_97: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_97;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_97 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_98 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_98 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_98 _currn;
#ifdef __cplusplus
_currn = new _TPrule_98;
#else
_currn = (_TPPrule_98) TreeNodeAlloc (sizeof (struct _TPrule_98));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_98;
_SETCOORD(_currn)
_TERMACT_rule_98;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_98 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_99 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_99 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_99 _currn;
#ifdef __cplusplus
_currn = new _TPrule_99;
#else
_currn = (_TPPrule_99) TreeNodeAlloc (sizeof (struct _TPrule_99));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_99;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_99: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxAccessSpec) MkxAccessSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_99: root of subtree no. 2 can not be made a xAccessSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPxTypeName) MkxTypeName (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_99: root of subtree no. 3 can not be made a xTypeName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_99;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_99 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_100 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_100 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_100 _currn;
#ifdef __cplusplus
_currn = new _TPrule_100;
#else
_currn = (_TPPrule_100) TreeNodeAlloc (sizeof (struct _TPrule_100));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_100;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_100: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxTypeName) MkxTypeName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_100: root of subtree no. 2 can not be made a xTypeName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_100;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_100 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_101 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_101 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_101 _currn;
#ifdef __cplusplus
_currn = new _TPrule_101;
#else
_currn = (_TPPrule_101) TreeNodeAlloc (sizeof (struct _TPrule_101));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_101;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_101: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxTypeName) MkxTypeName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_101: root of subtree no. 2 can not be made a xTypeName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_101;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_101 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_102 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_102 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_102 _currn;
#ifdef __cplusplus
_currn = new _TPrule_102;
#else
_currn = (_TPPrule_102) TreeNodeAlloc (sizeof (struct _TPrule_102));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_102;
_currn->_desc1 = (_TSPxAttrArraySpec) MkxAttrArraySpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_102: root of subtree no. 1 can not be made a xAttrArraySpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_102;
return ( (NODEPTR) _currn);
}/* Mkrule_102 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_103 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_103 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_103 _currn;
#ifdef __cplusplus
_currn = new _TPrule_103;
#else
_currn = (_TPPrule_103) TreeNodeAlloc (sizeof (struct _TPrule_103));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_103;
_currn->_desc1 = (_TSPxComponentName) MkxComponentName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_103: root of subtree no. 1 can not be made a xComponentName node ", 0, _coordref);
_currn->_desc2 = (_TSPDimensionDeclarators) MkDimensionDeclarators (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_103: root of subtree no. 2 can not be made a DimensionDeclarators node ", 0, _coordref);
_currn->_desc3 = (_TSPxComponentInitialization) MkxComponentInitialization (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_103: root of subtree no. 3 can not be made a xComponentInitialization node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_103;
return ( (NODEPTR) _currn);
}/* Mkrule_103 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_104 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4)
#else
NODEPTR Mkrule_104 (_coordref,_desc1,_desc2,_desc3,_desc4)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
#endif
{	_TPPrule_104 _currn;
#ifdef __cplusplus
_currn = new _TPrule_104;
#else
_currn = (_TPPrule_104) TreeNodeAlloc (sizeof (struct _TPrule_104));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_104;
_currn->_desc1 = (_TSPxComponentName) MkxComponentName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_104: root of subtree no. 1 can not be made a xComponentName node ", 0, _coordref);
_currn->_desc2 = (_TSPDimensionDeclarators) MkDimensionDeclarators (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_104: root of subtree no. 2 can not be made a DimensionDeclarators node ", 0, _coordref);
_currn->_desc3 = (_TSPxCharLength) MkxCharLength (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_104: root of subtree no. 3 can not be made a xCharLength node ", 0, _coordref);
_currn->_desc4 = (_TSPxComponentInitialization) MkxComponentInitialization (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_104: root of subtree no. 4 can not be made a xComponentInitialization node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_104;
return ( (NODEPTR) _currn);
}/* Mkrule_104 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_105 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_105 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_105 _currn;
#ifdef __cplusplus
_currn = new _TPrule_105;
#else
_currn = (_TPPrule_105) TreeNodeAlloc (sizeof (struct _TPrule_105));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_105;
_currn->_desc1 = (_TSPxPointerName) MkxPointerName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_105: root of subtree no. 1 can not be made a xPointerName node ", 0, _coordref);
_currn->_desc2 = (_TSPDimensionDeclarators) MkDimensionDeclarators (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_105: root of subtree no. 2 can not be made a DimensionDeclarators node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_105;
return ( (NODEPTR) _currn);
}/* Mkrule_105 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_106 (POSITION *_coordref)
#else
NODEPTR Mkrule_106 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_106 _currn;
#ifdef __cplusplus
_currn = new _TPrule_106;
#else
_currn = (_TPPrule_106) TreeNodeAlloc (sizeof (struct _TPrule_106));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_106;
_SETCOORD(_currn)
_TERMACT_rule_106;
return ( (NODEPTR) _currn);
}/* Mkrule_106 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_107 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_107 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_107 _currn;
#ifdef __cplusplus
_currn = new _TPrule_107;
#else
_currn = (_TPPrule_107) TreeNodeAlloc (sizeof (struct _TPrule_107));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_107;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_107: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndWhereStmt) MkxEndWhereStmt (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_107: root of subtree no. 2 can not be made a xEndWhereStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_107;
return ( (NODEPTR) _currn);
}/* Mkrule_107 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_108 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_108 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_108 _currn;
#ifdef __cplusplus
_currn = new _TPrule_108;
#else
_currn = (_TPPrule_108) TreeNodeAlloc (sizeof (struct _TPrule_108));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_108;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_108: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxBody) MkxBody (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_108: root of subtree no. 2 can not be made a xBody node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_108;
return ( (NODEPTR) _currn);
}/* Mkrule_108 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_109 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_109 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_109 _currn;
#ifdef __cplusplus
_currn = new _TPrule_109;
#else
_currn = (_TPPrule_109) TreeNodeAlloc (sizeof (struct _TPrule_109));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_109;
_currn->_desc1 = (_TSPxEndWhereStmt) MkxEndWhereStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_109: root of subtree no. 1 can not be made a xEndWhereStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_109;
return ( (NODEPTR) _currn);
}/* Mkrule_109 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_110 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_110 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_110 _currn;
#ifdef __cplusplus
_currn = new _TPrule_110;
#else
_currn = (_TPPrule_110) TreeNodeAlloc (sizeof (struct _TPrule_110));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_110;
_currn->_desc1 = (_TSPxStmt) MkxStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_110: root of subtree no. 1 can not be made a xStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxBody) MkxBody (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_110: root of subtree no. 2 can not be made a xBody node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_110;
return ( (NODEPTR) _currn);
}/* Mkrule_110 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_111 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_111 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_111 _currn;
#ifdef __cplusplus
_currn = new _TPrule_111;
#else
_currn = (_TPPrule_111) TreeNodeAlloc (sizeof (struct _TPrule_111));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_111;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_111: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxWhereBodyConstruct) MkxWhereBodyConstruct (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_111: root of subtree no. 2 can not be made a xWhereBodyConstruct node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_111;
return ( (NODEPTR) _currn);
}/* Mkrule_111 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_112 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_112 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_112 _currn;
#ifdef __cplusplus
_currn = new _TPrule_112;
#else
_currn = (_TPPrule_112) TreeNodeAlloc (sizeof (struct _TPrule_112));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_112;
_currn->_desc1 = (_TSPxWhereBodyConstruct) MkxWhereBodyConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_112: root of subtree no. 1 can not be made a xWhereBodyConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_112;
return ( (NODEPTR) _currn);
}/* Mkrule_112 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_113 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_113 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_113 _currn;
#ifdef __cplusplus
_currn = new _TPrule_113;
#else
_currn = (_TPPrule_113) TreeNodeAlloc (sizeof (struct _TPrule_113));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_113;
_currn->_desc1 = (_TSPxWhereConstruct) MkxWhereConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_113: root of subtree no. 1 can not be made a xWhereConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_113;
return ( (NODEPTR) _currn);
}/* Mkrule_113 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_114 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_114 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_114 _currn;
#ifdef __cplusplus
_currn = new _TPrule_114;
#else
_currn = (_TPPrule_114) TreeNodeAlloc (sizeof (struct _TPrule_114));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_114;
_currn->_desc1 = (_TSPxStmt) MkxStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_114: root of subtree no. 1 can not be made a xStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_114;
return ( (NODEPTR) _currn);
}/* Mkrule_114 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_115 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_115 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_115 _currn;
#ifdef __cplusplus
_currn = new _TPrule_115;
#else
_currn = (_TPPrule_115) TreeNodeAlloc (sizeof (struct _TPrule_115));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_115;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_115: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_115;
return ( (NODEPTR) _currn);
}/* Mkrule_115 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_116 (POSITION *_coordref)
#else
NODEPTR Mkrule_116 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_116 _currn;
#ifdef __cplusplus
_currn = new _TPrule_116;
#else
_currn = (_TPPrule_116) TreeNodeAlloc (sizeof (struct _TPrule_116));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_116;
_SETCOORD(_currn)
_TERMACT_rule_116;
return ( (NODEPTR) _currn);
}/* Mkrule_116 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_117 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_117 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_117 _currn;
#ifdef __cplusplus
_currn = new _TPrule_117;
#else
_currn = (_TPPrule_117) TreeNodeAlloc (sizeof (struct _TPrule_117));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_117;
_SETCOORD(_currn)
_TERMACT_rule_117;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_117 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_118 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_118 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_118 _currn;
#ifdef __cplusplus
_currn = new _TPrule_118;
#else
_currn = (_TPPrule_118) TreeNodeAlloc (sizeof (struct _TPrule_118));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_118;
_currn->_desc1 = (_TSPxEndIfStmt) MkxEndIfStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_118: root of subtree no. 1 can not be made a xEndIfStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_118;
return ( (NODEPTR) _currn);
}/* Mkrule_118 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_119 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_119 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_119 _currn;
#ifdef __cplusplus
_currn = new _TPrule_119;
#else
_currn = (_TPPrule_119) TreeNodeAlloc (sizeof (struct _TPrule_119));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_119;
_currn->_desc1 = (_TSPxElseIfConstruct) MkxElseIfConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_119: root of subtree no. 1 can not be made a xElseIfConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_119;
return ( (NODEPTR) _currn);
}/* Mkrule_119 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_120 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_120 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_120 _currn;
#ifdef __cplusplus
_currn = new _TPrule_120;
#else
_currn = (_TPPrule_120) TreeNodeAlloc (sizeof (struct _TPrule_120));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_120;
_currn->_desc1 = (_TSPxElseConstruct) MkxElseConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_120: root of subtree no. 1 can not be made a xElseConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_120;
return ( (NODEPTR) _currn);
}/* Mkrule_120 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_121 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_121 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_121 _currn;
#ifdef __cplusplus
_currn = new _TPrule_121;
#else
_currn = (_TPPrule_121) TreeNodeAlloc (sizeof (struct _TPrule_121));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_121;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_121: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndIfStmt) MkxEndIfStmt (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_121: root of subtree no. 2 can not be made a xEndIfStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_121;
return ( (NODEPTR) _currn);
}/* Mkrule_121 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_122 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_122 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_122 _currn;
#ifdef __cplusplus
_currn = new _TPrule_122;
#else
_currn = (_TPPrule_122) TreeNodeAlloc (sizeof (struct _TPrule_122));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_122;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_122: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxElseIfConstruct) MkxElseIfConstruct (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_122: root of subtree no. 2 can not be made a xElseIfConstruct node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_122;
return ( (NODEPTR) _currn);
}/* Mkrule_122 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_123 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_123 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_123 _currn;
#ifdef __cplusplus
_currn = new _TPrule_123;
#else
_currn = (_TPPrule_123) TreeNodeAlloc (sizeof (struct _TPrule_123));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_123;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_123: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxElseConstruct) MkxElseConstruct (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_123: root of subtree no. 2 can not be made a xElseConstruct node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_123;
return ( (NODEPTR) _currn);
}/* Mkrule_123 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_124 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_124 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_124 _currn;
#ifdef __cplusplus
_currn = new _TPrule_124;
#else
_currn = (_TPPrule_124) TreeNodeAlloc (sizeof (struct _TPrule_124));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_124;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_124: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxTargetObjectList) MkxTargetObjectList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_124: root of subtree no. 2 can not be made a xTargetObjectList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_124;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_124 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_125 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_125 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_125 _currn;
#ifdef __cplusplus
_currn = new _TPrule_125;
#else
_currn = (_TPPrule_125) TreeNodeAlloc (sizeof (struct _TPrule_125));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_125;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_125: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxTargetObjectList) MkxTargetObjectList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_125: root of subtree no. 2 can not be made a xTargetObjectList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_125;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_125 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_126 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_126 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_126 _currn;
#ifdef __cplusplus
_currn = new _TPrule_126;
#else
_currn = (_TPPrule_126) TreeNodeAlloc (sizeof (struct _TPrule_126));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_126;
_currn->_desc1 = (_TSPxTargetObjectList) MkxTargetObjectList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_126: root of subtree no. 1 can not be made a xTargetObjectList node ", 0, _coordref);
_currn->_desc2 = (_TSPxTargetObject) MkxTargetObject (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_126: root of subtree no. 2 can not be made a xTargetObject node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_126;
return ( (NODEPTR) _currn);
}/* Mkrule_126 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_127 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_127 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_127 _currn;
#ifdef __cplusplus
_currn = new _TPrule_127;
#else
_currn = (_TPPrule_127) TreeNodeAlloc (sizeof (struct _TPrule_127));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_127;
_currn->_desc1 = (_TSPxTargetObject) MkxTargetObject (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_127: root of subtree no. 1 can not be made a xTargetObject node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_127;
return ( (NODEPTR) _currn);
}/* Mkrule_127 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_128 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_128 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_128 _currn;
#ifdef __cplusplus
_currn = new _TPrule_128;
#else
_currn = (_TPPrule_128) TreeNodeAlloc (sizeof (struct _TPrule_128));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_128;
_currn->_desc1 = (_TSPxTargetName) MkxTargetName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_128: root of subtree no. 1 can not be made a xTargetName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_128;
return ( (NODEPTR) _currn);
}/* Mkrule_128 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_129 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_129 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_129 _currn;
#ifdef __cplusplus
_currn = new _TPrule_129;
#else
_currn = (_TPPrule_129) TreeNodeAlloc (sizeof (struct _TPrule_129));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_129;
_currn->_desc1 = (_TSPxTargetName) MkxTargetName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_129: root of subtree no. 1 can not be made a xTargetName node ", 0, _coordref);
_currn->_desc2 = (_TSPxArraySpec) MkxArraySpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_129: root of subtree no. 2 can not be made a xArraySpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_129;
return ( (NODEPTR) _currn);
}/* Mkrule_129 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_130 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_130 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_130 _currn;
#ifdef __cplusplus
_currn = new _TPrule_130;
#else
_currn = (_TPPrule_130) TreeNodeAlloc (sizeof (struct _TPrule_130));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_130;
_SETCOORD(_currn)
_TERMACT_rule_130;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_130 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_131 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_131 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_131 _currn;
#ifdef __cplusplus
_currn = new _TPrule_131;
#else
_currn = (_TPPrule_131) TreeNodeAlloc (sizeof (struct _TPrule_131));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_131;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_131: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_131;
return ( (NODEPTR) _currn);
}/* Mkrule_131 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_132 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_132 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_132 _currn;
#ifdef __cplusplus
_currn = new _TPrule_132;
#else
_currn = (_TPPrule_132) TreeNodeAlloc (sizeof (struct _TPrule_132));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_132;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_132: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_132: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_132: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_132;
return ( (NODEPTR) _currn);
}/* Mkrule_132 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_133 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_133 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_133 _currn;
#ifdef __cplusplus
_currn = new _TPrule_133;
#else
_currn = (_TPPrule_133) TreeNodeAlloc (sizeof (struct _TPrule_133));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_133;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_133: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_133: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_133;
return ( (NODEPTR) _currn);
}/* Mkrule_133 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_134 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_134 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_134 _currn;
#ifdef __cplusplus
_currn = new _TPrule_134;
#else
_currn = (_TPPrule_134) TreeNodeAlloc (sizeof (struct _TPrule_134));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_134;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_134: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_134;
return ( (NODEPTR) _currn);
}/* Mkrule_134 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_135 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_135 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_135 _currn;
#ifdef __cplusplus
_currn = new _TPrule_135;
#else
_currn = (_TPPrule_135) TreeNodeAlloc (sizeof (struct _TPrule_135));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_135;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_135: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_135: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_135;
return ( (NODEPTR) _currn);
}/* Mkrule_135 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_136 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_136 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_136 _currn;
#ifdef __cplusplus
_currn = new _TPrule_136;
#else
_currn = (_TPPrule_136) TreeNodeAlloc (sizeof (struct _TPrule_136));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_136;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_136: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_136;
return ( (NODEPTR) _currn);
}/* Mkrule_136 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_137 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_137 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_137 _currn;
#ifdef __cplusplus
_currn = new _TPrule_137;
#else
_currn = (_TPPrule_137) TreeNodeAlloc (sizeof (struct _TPrule_137));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_137;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_137: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_137;
return ( (NODEPTR) _currn);
}/* Mkrule_137 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_138 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_138 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_138 _currn;
#ifdef __cplusplus
_currn = new _TPrule_138;
#else
_currn = (_TPPrule_138) TreeNodeAlloc (sizeof (struct _TPrule_138));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_138;
_currn->_desc1 = (_TSPxTypeName) MkxTypeName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_138: root of subtree no. 1 can not be made a xTypeName node ", 0, _coordref);
_currn->_desc2 = (_TSPxExprList) MkxExprList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_138: root of subtree no. 2 can not be made a xExprList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_138;
return ( (NODEPTR) _currn);
}/* Mkrule_138 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_139 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_139 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_139 _currn;
#ifdef __cplusplus
_currn = new _TPrule_139;
#else
_currn = (_TPPrule_139) TreeNodeAlloc (sizeof (struct _TPrule_139));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_139;
_currn->_desc1 = (_TSPxExecutableProgram) MkxExecutableProgram (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_139: root of subtree no. 1 can not be made a xExecutableProgram node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_139;
return ( (NODEPTR) _currn);
}/* Mkrule_139 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_140 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_140 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_140 _currn;
#ifdef __cplusplus
_currn = new _TPrule_140;
#else
_currn = (_TPPrule_140) TreeNodeAlloc (sizeof (struct _TPrule_140));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_140;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_140: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndSelectStmt) MkxEndSelectStmt (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_140: root of subtree no. 2 can not be made a xEndSelectStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_140;
return ( (NODEPTR) _currn);
}/* Mkrule_140 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_141 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_141 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_141 _currn;
#ifdef __cplusplus
_currn = new _TPrule_141;
#else
_currn = (_TPPrule_141) TreeNodeAlloc (sizeof (struct _TPrule_141));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_141;
_currn->_desc1 = (_TSPxEndSelectStmt) MkxEndSelectStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_141: root of subtree no. 1 can not be made a xEndSelectStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_141;
return ( (NODEPTR) _currn);
}/* Mkrule_141 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_142 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_142 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_142 _currn;
#ifdef __cplusplus
_currn = new _TPrule_142;
#else
_currn = (_TPPrule_142) TreeNodeAlloc (sizeof (struct _TPrule_142));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_142;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_142: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxCaseBodyConstruct) MkxCaseBodyConstruct (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_142: root of subtree no. 2 can not be made a xCaseBodyConstruct node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_142;
return ( (NODEPTR) _currn);
}/* Mkrule_142 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_143 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_143 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_143 _currn;
#ifdef __cplusplus
_currn = new _TPrule_143;
#else
_currn = (_TPPrule_143) TreeNodeAlloc (sizeof (struct _TPrule_143));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_143;
_currn->_desc1 = (_TSPxVariableName) MkxVariableName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_143: root of subtree no. 1 can not be made a xVariableName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_143;
return ( (NODEPTR) _currn);
}/* Mkrule_143 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_144 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_144 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_144 _currn;
#ifdef __cplusplus
_currn = new _TPrule_144;
#else
_currn = (_TPPrule_144) TreeNodeAlloc (sizeof (struct _TPrule_144));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_144;
_currn->_desc1 = (_TSPxArrayElement) MkxArrayElement (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_144: root of subtree no. 1 can not be made a xArrayElement node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_144;
return ( (NODEPTR) _currn);
}/* Mkrule_144 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_145 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_145 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_145 _currn;
#ifdef __cplusplus
_currn = new _TPrule_145;
#else
_currn = (_TPPrule_145) TreeNodeAlloc (sizeof (struct _TPrule_145));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_145;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_145: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_145;
return ( (NODEPTR) _currn);
}/* Mkrule_145 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_146 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_146 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_146 _currn;
#ifdef __cplusplus
_currn = new _TPrule_146;
#else
_currn = (_TPPrule_146) TreeNodeAlloc (sizeof (struct _TPrule_146));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_146;
_currn->_desc1 = (_TSPxSavedEntityList) MkxSavedEntityList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_146: root of subtree no. 1 can not be made a xSavedEntityList node ", 0, _coordref);
_currn->_desc2 = (_TSPxSavedEntity) MkxSavedEntity (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_146: root of subtree no. 2 can not be made a xSavedEntity node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_146;
return ( (NODEPTR) _currn);
}/* Mkrule_146 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_147 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_147 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_147 _currn;
#ifdef __cplusplus
_currn = new _TPrule_147;
#else
_currn = (_TPPrule_147) TreeNodeAlloc (sizeof (struct _TPrule_147));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_147;
_currn->_desc1 = (_TSPxSavedEntity) MkxSavedEntity (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_147: root of subtree no. 1 can not be made a xSavedEntity node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_147;
return ( (NODEPTR) _currn);
}/* Mkrule_147 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_148 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_148 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_148 _currn;
#ifdef __cplusplus
_currn = new _TPrule_148;
#else
_currn = (_TPPrule_148) TreeNodeAlloc (sizeof (struct _TPrule_148));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_148;
_currn->_desc1 = (_TSPxVariableName) MkxVariableName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_148: root of subtree no. 1 can not be made a xVariableName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_148;
return ( (NODEPTR) _currn);
}/* Mkrule_148 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_149 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_149 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_149 _currn;
#ifdef __cplusplus
_currn = new _TPrule_149;
#else
_currn = (_TPPrule_149) TreeNodeAlloc (sizeof (struct _TPrule_149));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_149;
_currn->_desc1 = (_TSPxComblock) MkxComblock (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_149: root of subtree no. 1 can not be made a xComblock node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_149;
return ( (NODEPTR) _currn);
}/* Mkrule_149 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_150 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_150 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_150 _currn;
#ifdef __cplusplus
_currn = new _TPrule_150;
#else
_currn = (_TPPrule_150) TreeNodeAlloc (sizeof (struct _TPrule_150));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_150;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_150: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxSavedEntityList) MkxSavedEntityList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_150: root of subtree no. 2 can not be made a xSavedEntityList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_150;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_150 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_151 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_151 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_151 _currn;
#ifdef __cplusplus
_currn = new _TPrule_151;
#else
_currn = (_TPPrule_151) TreeNodeAlloc (sizeof (struct _TPrule_151));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_151;
_currn->_desc1 = (_TSPxRenameList) MkxRenameList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_151: root of subtree no. 1 can not be made a xRenameList node ", 0, _coordref);
_currn->_desc2 = (_TSPxRename) MkxRename (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_151: root of subtree no. 2 can not be made a xRename node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_151;
return ( (NODEPTR) _currn);
}/* Mkrule_151 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_152 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_152 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_152 _currn;
#ifdef __cplusplus
_currn = new _TPrule_152;
#else
_currn = (_TPPrule_152) TreeNodeAlloc (sizeof (struct _TPrule_152));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_152;
_currn->_desc1 = (_TSPxRename) MkxRename (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_152: root of subtree no. 1 can not be made a xRename node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_152;
return ( (NODEPTR) _currn);
}/* Mkrule_152 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_153 (POSITION *_coordref, int _TERM1, NODEPTR _desc1)
#else
NODEPTR Mkrule_153 (_coordref, _TERM1,_desc1)
	POSITION *_coordref;
	int _TERM1;
	NODEPTR _desc1;
#endif
{	_TPPrule_153 _currn;
#ifdef __cplusplus
_currn = new _TPrule_153;
#else
_currn = (_TPPrule_153) TreeNodeAlloc (sizeof (struct _TPrule_153));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_153;
_currn->_desc1 = (_TSPxUseName) MkxUseName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_153: root of subtree no. 1 can not be made a xUseName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_153;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_153 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_154 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_154 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_154 _currn;
#ifdef __cplusplus
_currn = new _TPrule_154;
#else
_currn = (_TPPrule_154) TreeNodeAlloc (sizeof (struct _TPrule_154));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_154;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_154: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_154;
return ( (NODEPTR) _currn);
}/* Mkrule_154 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_155 (POSITION *_coordref)
#else
NODEPTR Mkrule_155 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_155 _currn;
#ifdef __cplusplus
_currn = new _TPrule_155;
#else
_currn = (_TPPrule_155) TreeNodeAlloc (sizeof (struct _TPrule_155));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_155;
_SETCOORD(_currn)
_TERMACT_rule_155;
return ( (NODEPTR) _currn);
}/* Mkrule_155 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_156 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_156 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_156 _currn;
#ifdef __cplusplus
_currn = new _TPrule_156;
#else
_currn = (_TPPrule_156) TreeNodeAlloc (sizeof (struct _TPrule_156));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_156;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_156: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxBinOp) MkxBinOp (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_156: root of subtree no. 2 can not be made a xBinOp node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_156: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_156;
return ( (NODEPTR) _currn);
}/* Mkrule_156 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_157 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_157 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_157 _currn;
#ifdef __cplusplus
_currn = new _TPrule_157;
#else
_currn = (_TPPrule_157) TreeNodeAlloc (sizeof (struct _TPrule_157));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_157;
_currn->_desc1 = (_TSPxRdUnitId) MkxRdUnitId (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_157: root of subtree no. 1 can not be made a xRdUnitId node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_157;
return ( (NODEPTR) _currn);
}/* Mkrule_157 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_158 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_158 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_158 _currn;
#ifdef __cplusplus
_currn = new _TPrule_158;
#else
_currn = (_TPPrule_158) TreeNodeAlloc (sizeof (struct _TPrule_158));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_158;
_currn->_desc1 = (_TSPxIoControlSpecList) MkxIoControlSpecList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_158: root of subtree no. 1 can not be made a xIoControlSpecList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_158;
return ( (NODEPTR) _currn);
}/* Mkrule_158 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_159 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_159 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_159 _currn;
#ifdef __cplusplus
_currn = new _TPrule_159;
#else
_currn = (_TPPrule_159) TreeNodeAlloc (sizeof (struct _TPrule_159));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_159;
_SETCOORD(_currn)
_TERMACT_rule_159;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_159 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_160 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_160 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_160 _currn;
#ifdef __cplusplus
_currn = new _TPrule_160;
#else
_currn = (_TPPrule_160) TreeNodeAlloc (sizeof (struct _TPrule_160));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_160;
_currn->_desc1 = (_TSPxProcedureNameList) MkxProcedureNameList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_160: root of subtree no. 1 can not be made a xProcedureNameList node ", 0, _coordref);
_currn->_desc2 = (_TSPxProcedureName) MkxProcedureName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_160: root of subtree no. 2 can not be made a xProcedureName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_160;
return ( (NODEPTR) _currn);
}/* Mkrule_160 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_161 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_161 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_161 _currn;
#ifdef __cplusplus
_currn = new _TPrule_161;
#else
_currn = (_TPPrule_161) TreeNodeAlloc (sizeof (struct _TPrule_161));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_161;
_currn->_desc1 = (_TSPxProcedureName) MkxProcedureName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_161: root of subtree no. 1 can not be made a xProcedureName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_161;
return ( (NODEPTR) _currn);
}/* Mkrule_161 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_162 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_162 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_162 _currn;
#ifdef __cplusplus
_currn = new _TPrule_162;
#else
_currn = (_TPPrule_162) TreeNodeAlloc (sizeof (struct _TPrule_162));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_162;
_SETCOORD(_currn)
_TERMACT_rule_162;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_162 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_163 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_163 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_163 _currn;
#ifdef __cplusplus
_currn = new _TPrule_163;
#else
_currn = (_TPPrule_163) TreeNodeAlloc (sizeof (struct _TPrule_163));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_163;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_163: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_163;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_163 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_164 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_164 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_164 _currn;
#ifdef __cplusplus
_currn = new _TPrule_164;
#else
_currn = (_TPPrule_164) TreeNodeAlloc (sizeof (struct _TPrule_164));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_164;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_164: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_164;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_164 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_165 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_165 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_165 _currn;
#ifdef __cplusplus
_currn = new _TPrule_165;
#else
_currn = (_TPPrule_165) TreeNodeAlloc (sizeof (struct _TPrule_165));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_165;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_165: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxSubstringRange) MkxSubstringRange (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_165: root of subtree no. 2 can not be made a xSubstringRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_165;
return ( (NODEPTR) _currn);
}/* Mkrule_165 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_166 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_166 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_166 _currn;
#ifdef __cplusplus
_currn = new _TPrule_166;
#else
_currn = (_TPPrule_166) TreeNodeAlloc (sizeof (struct _TPrule_166));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_166;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_166: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxCompDataRef) MkxCompDataRef (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_166: root of subtree no. 2 can not be made a xCompDataRef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_166;
return ( (NODEPTR) _currn);
}/* Mkrule_166 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_167 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_167 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_167 _currn;
#ifdef __cplusplus
_currn = new _TPrule_167;
#else
_currn = (_TPPrule_167) TreeNodeAlloc (sizeof (struct _TPrule_167));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_167;
_currn->_desc1 = (_TSPxPointerStmtObjectList) MkxPointerStmtObjectList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_167: root of subtree no. 1 can not be made a xPointerStmtObjectList node ", 0, _coordref);
_currn->_desc2 = (_TSPxPointerStmtObject) MkxPointerStmtObject (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_167: root of subtree no. 2 can not be made a xPointerStmtObject node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_167;
return ( (NODEPTR) _currn);
}/* Mkrule_167 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_168 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_168 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_168 _currn;
#ifdef __cplusplus
_currn = new _TPrule_168;
#else
_currn = (_TPPrule_168) TreeNodeAlloc (sizeof (struct _TPrule_168));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_168;
_currn->_desc1 = (_TSPxPointerStmtObject) MkxPointerStmtObject (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_168: root of subtree no. 1 can not be made a xPointerStmtObject node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_168;
return ( (NODEPTR) _currn);
}/* Mkrule_168 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_169 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_169 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_169 _currn;
#ifdef __cplusplus
_currn = new _TPrule_169;
#else
_currn = (_TPPrule_169) TreeNodeAlloc (sizeof (struct _TPrule_169));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_169;
_currn->_desc1 = (_TSPxPointerName) MkxPointerName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_169: root of subtree no. 1 can not be made a xPointerName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_169;
return ( (NODEPTR) _currn);
}/* Mkrule_169 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_170 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_170 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_170 _currn;
#ifdef __cplusplus
_currn = new _TPrule_170;
#else
_currn = (_TPPrule_170) TreeNodeAlloc (sizeof (struct _TPrule_170));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_170;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_170: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxPointerStmtObjectList) MkxPointerStmtObjectList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_170: root of subtree no. 2 can not be made a xPointerStmtObjectList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_170;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_170 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_171 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_171 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_171 _currn;
#ifdef __cplusplus
_currn = new _TPrule_171;
#else
_currn = (_TPPrule_171) TreeNodeAlloc (sizeof (struct _TPrule_171));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_171;
_currn->_desc1 = (_TSPxPointerObjectList) MkxPointerObjectList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_171: root of subtree no. 1 can not be made a xPointerObjectList node ", 0, _coordref);
_currn->_desc2 = (_TSPxPointerObject) MkxPointerObject (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_171: root of subtree no. 2 can not be made a xPointerObject node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_171;
return ( (NODEPTR) _currn);
}/* Mkrule_171 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_172 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_172 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_172 _currn;
#ifdef __cplusplus
_currn = new _TPrule_172;
#else
_currn = (_TPPrule_172) TreeNodeAlloc (sizeof (struct _TPrule_172));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_172;
_currn->_desc1 = (_TSPxPointerObject) MkxPointerObject (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_172: root of subtree no. 1 can not be made a xPointerObject node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_172;
return ( (NODEPTR) _currn);
}/* Mkrule_172 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_173 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_173 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_173 _currn;
#ifdef __cplusplus
_currn = new _TPrule_173;
#else
_currn = (_TPPrule_173) TreeNodeAlloc (sizeof (struct _TPrule_173));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_173;
_SETCOORD(_currn)
_TERMACT_rule_173;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_173 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_174 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_174 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_174 _currn;
#ifdef __cplusplus
_currn = new _TPrule_174;
#else
_currn = (_TPPrule_174) TreeNodeAlloc (sizeof (struct _TPrule_174));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_174;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_174: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_174: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_174: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_174;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_174 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_175 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_175 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_175 _currn;
#ifdef __cplusplus
_currn = new _TPrule_175;
#else
_currn = (_TPPrule_175) TreeNodeAlloc (sizeof (struct _TPrule_175));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_175;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_175: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_175;
return ( (NODEPTR) _currn);
}/* Mkrule_175 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_176 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_176 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_176 _currn;
#ifdef __cplusplus
_currn = new _TPrule_176;
#else
_currn = (_TPPrule_176) TreeNodeAlloc (sizeof (struct _TPrule_176));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_176;
_currn->_desc1 = (_TSPxOutputItemList) MkxOutputItemList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_176: root of subtree no. 1 can not be made a xOutputItemList node ", 0, _coordref);
_currn->_desc2 = (_TSPxOutputImpliedDo) MkxOutputImpliedDo (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_176: root of subtree no. 2 can not be made a xOutputImpliedDo node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_176;
return ( (NODEPTR) _currn);
}/* Mkrule_176 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_177 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_177 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_177 _currn;
#ifdef __cplusplus
_currn = new _TPrule_177;
#else
_currn = (_TPPrule_177) TreeNodeAlloc (sizeof (struct _TPrule_177));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_177;
_currn->_desc1 = (_TSPxOutputItemList) MkxOutputItemList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_177: root of subtree no. 1 can not be made a xOutputItemList node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_177: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_177;
return ( (NODEPTR) _currn);
}/* Mkrule_177 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_178 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_178 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_178 _currn;
#ifdef __cplusplus
_currn = new _TPrule_178;
#else
_currn = (_TPPrule_178) TreeNodeAlloc (sizeof (struct _TPrule_178));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_178;
_currn->_desc1 = (_TSPxOutputImpliedDo) MkxOutputImpliedDo (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_178: root of subtree no. 1 can not be made a xOutputImpliedDo node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_178;
return ( (NODEPTR) _currn);
}/* Mkrule_178 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_179 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_179 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_179 _currn;
#ifdef __cplusplus
_currn = new _TPrule_179;
#else
_currn = (_TPPrule_179) TreeNodeAlloc (sizeof (struct _TPrule_179));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_179;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_179: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxOutputImpliedDo) MkxOutputImpliedDo (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_179: root of subtree no. 2 can not be made a xOutputImpliedDo node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_179;
return ( (NODEPTR) _currn);
}/* Mkrule_179 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_180 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_180 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_180 _currn;
#ifdef __cplusplus
_currn = new _TPrule_180;
#else
_currn = (_TPPrule_180) TreeNodeAlloc (sizeof (struct _TPrule_180));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_180;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_180: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_180: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_180;
return ( (NODEPTR) _currn);
}/* Mkrule_180 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_181 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, NODEPTR _desc5)
#else
NODEPTR Mkrule_181 (_coordref,_desc1,_desc2,_desc3,_desc4,_desc5)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	NODEPTR _desc5;
#endif
{	_TPPrule_181 _currn;
#ifdef __cplusplus
_currn = new _TPrule_181;
#else
_currn = (_TPPrule_181) TreeNodeAlloc (sizeof (struct _TPrule_181));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_181;
_currn->_desc1 = (_TSPxOutputItemList) MkxOutputItemList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_181: root of subtree no. 1 can not be made a xOutputItemList node ", 0, _coordref);
_currn->_desc2 = (_TSPxImpliedDoVariable) MkxImpliedDoVariable (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_181: root of subtree no. 2 can not be made a xImpliedDoVariable node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_181: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_181: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_currn->_desc5 = (_TSPxExpr) MkxExpr (_coordref, _desc5);	
if (((NODEPTR)_currn->_desc5) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_181: root of subtree no. 5 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_181;
return ( (NODEPTR) _currn);
}/* Mkrule_181 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_182 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4)
#else
NODEPTR Mkrule_182 (_coordref,_desc1,_desc2,_desc3,_desc4)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
#endif
{	_TPPrule_182 _currn;
#ifdef __cplusplus
_currn = new _TPrule_182;
#else
_currn = (_TPPrule_182) TreeNodeAlloc (sizeof (struct _TPrule_182));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_182;
_currn->_desc1 = (_TSPxOutputItemList) MkxOutputItemList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_182: root of subtree no. 1 can not be made a xOutputItemList node ", 0, _coordref);
_currn->_desc2 = (_TSPxImpliedDoVariable) MkxImpliedDoVariable (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_182: root of subtree no. 2 can not be made a xImpliedDoVariable node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_182: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_182: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_182;
return ( (NODEPTR) _currn);
}/* Mkrule_182 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_183 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, NODEPTR _desc5)
#else
NODEPTR Mkrule_183 (_coordref,_desc1,_desc2,_desc3,_desc4,_desc5)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	NODEPTR _desc5;
#endif
{	_TPPrule_183 _currn;
#ifdef __cplusplus
_currn = new _TPrule_183;
#else
_currn = (_TPPrule_183) TreeNodeAlloc (sizeof (struct _TPrule_183));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_183;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_183: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxImpliedDoVariable) MkxImpliedDoVariable (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_183: root of subtree no. 2 can not be made a xImpliedDoVariable node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_183: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_183: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_currn->_desc5 = (_TSPxExpr) MkxExpr (_coordref, _desc5);	
if (((NODEPTR)_currn->_desc5) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_183: root of subtree no. 5 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_183;
return ( (NODEPTR) _currn);
}/* Mkrule_183 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_184 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4)
#else
NODEPTR Mkrule_184 (_coordref,_desc1,_desc2,_desc3,_desc4)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
#endif
{	_TPPrule_184 _currn;
#ifdef __cplusplus
_currn = new _TPrule_184;
#else
_currn = (_TPPrule_184) TreeNodeAlloc (sizeof (struct _TPrule_184));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_184;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_184: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxImpliedDoVariable) MkxImpliedDoVariable (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_184: root of subtree no. 2 can not be made a xImpliedDoVariable node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_184: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_184: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_184;
return ( (NODEPTR) _currn);
}/* Mkrule_184 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_185 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_185 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_185 _currn;
#ifdef __cplusplus
_currn = new _TPrule_185;
#else
_currn = (_TPPrule_185) TreeNodeAlloc (sizeof (struct _TPrule_185));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_185;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_185: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxOptionalParList) MkxOptionalParList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_185: root of subtree no. 2 can not be made a xOptionalParList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_185;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_185 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_186 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_186 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_186 _currn;
#ifdef __cplusplus
_currn = new _TPrule_186;
#else
_currn = (_TPPrule_186) TreeNodeAlloc (sizeof (struct _TPrule_186));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_186;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_186: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxOptionalParList) MkxOptionalParList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_186: root of subtree no. 2 can not be made a xOptionalParList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_186;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_186 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_187 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_187 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_187 _currn;
#ifdef __cplusplus
_currn = new _TPrule_187;
#else
_currn = (_TPPrule_187) TreeNodeAlloc (sizeof (struct _TPrule_187));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_187;
_currn->_desc1 = (_TSPxOptionalParList) MkxOptionalParList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_187: root of subtree no. 1 can not be made a xOptionalParList node ", 0, _coordref);
_currn->_desc2 = (_TSPxOptionalPar) MkxOptionalPar (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_187: root of subtree no. 2 can not be made a xOptionalPar node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_187;
return ( (NODEPTR) _currn);
}/* Mkrule_187 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_188 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_188 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_188 _currn;
#ifdef __cplusplus
_currn = new _TPrule_188;
#else
_currn = (_TPPrule_188) TreeNodeAlloc (sizeof (struct _TPrule_188));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_188;
_currn->_desc1 = (_TSPxOptionalPar) MkxOptionalPar (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_188: root of subtree no. 1 can not be made a xOptionalPar node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_188;
return ( (NODEPTR) _currn);
}/* Mkrule_188 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_189 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_189 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_189 _currn;
#ifdef __cplusplus
_currn = new _TPrule_189;
#else
_currn = (_TPPrule_189) TreeNodeAlloc (sizeof (struct _TPrule_189));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_189;
_currn->_desc1 = (_TSPxDummyArgName) MkxDummyArgName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_189: root of subtree no. 1 can not be made a xDummyArgName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_189;
return ( (NODEPTR) _currn);
}/* Mkrule_189 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_190 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_190 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_190 _currn;
#ifdef __cplusplus
_currn = new _TPrule_190;
#else
_currn = (_TPPrule_190) TreeNodeAlloc (sizeof (struct _TPrule_190));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_190;
_currn->_desc1 = (_TSPxStmt) MkxStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_190: root of subtree no. 1 can not be made a xStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_190;
return ( (NODEPTR) _currn);
}/* Mkrule_190 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_191 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_191 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_191 _currn;
#ifdef __cplusplus
_currn = new _TPrule_191;
#else
_currn = (_TPPrule_191) TreeNodeAlloc (sizeof (struct _TPrule_191));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_191;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_191: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxNamelistGroups) MkxNamelistGroups (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_191: root of subtree no. 2 can not be made a xNamelistGroups node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_191;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_191 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_192 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_192 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_192 _currn;
#ifdef __cplusplus
_currn = new _TPrule_192;
#else
_currn = (_TPPrule_192) TreeNodeAlloc (sizeof (struct _TPrule_192));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_192;
_currn->_desc1 = (_TSPxNamelistGroups) MkxNamelistGroups (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_192: root of subtree no. 1 can not be made a xNamelistGroups node ", 0, _coordref);
_currn->_desc2 = (_TSPxNamelistGroupName) MkxNamelistGroupName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_192: root of subtree no. 2 can not be made a xNamelistGroupName node ", 0, _coordref);
_currn->_desc3 = (_TSPxNamelistGroupObject) MkxNamelistGroupObject (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_192: root of subtree no. 3 can not be made a xNamelistGroupObject node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_192;
return ( (NODEPTR) _currn);
}/* Mkrule_192 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_193 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_193 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_193 _currn;
#ifdef __cplusplus
_currn = new _TPrule_193;
#else
_currn = (_TPPrule_193) TreeNodeAlloc (sizeof (struct _TPrule_193));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_193;
_currn->_desc1 = (_TSPxNamelistGroups) MkxNamelistGroups (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_193: root of subtree no. 1 can not be made a xNamelistGroups node ", 0, _coordref);
_currn->_desc2 = (_TSPxNamelistGroupObject) MkxNamelistGroupObject (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_193: root of subtree no. 2 can not be made a xNamelistGroupObject node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_193;
return ( (NODEPTR) _currn);
}/* Mkrule_193 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_194 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_194 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_194 _currn;
#ifdef __cplusplus
_currn = new _TPrule_194;
#else
_currn = (_TPPrule_194) TreeNodeAlloc (sizeof (struct _TPrule_194));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_194;
_currn->_desc1 = (_TSPxNamelistGroups) MkxNamelistGroups (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_194: root of subtree no. 1 can not be made a xNamelistGroups node ", 0, _coordref);
_currn->_desc2 = (_TSPxNamelistGroupName) MkxNamelistGroupName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_194: root of subtree no. 2 can not be made a xNamelistGroupName node ", 0, _coordref);
_currn->_desc3 = (_TSPxNamelistGroupObject) MkxNamelistGroupObject (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_194: root of subtree no. 3 can not be made a xNamelistGroupObject node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_194;
return ( (NODEPTR) _currn);
}/* Mkrule_194 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_195 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_195 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_195 _currn;
#ifdef __cplusplus
_currn = new _TPrule_195;
#else
_currn = (_TPPrule_195) TreeNodeAlloc (sizeof (struct _TPrule_195));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_195;
_currn->_desc1 = (_TSPxNamelistGroupName) MkxNamelistGroupName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_195: root of subtree no. 1 can not be made a xNamelistGroupName node ", 0, _coordref);
_currn->_desc2 = (_TSPxNamelistGroupObject) MkxNamelistGroupObject (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_195: root of subtree no. 2 can not be made a xNamelistGroupObject node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_195;
return ( (NODEPTR) _currn);
}/* Mkrule_195 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_196 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_196 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_196 _currn;
#ifdef __cplusplus
_currn = new _TPrule_196;
#else
_currn = (_TPPrule_196) TreeNodeAlloc (sizeof (struct _TPrule_196));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_196;
_currn->_desc1 = (_TSPxVariableName) MkxVariableName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_196: root of subtree no. 1 can not be made a xVariableName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_196;
return ( (NODEPTR) _currn);
}/* Mkrule_196 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_197 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_197 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_197 _currn;
#ifdef __cplusplus
_currn = new _TPrule_197;
#else
_currn = (_TPPrule_197) TreeNodeAlloc (sizeof (struct _TPrule_197));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_197;
_SETCOORD(_currn)
_TERMACT_rule_197;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_197 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_198 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_198 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_198 _currn;
#ifdef __cplusplus
_currn = new _TPrule_198;
#else
_currn = (_TPPrule_198) TreeNodeAlloc (sizeof (struct _TPrule_198));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_198;
_currn->_desc1 = (_TSPxModuleSubprogram) MkxModuleSubprogram (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_198: root of subtree no. 1 can not be made a xModuleSubprogram node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_198;
return ( (NODEPTR) _currn);
}/* Mkrule_198 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_199 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_199 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_199 _currn;
#ifdef __cplusplus
_currn = new _TPrule_199;
#else
_currn = (_TPPrule_199) TreeNodeAlloc (sizeof (struct _TPrule_199));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_199;
_currn->_desc1 = (_TSPxProgramUnit) MkxProgramUnit (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_199: root of subtree no. 1 can not be made a xProgramUnit node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_199;
return ( (NODEPTR) _currn);
}/* Mkrule_199 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_200 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_200 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_200 _currn;
#ifdef __cplusplus
_currn = new _TPrule_200;
#else
_currn = (_TPPrule_200) TreeNodeAlloc (sizeof (struct _TPrule_200));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_200;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_200: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxProcedureNameList) MkxProcedureNameList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_200: root of subtree no. 2 can not be made a xProcedureNameList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_200;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_200 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_201 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_201 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_201 _currn;
#ifdef __cplusplus
_currn = new _TPrule_201;
#else
_currn = (_TPPrule_201) TreeNodeAlloc (sizeof (struct _TPrule_201));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_201;
_currn->_desc1 = (_TSPxBodyConstruct) MkxBodyConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_201: root of subtree no. 1 can not be made a xBodyConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_201;
return ( (NODEPTR) _currn);
}/* Mkrule_201 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_202 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_202 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_202 _currn;
#ifdef __cplusplus
_currn = new _TPrule_202;
#else
_currn = (_TPPrule_202) TreeNodeAlloc (sizeof (struct _TPrule_202));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_202;
_currn->_desc1 = (_TSPxModuleBody) MkxModuleBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_202: root of subtree no. 1 can not be made a xModuleBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxBodyConstruct) MkxBodyConstruct (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_202: root of subtree no. 2 can not be made a xBodyConstruct node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_202;
return ( (NODEPTR) _currn);
}/* Mkrule_202 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_203 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_203 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_203 _currn;
#ifdef __cplusplus
_currn = new _TPrule_203;
#else
_currn = (_TPPrule_203) TreeNodeAlloc (sizeof (struct _TPrule_203));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_203;
_currn->_desc1 = (_TSPxModuleBody) MkxModuleBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_203: root of subtree no. 1 can not be made a xModuleBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndModuleStmt) MkxEndModuleStmt (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_203: root of subtree no. 2 can not be made a xEndModuleStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_203;
return ( (NODEPTR) _currn);
}/* Mkrule_203 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_204 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_204 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_204 _currn;
#ifdef __cplusplus
_currn = new _TPrule_204;
#else
_currn = (_TPPrule_204) TreeNodeAlloc (sizeof (struct _TPrule_204));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_204;
_currn->_desc1 = (_TSPxEndModuleStmt) MkxEndModuleStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_204: root of subtree no. 1 can not be made a xEndModuleStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_204;
return ( (NODEPTR) _currn);
}/* Mkrule_204 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_205 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_205 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_205 _currn;
#ifdef __cplusplus
_currn = new _TPrule_205;
#else
_currn = (_TPPrule_205) TreeNodeAlloc (sizeof (struct _TPrule_205));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_205;
_currn->_desc1 = (_TSPxHeader) MkxHeader (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_205: root of subtree no. 1 can not be made a xHeader node ", 0, _coordref);
_currn->_desc2 = (_TSPxModuleBlock) MkxModuleBlock (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_205: root of subtree no. 2 can not be made a xModuleBlock node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_205;
return ( (NODEPTR) _currn);
}/* Mkrule_205 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_206 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_206 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_206 _currn;
#ifdef __cplusplus
_currn = new _TPrule_206;
#else
_currn = (_TPPrule_206) TreeNodeAlloc (sizeof (struct _TPrule_206));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_206;
_currn->_desc1 = (_TSPxStmt) MkxStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_206: root of subtree no. 1 can not be made a xStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxBody) MkxBody (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_206: root of subtree no. 2 can not be made a xBody node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_206;
return ( (NODEPTR) _currn);
}/* Mkrule_206 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_207 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_207 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_207 _currn;
#ifdef __cplusplus
_currn = new _TPrule_207;
#else
_currn = (_TPPrule_207) TreeNodeAlloc (sizeof (struct _TPrule_207));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_207;
_currn->_desc1 = (_TSPxEndProgramStmt) MkxEndProgramStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_207: root of subtree no. 1 can not be made a xEndProgramStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_207;
return ( (NODEPTR) _currn);
}/* Mkrule_207 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_208 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_208 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_208 _currn;
#ifdef __cplusplus
_currn = new _TPrule_208;
#else
_currn = (_TPPrule_208) TreeNodeAlloc (sizeof (struct _TPrule_208));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_208;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_208: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndProgramStmt) MkxEndProgramStmt (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_208: root of subtree no. 2 can not be made a xEndProgramStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_208;
return ( (NODEPTR) _currn);
}/* Mkrule_208 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_209 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_209 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_209 _currn;
#ifdef __cplusplus
_currn = new _TPrule_209;
#else
_currn = (_TPPrule_209) TreeNodeAlloc (sizeof (struct _TPrule_209));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_209;
_currn->_desc1 = (_TSPxDefinedUnaryOp) MkxDefinedUnaryOp (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_209: root of subtree no. 1 can not be made a xDefinedUnaryOp node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_209: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_209;
return ( (NODEPTR) _currn);
}/* Mkrule_209 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_210 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_210 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_210 _currn;
#ifdef __cplusplus
_currn = new _TPrule_210;
#else
_currn = (_TPPrule_210) TreeNodeAlloc (sizeof (struct _TPrule_210));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_210;
_currn->_desc1 = (_TSPxLblRefList) MkxLblRefList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_210: root of subtree no. 1 can not be made a xLblRefList node ", 0, _coordref);
_currn->_desc2 = (_TSPxLblRef) MkxLblRef (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_210: root of subtree no. 2 can not be made a xLblRef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_210;
return ( (NODEPTR) _currn);
}/* Mkrule_210 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_211 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_211 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_211 _currn;
#ifdef __cplusplus
_currn = new _TPrule_211;
#else
_currn = (_TPPrule_211) TreeNodeAlloc (sizeof (struct _TPrule_211));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_211;
_currn->_desc1 = (_TSPxLblRef) MkxLblRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_211: root of subtree no. 1 can not be made a xLblRef node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_211;
return ( (NODEPTR) _currn);
}/* Mkrule_211 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_212 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_212 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_212 _currn;
#ifdef __cplusplus
_currn = new _TPrule_212;
#else
_currn = (_TPPrule_212) TreeNodeAlloc (sizeof (struct _TPrule_212));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_212;
_currn->_desc1 = (_TSPxUnitIdentifier) MkxUnitIdentifier (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_212: root of subtree no. 1 can not be made a xUnitIdentifier node ", 0, _coordref);
_currn->_desc2 = (_TSPxIoControlSpec) MkxIoControlSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_212: root of subtree no. 2 can not be made a xIoControlSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_212;
return ( (NODEPTR) _currn);
}/* Mkrule_212 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_213 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_213 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_213 _currn;
#ifdef __cplusplus
_currn = new _TPrule_213;
#else
_currn = (_TPPrule_213) TreeNodeAlloc (sizeof (struct _TPrule_213));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_213;
_currn->_desc1 = (_TSPxUnitIdentifier) MkxUnitIdentifier (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_213: root of subtree no. 1 can not be made a xUnitIdentifier node ", 0, _coordref);
_currn->_desc2 = (_TSPxFormatIdentifier) MkxFormatIdentifier (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_213: root of subtree no. 2 can not be made a xFormatIdentifier node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_213;
return ( (NODEPTR) _currn);
}/* Mkrule_213 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_214 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_214 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_214 _currn;
#ifdef __cplusplus
_currn = new _TPrule_214;
#else
_currn = (_TPPrule_214) TreeNodeAlloc (sizeof (struct _TPrule_214));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_214;
_currn->_desc1 = (_TSPxVariable) MkxVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_214: root of subtree no. 1 can not be made a xVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_214;
return ( (NODEPTR) _currn);
}/* Mkrule_214 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_215 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_215 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_215 _currn;
#ifdef __cplusplus
_currn = new _TPrule_215;
#else
_currn = (_TPPrule_215) TreeNodeAlloc (sizeof (struct _TPrule_215));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_215;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_215: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_215;
return ( (NODEPTR) _currn);
}/* Mkrule_215 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_216 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_216 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_216 _currn;
#ifdef __cplusplus
_currn = new _TPrule_216;
#else
_currn = (_TPPrule_216) TreeNodeAlloc (sizeof (struct _TPrule_216));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_216;
_currn->_desc1 = (_TSPxNamelistGroupName) MkxNamelistGroupName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_216: root of subtree no. 1 can not be made a xNamelistGroupName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_216;
return ( (NODEPTR) _currn);
}/* Mkrule_216 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_217 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_217 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_217 _currn;
#ifdef __cplusplus
_currn = new _TPrule_217;
#else
_currn = (_TPPrule_217) TreeNodeAlloc (sizeof (struct _TPrule_217));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_217;
_currn->_desc1 = (_TSPxFormatIdentifier) MkxFormatIdentifier (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_217: root of subtree no. 1 can not be made a xFormatIdentifier node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_217;
return ( (NODEPTR) _currn);
}/* Mkrule_217 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_218 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_218 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_218 _currn;
#ifdef __cplusplus
_currn = new _TPrule_218;
#else
_currn = (_TPPrule_218) TreeNodeAlloc (sizeof (struct _TPrule_218));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_218;
_currn->_desc1 = (_TSPxLblRef) MkxLblRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_218: root of subtree no. 1 can not be made a xLblRef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_218;
return ( (NODEPTR) _currn);
}/* Mkrule_218 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_219 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_219 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_219 _currn;
#ifdef __cplusplus
_currn = new _TPrule_219;
#else
_currn = (_TPPrule_219) TreeNodeAlloc (sizeof (struct _TPrule_219));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_219;
_currn->_desc1 = (_TSPxLblRef) MkxLblRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_219: root of subtree no. 1 can not be made a xLblRef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_219;
return ( (NODEPTR) _currn);
}/* Mkrule_219 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_220 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_220 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_220 _currn;
#ifdef __cplusplus
_currn = new _TPrule_220;
#else
_currn = (_TPPrule_220) TreeNodeAlloc (sizeof (struct _TPrule_220));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_220;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_220: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_220;
return ( (NODEPTR) _currn);
}/* Mkrule_220 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_221 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_221 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_221 _currn;
#ifdef __cplusplus
_currn = new _TPrule_221;
#else
_currn = (_TPPrule_221) TreeNodeAlloc (sizeof (struct _TPrule_221));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_221;
_currn->_desc1 = (_TSPxObjectName) MkxObjectName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_221: root of subtree no. 1 can not be made a xObjectName node ", 0, _coordref);
_currn->_desc2 = (_TSPxCharLength) MkxCharLength (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_221: root of subtree no. 2 can not be made a xCharLength node ", 0, _coordref);
_currn->_desc3 = (_TSPxArraySpec) MkxArraySpec (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_221: root of subtree no. 3 can not be made a xArraySpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_221;
return ( (NODEPTR) _currn);
}/* Mkrule_221 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_222 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4)
#else
NODEPTR Mkrule_222 (_coordref,_desc1,_desc2,_desc3,_desc4)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
#endif
{	_TPPrule_222 _currn;
#ifdef __cplusplus
_currn = new _TPrule_222;
#else
_currn = (_TPPrule_222) TreeNodeAlloc (sizeof (struct _TPrule_222));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_222;
_currn->_desc1 = (_TSPxObjectName) MkxObjectName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_222: root of subtree no. 1 can not be made a xObjectName node ", 0, _coordref);
_currn->_desc2 = (_TSPxCharLength) MkxCharLength (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_222: root of subtree no. 2 can not be made a xCharLength node ", 0, _coordref);
_currn->_desc3 = (_TSPxArraySpec) MkxArraySpec (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_222: root of subtree no. 3 can not be made a xArraySpec node ", 0, _coordref);
_currn->_desc4 = (_TSPxInitialization) MkxInitialization (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_222: root of subtree no. 4 can not be made a xInitialization node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_222;
return ( (NODEPTR) _currn);
}/* Mkrule_222 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_223 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_223 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_223 _currn;
#ifdef __cplusplus
_currn = new _TPrule_223;
#else
_currn = (_TPPrule_223) TreeNodeAlloc (sizeof (struct _TPrule_223));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_223;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_223: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxIntrinsicList) MkxIntrinsicList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_223: root of subtree no. 2 can not be made a xIntrinsicList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_223;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_223 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_224 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_224 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_224 _currn;
#ifdef __cplusplus
_currn = new _TPrule_224;
#else
_currn = (_TPPrule_224) TreeNodeAlloc (sizeof (struct _TPrule_224));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_224;
_SETCOORD(_currn)
_TERMACT_rule_224;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_224 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_225 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_225 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_225 _currn;
#ifdef __cplusplus
_currn = new _TPrule_225;
#else
_currn = (_TPPrule_225) TreeNodeAlloc (sizeof (struct _TPrule_225));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_225;
_currn->_desc1 = (_TSPxIntrinsicProcedureName) MkxIntrinsicProcedureName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_225: root of subtree no. 1 can not be made a xIntrinsicProcedureName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_225;
return ( (NODEPTR) _currn);
}/* Mkrule_225 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_226 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_226 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_226 _currn;
#ifdef __cplusplus
_currn = new _TPrule_226;
#else
_currn = (_TPPrule_226) TreeNodeAlloc (sizeof (struct _TPrule_226));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_226;
_currn->_desc1 = (_TSPxIntrinsicList) MkxIntrinsicList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_226: root of subtree no. 1 can not be made a xIntrinsicList node ", 0, _coordref);
_currn->_desc2 = (_TSPxIntrinsicProcedureName) MkxIntrinsicProcedureName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_226: root of subtree no. 2 can not be made a xIntrinsicProcedureName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_226;
return ( (NODEPTR) _currn);
}/* Mkrule_226 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_227 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_227 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_227 _currn;
#ifdef __cplusplus
_currn = new _TPrule_227;
#else
_currn = (_TPPrule_227) TreeNodeAlloc (sizeof (struct _TPrule_227));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_227;
_currn->_desc1 = (_TSPxProgramUnit) MkxProgramUnit (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_227: root of subtree no. 1 can not be made a xProgramUnit node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_227;
return ( (NODEPTR) _currn);
}/* Mkrule_227 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_228 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_228 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_228 _currn;
#ifdef __cplusplus
_currn = new _TPrule_228;
#else
_currn = (_TPPrule_228) TreeNodeAlloc (sizeof (struct _TPrule_228));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_228;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_228: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxGenericSpec) MkxGenericSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_228: root of subtree no. 2 can not be made a xGenericSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_228;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_228 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_229 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_229 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_229 _currn;
#ifdef __cplusplus
_currn = new _TPrule_229;
#else
_currn = (_TPPrule_229) TreeNodeAlloc (sizeof (struct _TPrule_229));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_229;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_229: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxGenericName) MkxGenericName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_229: root of subtree no. 2 can not be made a xGenericName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_229;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_229 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_230 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_230 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_230 _currn;
#ifdef __cplusplus
_currn = new _TPrule_230;
#else
_currn = (_TPPrule_230) TreeNodeAlloc (sizeof (struct _TPrule_230));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_230;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_230: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_230;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_230 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_231 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_231 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_231 _currn;
#ifdef __cplusplus
_currn = new _TPrule_231;
#else
_currn = (_TPPrule_231) TreeNodeAlloc (sizeof (struct _TPrule_231));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_231;
_currn->_desc1 = (_TSPxStmt) MkxStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_231: root of subtree no. 1 can not be made a xStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_231;
return ( (NODEPTR) _currn);
}/* Mkrule_231 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_232 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_232 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_232 _currn;
#ifdef __cplusplus
_currn = new _TPrule_232;
#else
_currn = (_TPPrule_232) TreeNodeAlloc (sizeof (struct _TPrule_232));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_232;
_currn->_desc1 = (_TSPxInterfaceBody) MkxInterfaceBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_232: root of subtree no. 1 can not be made a xInterfaceBody node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_232;
return ( (NODEPTR) _currn);
}/* Mkrule_232 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_233 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_233 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_233 _currn;
#ifdef __cplusplus
_currn = new _TPrule_233;
#else
_currn = (_TPPrule_233) TreeNodeAlloc (sizeof (struct _TPrule_233));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_233;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_233: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndInterfaceStmt) MkxEndInterfaceStmt (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_233: root of subtree no. 2 can not be made a xEndInterfaceStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_233;
return ( (NODEPTR) _currn);
}/* Mkrule_233 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_234 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_234 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_234 _currn;
#ifdef __cplusplus
_currn = new _TPrule_234;
#else
_currn = (_TPPrule_234) TreeNodeAlloc (sizeof (struct _TPrule_234));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_234;
_currn->_desc1 = (_TSPxSubroutineStmt) MkxSubroutineStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_234: root of subtree no. 1 can not be made a xSubroutineStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxSubprogramRange) MkxSubprogramRange (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_234: root of subtree no. 2 can not be made a xSubprogramRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_234;
return ( (NODEPTR) _currn);
}/* Mkrule_234 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_235 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_235 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_235 _currn;
#ifdef __cplusplus
_currn = new _TPrule_235;
#else
_currn = (_TPPrule_235) TreeNodeAlloc (sizeof (struct _TPrule_235));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_235;
_currn->_desc1 = (_TSPxFunctionStmt) MkxFunctionStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_235: root of subtree no. 1 can not be made a xFunctionStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxSubprogramRange) MkxSubprogramRange (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_235: root of subtree no. 2 can not be made a xSubprogramRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_235;
return ( (NODEPTR) _currn);
}/* Mkrule_235 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_236 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_236 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_236 _currn;
#ifdef __cplusplus
_currn = new _TPrule_236;
#else
_currn = (_TPPrule_236) TreeNodeAlloc (sizeof (struct _TPrule_236));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_236;
_currn->_desc1 = (_TSPxInterfaceSpecification) MkxInterfaceSpecification (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_236: root of subtree no. 1 can not be made a xInterfaceSpecification node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_236;
return ( (NODEPTR) _currn);
}/* Mkrule_236 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_237 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_237 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_237 _currn;
#ifdef __cplusplus
_currn = new _TPrule_237;
#else
_currn = (_TPPrule_237) TreeNodeAlloc (sizeof (struct _TPrule_237));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_237;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_237: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxInterfaceSpecification) MkxInterfaceSpecification (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_237: root of subtree no. 2 can not be made a xInterfaceSpecification node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_237;
return ( (NODEPTR) _currn);
}/* Mkrule_237 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_238 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_238 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_238 _currn;
#ifdef __cplusplus
_currn = new _TPrule_238;
#else
_currn = (_TPPrule_238) TreeNodeAlloc (sizeof (struct _TPrule_238));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_238;
_currn->_desc1 = (_TSPxInterfaceStmt) MkxInterfaceStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_238: root of subtree no. 1 can not be made a xInterfaceStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxInterfaceRange) MkxInterfaceRange (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_238: root of subtree no. 2 can not be made a xInterfaceRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_238;
return ( (NODEPTR) _currn);
}/* Mkrule_238 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_239 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_239 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_239 _currn;
#ifdef __cplusplus
_currn = new _TPrule_239;
#else
_currn = (_TPPrule_239) TreeNodeAlloc (sizeof (struct _TPrule_239));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_239;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_239: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxIntentSpec) MkxIntentSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_239: root of subtree no. 2 can not be made a xIntentSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPxIntentParList) MkxIntentParList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_239: root of subtree no. 3 can not be made a xIntentParList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_239;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_239 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_240 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_240 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_240 _currn;
#ifdef __cplusplus
_currn = new _TPrule_240;
#else
_currn = (_TPPrule_240) TreeNodeAlloc (sizeof (struct _TPrule_240));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_240;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_240: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxIntentSpec) MkxIntentSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_240: root of subtree no. 2 can not be made a xIntentSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPxIntentParList) MkxIntentParList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_240: root of subtree no. 3 can not be made a xIntentParList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_240;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_240 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_241 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_241 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_241 _currn;
#ifdef __cplusplus
_currn = new _TPrule_241;
#else
_currn = (_TPPrule_241) TreeNodeAlloc (sizeof (struct _TPrule_241));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_241;
_currn->_desc1 = (_TSPxIntentParList) MkxIntentParList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_241: root of subtree no. 1 can not be made a xIntentParList node ", 0, _coordref);
_currn->_desc2 = (_TSPxIntentPar) MkxIntentPar (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_241: root of subtree no. 2 can not be made a xIntentPar node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_241;
return ( (NODEPTR) _currn);
}/* Mkrule_241 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_242 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_242 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_242 _currn;
#ifdef __cplusplus
_currn = new _TPrule_242;
#else
_currn = (_TPPrule_242) TreeNodeAlloc (sizeof (struct _TPrule_242));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_242;
_currn->_desc1 = (_TSPxIntentPar) MkxIntentPar (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_242: root of subtree no. 1 can not be made a xIntentPar node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_242;
return ( (NODEPTR) _currn);
}/* Mkrule_242 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_243 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_243 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_243 _currn;
#ifdef __cplusplus
_currn = new _TPrule_243;
#else
_currn = (_TPPrule_243) TreeNodeAlloc (sizeof (struct _TPrule_243));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_243;
_currn->_desc1 = (_TSPxDummyArgName) MkxDummyArgName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_243: root of subtree no. 1 can not be made a xDummyArgName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_243;
return ( (NODEPTR) _currn);
}/* Mkrule_243 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_244 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_244 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_244 _currn;
#ifdef __cplusplus
_currn = new _TPrule_244;
#else
_currn = (_TPPrule_244) TreeNodeAlloc (sizeof (struct _TPrule_244));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_244;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_244: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_244;
return ( (NODEPTR) _currn);
}/* Mkrule_244 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_245 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_245 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_245 _currn;
#ifdef __cplusplus
_currn = new _TPrule_245;
#else
_currn = (_TPPrule_245) TreeNodeAlloc (sizeof (struct _TPrule_245));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_245;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_245: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_245;
return ( (NODEPTR) _currn);
}/* Mkrule_245 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_246 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_246 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_246 _currn;
#ifdef __cplusplus
_currn = new _TPrule_246;
#else
_currn = (_TPPrule_246) TreeNodeAlloc (sizeof (struct _TPrule_246));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_246;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_246: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_246;
return ( (NODEPTR) _currn);
}/* Mkrule_246 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_247 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_247 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_247 _currn;
#ifdef __cplusplus
_currn = new _TPrule_247;
#else
_currn = (_TPPrule_247) TreeNodeAlloc (sizeof (struct _TPrule_247));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_247;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_247: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_247;
return ( (NODEPTR) _currn);
}/* Mkrule_247 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_248 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_248 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_248 _currn;
#ifdef __cplusplus
_currn = new _TPrule_248;
#else
_currn = (_TPPrule_248) TreeNodeAlloc (sizeof (struct _TPrule_248));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_248;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_248: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_248;
return ( (NODEPTR) _currn);
}/* Mkrule_248 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_249 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_249 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_249 _currn;
#ifdef __cplusplus
_currn = new _TPrule_249;
#else
_currn = (_TPPrule_249) TreeNodeAlloc (sizeof (struct _TPrule_249));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_249;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_249: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_249;
return ( (NODEPTR) _currn);
}/* Mkrule_249 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_250 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_250 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_250 _currn;
#ifdef __cplusplus
_currn = new _TPrule_250;
#else
_currn = (_TPPrule_250) TreeNodeAlloc (sizeof (struct _TPrule_250));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_250;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_250: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_250;
return ( (NODEPTR) _currn);
}/* Mkrule_250 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_251 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_251 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_251 _currn;
#ifdef __cplusplus
_currn = new _TPrule_251;
#else
_currn = (_TPPrule_251) TreeNodeAlloc (sizeof (struct _TPrule_251));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_251;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_251: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_251;
return ( (NODEPTR) _currn);
}/* Mkrule_251 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_252 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_252 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_252 _currn;
#ifdef __cplusplus
_currn = new _TPrule_252;
#else
_currn = (_TPPrule_252) TreeNodeAlloc (sizeof (struct _TPrule_252));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_252;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_252: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_252;
return ( (NODEPTR) _currn);
}/* Mkrule_252 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_253 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_253 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_253 _currn;
#ifdef __cplusplus
_currn = new _TPrule_253;
#else
_currn = (_TPPrule_253) TreeNodeAlloc (sizeof (struct _TPrule_253));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_253;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_253: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_253;
return ( (NODEPTR) _currn);
}/* Mkrule_253 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_254 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_254 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_254 _currn;
#ifdef __cplusplus
_currn = new _TPrule_254;
#else
_currn = (_TPPrule_254) TreeNodeAlloc (sizeof (struct _TPrule_254));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_254;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_254: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_254;
return ( (NODEPTR) _currn);
}/* Mkrule_254 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_255 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_255 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_255 _currn;
#ifdef __cplusplus
_currn = new _TPrule_255;
#else
_currn = (_TPPrule_255) TreeNodeAlloc (sizeof (struct _TPrule_255));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_255;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_255: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_255;
return ( (NODEPTR) _currn);
}/* Mkrule_255 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_256 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_256 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_256 _currn;
#ifdef __cplusplus
_currn = new _TPrule_256;
#else
_currn = (_TPPrule_256) TreeNodeAlloc (sizeof (struct _TPrule_256));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_256;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_256: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_256;
return ( (NODEPTR) _currn);
}/* Mkrule_256 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_257 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_257 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_257 _currn;
#ifdef __cplusplus
_currn = new _TPrule_257;
#else
_currn = (_TPPrule_257) TreeNodeAlloc (sizeof (struct _TPrule_257));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_257;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_257: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_257;
return ( (NODEPTR) _currn);
}/* Mkrule_257 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_258 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_258 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_258 _currn;
#ifdef __cplusplus
_currn = new _TPrule_258;
#else
_currn = (_TPPrule_258) TreeNodeAlloc (sizeof (struct _TPrule_258));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_258;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_258: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_258;
return ( (NODEPTR) _currn);
}/* Mkrule_258 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_259 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_259 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_259 _currn;
#ifdef __cplusplus
_currn = new _TPrule_259;
#else
_currn = (_TPPrule_259) TreeNodeAlloc (sizeof (struct _TPrule_259));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_259;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_259: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_259;
return ( (NODEPTR) _currn);
}/* Mkrule_259 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_260 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_260 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_260 _currn;
#ifdef __cplusplus
_currn = new _TPrule_260;
#else
_currn = (_TPPrule_260) TreeNodeAlloc (sizeof (struct _TPrule_260));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_260;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_260: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_260;
return ( (NODEPTR) _currn);
}/* Mkrule_260 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_261 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_261 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_261 _currn;
#ifdef __cplusplus
_currn = new _TPrule_261;
#else
_currn = (_TPPrule_261) TreeNodeAlloc (sizeof (struct _TPrule_261));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_261;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_261: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_261;
return ( (NODEPTR) _currn);
}/* Mkrule_261 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_262 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_262 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_262 _currn;
#ifdef __cplusplus
_currn = new _TPrule_262;
#else
_currn = (_TPPrule_262) TreeNodeAlloc (sizeof (struct _TPrule_262));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_262;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_262: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_262;
return ( (NODEPTR) _currn);
}/* Mkrule_262 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_263 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_263 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_263 _currn;
#ifdef __cplusplus
_currn = new _TPrule_263;
#else
_currn = (_TPPrule_263) TreeNodeAlloc (sizeof (struct _TPrule_263));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_263;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_263: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_263;
return ( (NODEPTR) _currn);
}/* Mkrule_263 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_264 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_264 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_264 _currn;
#ifdef __cplusplus
_currn = new _TPrule_264;
#else
_currn = (_TPPrule_264) TreeNodeAlloc (sizeof (struct _TPrule_264));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_264;
_currn->_desc1 = (_TSPxInputItemList) MkxInputItemList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_264: root of subtree no. 1 can not be made a xInputItemList node ", 0, _coordref);
_currn->_desc2 = (_TSPxInputItem) MkxInputItem (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_264: root of subtree no. 2 can not be made a xInputItem node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_264;
return ( (NODEPTR) _currn);
}/* Mkrule_264 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_265 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_265 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_265 _currn;
#ifdef __cplusplus
_currn = new _TPrule_265;
#else
_currn = (_TPPrule_265) TreeNodeAlloc (sizeof (struct _TPrule_265));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_265;
_currn->_desc1 = (_TSPxInputItem) MkxInputItem (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_265: root of subtree no. 1 can not be made a xInputItem node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_265;
return ( (NODEPTR) _currn);
}/* Mkrule_265 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_266 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_266 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_266 _currn;
#ifdef __cplusplus
_currn = new _TPrule_266;
#else
_currn = (_TPPrule_266) TreeNodeAlloc (sizeof (struct _TPrule_266));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_266;
_currn->_desc1 = (_TSPxVariable) MkxVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_266: root of subtree no. 1 can not be made a xVariable node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_266;
return ( (NODEPTR) _currn);
}/* Mkrule_266 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_267 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_267 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_267 _currn;
#ifdef __cplusplus
_currn = new _TPrule_267;
#else
_currn = (_TPPrule_267) TreeNodeAlloc (sizeof (struct _TPrule_267));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_267;
_currn->_desc1 = (_TSPxInputImpliedDo) MkxInputImpliedDo (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_267: root of subtree no. 1 can not be made a xInputImpliedDo node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_267;
return ( (NODEPTR) _currn);
}/* Mkrule_267 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_268 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, NODEPTR _desc5)
#else
NODEPTR Mkrule_268 (_coordref,_desc1,_desc2,_desc3,_desc4,_desc5)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	NODEPTR _desc5;
#endif
{	_TPPrule_268 _currn;
#ifdef __cplusplus
_currn = new _TPrule_268;
#else
_currn = (_TPPrule_268) TreeNodeAlloc (sizeof (struct _TPrule_268));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_268;
_currn->_desc1 = (_TSPxInputItemList) MkxInputItemList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_268: root of subtree no. 1 can not be made a xInputItemList node ", 0, _coordref);
_currn->_desc2 = (_TSPxImpliedDoVariable) MkxImpliedDoVariable (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_268: root of subtree no. 2 can not be made a xImpliedDoVariable node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_268: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_268: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_currn->_desc5 = (_TSPxExpr) MkxExpr (_coordref, _desc5);	
if (((NODEPTR)_currn->_desc5) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_268: root of subtree no. 5 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_268;
return ( (NODEPTR) _currn);
}/* Mkrule_268 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_269 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4)
#else
NODEPTR Mkrule_269 (_coordref,_desc1,_desc2,_desc3,_desc4)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
#endif
{	_TPPrule_269 _currn;
#ifdef __cplusplus
_currn = new _TPrule_269;
#else
_currn = (_TPPrule_269) TreeNodeAlloc (sizeof (struct _TPrule_269));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_269;
_currn->_desc1 = (_TSPxInputItemList) MkxInputItemList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_269: root of subtree no. 1 can not be made a xInputItemList node ", 0, _coordref);
_currn->_desc2 = (_TSPxImpliedDoVariable) MkxImpliedDoVariable (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_269: root of subtree no. 2 can not be made a xImpliedDoVariable node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_269: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_269: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_269;
return ( (NODEPTR) _currn);
}/* Mkrule_269 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_270 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_270 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_270 _currn;
#ifdef __cplusplus
_currn = new _TPrule_270;
#else
_currn = (_TPPrule_270) TreeNodeAlloc (sizeof (struct _TPrule_270));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_270;
_SETCOORD(_currn)
_TERMACT_rule_270;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_270 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_271 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_271 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_271 _currn;
#ifdef __cplusplus
_currn = new _TPrule_271;
#else
_currn = (_TPPrule_271) TreeNodeAlloc (sizeof (struct _TPrule_271));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_271;
_currn->_desc1 = (_TSPxImplicitSpecList) MkxImplicitSpecList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_271: root of subtree no. 1 can not be made a xImplicitSpecList node ", 0, _coordref);
_currn->_desc2 = (_TSPxImplicitSpec) MkxImplicitSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_271: root of subtree no. 2 can not be made a xImplicitSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_271;
return ( (NODEPTR) _currn);
}/* Mkrule_271 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_272 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_272 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_272 _currn;
#ifdef __cplusplus
_currn = new _TPrule_272;
#else
_currn = (_TPPrule_272) TreeNodeAlloc (sizeof (struct _TPrule_272));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_272;
_currn->_desc1 = (_TSPxImplicitSpec) MkxImplicitSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_272: root of subtree no. 1 can not be made a xImplicitSpec node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_272;
return ( (NODEPTR) _currn);
}/* Mkrule_272 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_273 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_273 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_273 _currn;
#ifdef __cplusplus
_currn = new _TPrule_273;
#else
_currn = (_TPPrule_273) TreeNodeAlloc (sizeof (struct _TPrule_273));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_273;
_currn->_desc1 = (_TSPxStmt) MkxStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_273: root of subtree no. 1 can not be made a xStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxThenPart) MkxThenPart (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_273: root of subtree no. 2 can not be made a xThenPart node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_273;
return ( (NODEPTR) _currn);
}/* Mkrule_273 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_274 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_274 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_274 _currn;
#ifdef __cplusplus
_currn = new _TPrule_274;
#else
_currn = (_TPPrule_274) TreeNodeAlloc (sizeof (struct _TPrule_274));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_274;
_currn->_desc1 = (_TSPxDefinedOperator) MkxDefinedOperator (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_274: root of subtree no. 1 can not be made a xDefinedOperator node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_274;
return ( (NODEPTR) _currn);
}/* Mkrule_274 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_275 (POSITION *_coordref)
#else
NODEPTR Mkrule_275 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_275 _currn;
#ifdef __cplusplus
_currn = new _TPrule_275;
#else
_currn = (_TPPrule_275) TreeNodeAlloc (sizeof (struct _TPrule_275));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_275;
_SETCOORD(_currn)
_TERMACT_rule_275;
return ( (NODEPTR) _currn);
}/* Mkrule_275 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_276 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_276 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_276 _currn;
#ifdef __cplusplus
_currn = new _TPrule_276;
#else
_currn = (_TPPrule_276) TreeNodeAlloc (sizeof (struct _TPrule_276));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_276;
_SETCOORD(_currn)
_TERMACT_rule_276;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_276 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_277 (POSITION *_coordref)
#else
NODEPTR Mkrule_277 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_277 _currn;
#ifdef __cplusplus
_currn = new _TPrule_277;
#else
_currn = (_TPPrule_277) TreeNodeAlloc (sizeof (struct _TPrule_277));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_277;
_SETCOORD(_currn)
_TERMACT_rule_277;
return ( (NODEPTR) _currn);
}/* Mkrule_277 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_278 (POSITION *_coordref)
#else
NODEPTR Mkrule_278 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_278 _currn;
#ifdef __cplusplus
_currn = new _TPrule_278;
#else
_currn = (_TPPrule_278) TreeNodeAlloc (sizeof (struct _TPrule_278));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_278;
_SETCOORD(_currn)
_TERMACT_rule_278;
return ( (NODEPTR) _currn);
}/* Mkrule_278 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_279 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_279 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_279 _currn;
#ifdef __cplusplus
_currn = new _TPrule_279;
#else
_currn = (_TPPrule_279) TreeNodeAlloc (sizeof (struct _TPrule_279));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_279;
_SETCOORD(_currn)
_TERMACT_rule_279;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xXcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_279 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_280 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_280 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_280 _currn;
#ifdef __cplusplus
_currn = new _TPrule_280;
#else
_currn = (_TPPrule_280) TreeNodeAlloc (sizeof (struct _TPrule_280));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_280;
_SETCOORD(_currn)
_TERMACT_rule_280;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xPcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_280 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_281 (POSITION *_coordref, int _TERM1, int _TERM2, NODEPTR _desc1)
#else
NODEPTR Mkrule_281 (_coordref, _TERM1, _TERM2,_desc1)
	POSITION *_coordref;
	int _TERM1;
	int _TERM2;
	NODEPTR _desc1;
#endif
{	_TPPrule_281 _currn;
#ifdef __cplusplus
_currn = new _TPrule_281;
#else
_currn = (_TPPrule_281) TreeNodeAlloc (sizeof (struct _TPrule_281));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_281;
_currn->_desc1 = (_TSPxFmtSpec) MkxFmtSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_281: root of subtree no. 1 can not be made a xFmtSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_281;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xPcon", _TERM1);
#endif

#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM2);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_281 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_282 (POSITION *_coordref, int _TERM1, NODEPTR _desc1)
#else
NODEPTR Mkrule_282 (_coordref, _TERM1,_desc1)
	POSITION *_coordref;
	int _TERM1;
	NODEPTR _desc1;
#endif
{	_TPPrule_282 _currn;
#ifdef __cplusplus
_currn = new _TPrule_282;
#else
_currn = (_TPPrule_282) TreeNodeAlloc (sizeof (struct _TPrule_282));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_282;
_currn->_desc1 = (_TSPxFmtSpec) MkxFmtSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_282: root of subtree no. 1 can not be made a xFmtSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_282;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xPcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_282 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_283 (POSITION *_coordref, int _TERM1, NODEPTR _desc1)
#else
NODEPTR Mkrule_283 (_coordref, _TERM1,_desc1)
	POSITION *_coordref;
	int _TERM1;
	NODEPTR _desc1;
#endif
{	_TPPrule_283 _currn;
#ifdef __cplusplus
_currn = new _TPrule_283;
#else
_currn = (_TPPrule_283) TreeNodeAlloc (sizeof (struct _TPrule_283));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_283;
_currn->_desc1 = (_TSPxFmtSpec) MkxFmtSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_283: root of subtree no. 1 can not be made a xFmtSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_283;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_283 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_284 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_284 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_284 _currn;
#ifdef __cplusplus
_currn = new _TPrule_284;
#else
_currn = (_TPPrule_284) TreeNodeAlloc (sizeof (struct _TPrule_284));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_284;
_currn->_desc1 = (_TSPxLblRef) MkxLblRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_284: root of subtree no. 1 can not be made a xLblRef node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_284;
return ( (NODEPTR) _currn);
}/* Mkrule_284 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_285 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_285 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_285 _currn;
#ifdef __cplusplus
_currn = new _TPrule_285;
#else
_currn = (_TPPrule_285) TreeNodeAlloc (sizeof (struct _TPrule_285));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_285;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_285: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_285;
return ( (NODEPTR) _currn);
}/* Mkrule_285 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_286 (POSITION *_coordref)
#else
NODEPTR Mkrule_286 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_286 _currn;
#ifdef __cplusplus
_currn = new _TPrule_286;
#else
_currn = (_TPPrule_286) TreeNodeAlloc (sizeof (struct _TPrule_286));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_286;
_SETCOORD(_currn)
_TERMACT_rule_286;
return ( (NODEPTR) _currn);
}/* Mkrule_286 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_287 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_287 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_287 _currn;
#ifdef __cplusplus
_currn = new _TPrule_287;
#else
_currn = (_TPPrule_287) TreeNodeAlloc (sizeof (struct _TPrule_287));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_287;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_287: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_currn->_desc2 = (_TSPxSubscript) MkxSubscript (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_287: root of subtree no. 2 can not be made a xSubscript node ", 0, _coordref);
_currn->_desc3 = (_TSPxSubscript) MkxSubscript (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_287: root of subtree no. 3 can not be made a xSubscript node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_287;
return ( (NODEPTR) _currn);
}/* Mkrule_287 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_288 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4)
#else
NODEPTR Mkrule_288 (_coordref,_desc1,_desc2,_desc3,_desc4)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
#endif
{	_TPPrule_288 _currn;
#ifdef __cplusplus
_currn = new _TPrule_288;
#else
_currn = (_TPPrule_288) TreeNodeAlloc (sizeof (struct _TPrule_288));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_288;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_288: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_currn->_desc2 = (_TSPxSubscript) MkxSubscript (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_288: root of subtree no. 2 can not be made a xSubscript node ", 0, _coordref);
_currn->_desc3 = (_TSPxSubscript) MkxSubscript (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_288: root of subtree no. 3 can not be made a xSubscript node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_288: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_288;
return ( (NODEPTR) _currn);
}/* Mkrule_288 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_289 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_289 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_289 _currn;
#ifdef __cplusplus
_currn = new _TPrule_289;
#else
_currn = (_TPPrule_289) TreeNodeAlloc (sizeof (struct _TPrule_289));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_289;
_currn->_desc1 = (_TSPxForallTripletSpecList) MkxForallTripletSpecList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_289: root of subtree no. 1 can not be made a xForallTripletSpecList node ", 0, _coordref);
_currn->_desc2 = (_TSPxScalarMaskExpr) MkxScalarMaskExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_289: root of subtree no. 2 can not be made a xScalarMaskExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_289;
return ( (NODEPTR) _currn);
}/* Mkrule_289 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_290 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_290 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_290 _currn;
#ifdef __cplusplus
_currn = new _TPrule_290;
#else
_currn = (_TPPrule_290) TreeNodeAlloc (sizeof (struct _TPrule_290));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_290;
_currn->_desc1 = (_TSPxForallTripletSpecList) MkxForallTripletSpecList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_290: root of subtree no. 1 can not be made a xForallTripletSpecList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_290;
return ( (NODEPTR) _currn);
}/* Mkrule_290 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_291 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_291 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_291 _currn;
#ifdef __cplusplus
_currn = new _TPrule_291;
#else
_currn = (_TPPrule_291) TreeNodeAlloc (sizeof (struct _TPrule_291));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_291;
_currn->_desc1 = (_TSPxForallConstructStmt) MkxForallConstructStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_291: root of subtree no. 1 can not be made a xForallConstructStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxBody) MkxBody (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_291: root of subtree no. 2 can not be made a xBody node ", 0, _coordref);
_currn->_desc3 = (_TSPxEndForallStmt) MkxEndForallStmt (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_291: root of subtree no. 3 can not be made a xEndForallStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_291;
return ( (NODEPTR) _currn);
}/* Mkrule_291 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_292 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_292 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_292 _currn;
#ifdef __cplusplus
_currn = new _TPrule_292;
#else
_currn = (_TPPrule_292) TreeNodeAlloc (sizeof (struct _TPrule_292));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_292;
_currn->_desc1 = (_TSPxForallConstructStmt) MkxForallConstructStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_292: root of subtree no. 1 can not be made a xForallConstructStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndForallStmt) MkxEndForallStmt (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_292: root of subtree no. 2 can not be made a xEndForallStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_292;
return ( (NODEPTR) _currn);
}/* Mkrule_292 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_293 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_293 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_293 _currn;
#ifdef __cplusplus
_currn = new _TPrule_293;
#else
_currn = (_TPPrule_293) TreeNodeAlloc (sizeof (struct _TPrule_293));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_293;
_currn->_desc1 = (_TSPxWhereConstruct) MkxWhereConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_293: root of subtree no. 1 can not be made a xWhereConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_293;
return ( (NODEPTR) _currn);
}/* Mkrule_293 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_294 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_294 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_294 _currn;
#ifdef __cplusplus
_currn = new _TPrule_294;
#else
_currn = (_TPPrule_294) TreeNodeAlloc (sizeof (struct _TPrule_294));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_294;
_currn->_desc1 = (_TSPxForallStmt) MkxForallStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_294: root of subtree no. 1 can not be made a xForallStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_294;
return ( (NODEPTR) _currn);
}/* Mkrule_294 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_295 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_295 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_295 _currn;
#ifdef __cplusplus
_currn = new _TPrule_295;
#else
_currn = (_TPPrule_295) TreeNodeAlloc (sizeof (struct _TPrule_295));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_295;
_currn->_desc1 = (_TSPxForallConstruct) MkxForallConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_295: root of subtree no. 1 can not be made a xForallConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_295;
return ( (NODEPTR) _currn);
}/* Mkrule_295 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_296 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_296 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_296 _currn;
#ifdef __cplusplus
_currn = new _TPrule_296;
#else
_currn = (_TPPrule_296) TreeNodeAlloc (sizeof (struct _TPrule_296));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_296;
_currn->_desc1 = (_TSPxStmt) MkxStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_296: root of subtree no. 1 can not be made a xStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_296;
return ( (NODEPTR) _currn);
}/* Mkrule_296 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_297 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_297 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_297 _currn;
#ifdef __cplusplus
_currn = new _TPrule_297;
#else
_currn = (_TPPrule_297) TreeNodeAlloc (sizeof (struct _TPrule_297));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_297;
_currn->_desc1 = (_TSPxForallBodyConstruct) MkxForallBodyConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_297: root of subtree no. 1 can not be made a xForallBodyConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_297;
return ( (NODEPTR) _currn);
}/* Mkrule_297 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_298 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_298 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_298 _currn;
#ifdef __cplusplus
_currn = new _TPrule_298;
#else
_currn = (_TPPrule_298) TreeNodeAlloc (sizeof (struct _TPrule_298));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_298;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_298: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxForallBodyConstruct) MkxForallBodyConstruct (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_298: root of subtree no. 2 can not be made a xForallBodyConstruct node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_298;
return ( (NODEPTR) _currn);
}/* Mkrule_298 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_299 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_299 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_299 _currn;
#ifdef __cplusplus
_currn = new _TPrule_299;
#else
_currn = (_TPPrule_299) TreeNodeAlloc (sizeof (struct _TPrule_299));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_299;
_currn->_desc1 = (_TSPxFmtSpec) MkxFmtSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_299: root of subtree no. 1 can not be made a xFmtSpec node ", 0, _coordref);
_currn->_desc2 = (_TSPxFmtSpec) MkxFmtSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_299: root of subtree no. 2 can not be made a xFmtSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_299;
return ( (NODEPTR) _currn);
}/* Mkrule_299 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_300 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_300 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_300 _currn;
#ifdef __cplusplus
_currn = new _TPrule_300;
#else
_currn = (_TPPrule_300) TreeNodeAlloc (sizeof (struct _TPrule_300));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_300;
_currn->_desc1 = (_TSPxFmtSpec) MkxFmtSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_300: root of subtree no. 1 can not be made a xFmtSpec node ", 0, _coordref);
_currn->_desc2 = (_TSPxFmtSpec) MkxFmtSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_300: root of subtree no. 2 can not be made a xFmtSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPxFmtSpec) MkxFmtSpec (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_300: root of subtree no. 3 can not be made a xFmtSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_300;
return ( (NODEPTR) _currn);
}/* Mkrule_300 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_301 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_301 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_301 _currn;
#ifdef __cplusplus
_currn = new _TPrule_301;
#else
_currn = (_TPPrule_301) TreeNodeAlloc (sizeof (struct _TPrule_301));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_301;
_currn->_desc1 = (_TSPxFmtSpec) MkxFmtSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_301: root of subtree no. 1 can not be made a xFmtSpec node ", 0, _coordref);
_currn->_desc2 = (_TSPxFmtSpec) MkxFmtSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_301: root of subtree no. 2 can not be made a xFmtSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPxFmtSpec) MkxFmtSpec (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_301: root of subtree no. 3 can not be made a xFmtSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_301;
return ( (NODEPTR) _currn);
}/* Mkrule_301 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_302 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_302 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_302 _currn;
#ifdef __cplusplus
_currn = new _TPrule_302;
#else
_currn = (_TPPrule_302) TreeNodeAlloc (sizeof (struct _TPrule_302));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_302;
_currn->_desc1 = (_TSPxFmtSpec) MkxFmtSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_302: root of subtree no. 1 can not be made a xFmtSpec node ", 0, _coordref);
_currn->_desc2 = (_TSPxFmtSpec) MkxFmtSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_302: root of subtree no. 2 can not be made a xFmtSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_302;
return ( (NODEPTR) _currn);
}/* Mkrule_302 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_303 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_303 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_303 _currn;
#ifdef __cplusplus
_currn = new _TPrule_303;
#else
_currn = (_TPPrule_303) TreeNodeAlloc (sizeof (struct _TPrule_303));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_303;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_303: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExternalNameList) MkxExternalNameList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_303: root of subtree no. 2 can not be made a xExternalNameList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_303;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_303 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_304 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_304 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_304 _currn;
#ifdef __cplusplus
_currn = new _TPrule_304;
#else
_currn = (_TPPrule_304) TreeNodeAlloc (sizeof (struct _TPrule_304));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_304;
_currn->_desc1 = (_TSPxExternalNameList) MkxExternalNameList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_304: root of subtree no. 1 can not be made a xExternalNameList node ", 0, _coordref);
_currn->_desc2 = (_TSPxExternalName) MkxExternalName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_304: root of subtree no. 2 can not be made a xExternalName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_304;
return ( (NODEPTR) _currn);
}/* Mkrule_304 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_305 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_305 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_305 _currn;
#ifdef __cplusplus
_currn = new _TPrule_305;
#else
_currn = (_TPPrule_305) TreeNodeAlloc (sizeof (struct _TPrule_305));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_305;
_currn->_desc1 = (_TSPxExternalName) MkxExternalName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_305: root of subtree no. 1 can not be made a xExternalName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_305;
return ( (NODEPTR) _currn);
}/* Mkrule_305 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_306 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_306 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_306 _currn;
#ifdef __cplusplus
_currn = new _TPrule_306;
#else
_currn = (_TPPrule_306) TreeNodeAlloc (sizeof (struct _TPrule_306));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_306;
_SETCOORD(_currn)
_TERMACT_rule_306;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_306 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_307 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_307 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_307 _currn;
#ifdef __cplusplus
_currn = new _TPrule_307;
#else
_currn = (_TPPrule_307) TreeNodeAlloc (sizeof (struct _TPrule_307));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_307;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_307: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxDefinedBinaryOp) MkxDefinedBinaryOp (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_307: root of subtree no. 2 can not be made a xDefinedBinaryOp node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_307: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_307;
return ( (NODEPTR) _currn);
}/* Mkrule_307 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_308 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_308 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_308 _currn;
#ifdef __cplusplus
_currn = new _TPrule_308;
#else
_currn = (_TPPrule_308) TreeNodeAlloc (sizeof (struct _TPrule_308));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_308;
_currn->_desc1 = (_TSPxObsoleteExecutionPartConstruct) MkxObsoleteExecutionPartConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_308: root of subtree no. 1 can not be made a xObsoleteExecutionPartConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_308;
return ( (NODEPTR) _currn);
}/* Mkrule_308 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_309 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_309 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_309 _currn;
#ifdef __cplusplus
_currn = new _TPrule_309;
#else
_currn = (_TPPrule_309) TreeNodeAlloc (sizeof (struct _TPrule_309));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_309;
_currn->_desc1 = (_TSPxProgramUnit) MkxProgramUnit (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_309: root of subtree no. 1 can not be made a xProgramUnit node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_309;
return ( (NODEPTR) _currn);
}/* Mkrule_309 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_310 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_310 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_310 _currn;
#ifdef __cplusplus
_currn = new _TPrule_310;
#else
_currn = (_TPPrule_310) TreeNodeAlloc (sizeof (struct _TPrule_310));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_310;
_currn->_desc1 = (_TSPxExecutableProgram) MkxExecutableProgram (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_310: root of subtree no. 1 can not be made a xExecutableProgram node ", 0, _coordref);
_currn->_desc2 = (_TSPxProgramUnit) MkxProgramUnit (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_310: root of subtree no. 2 can not be made a xProgramUnit node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_310;
return ( (NODEPTR) _currn);
}/* Mkrule_310 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_311 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_311 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_311 _currn;
#ifdef __cplusplus
_currn = new _TPrule_311;
#else
_currn = (_TPPrule_311) TreeNodeAlloc (sizeof (struct _TPrule_311));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_311;
_currn->_desc1 = (_TSPxWhereConstruct) MkxWhereConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_311: root of subtree no. 1 can not be made a xWhereConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_311;
return ( (NODEPTR) _currn);
}/* Mkrule_311 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_312 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_312 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_312 _currn;
#ifdef __cplusplus
_currn = new _TPrule_312;
#else
_currn = (_TPPrule_312) TreeNodeAlloc (sizeof (struct _TPrule_312));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_312;
_currn->_desc1 = (_TSPxIfConstruct) MkxIfConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_312: root of subtree no. 1 can not be made a xIfConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_312;
return ( (NODEPTR) _currn);
}/* Mkrule_312 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_313 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_313 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_313 _currn;
#ifdef __cplusplus
_currn = new _TPrule_313;
#else
_currn = (_TPPrule_313) TreeNodeAlloc (sizeof (struct _TPrule_313));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_313;
_currn->_desc1 = (_TSPxForallConstruct) MkxForallConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_313: root of subtree no. 1 can not be made a xForallConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_313;
return ( (NODEPTR) _currn);
}/* Mkrule_313 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_314 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_314 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_314 _currn;
#ifdef __cplusplus
_currn = new _TPrule_314;
#else
_currn = (_TPPrule_314) TreeNodeAlloc (sizeof (struct _TPrule_314));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_314;
_currn->_desc1 = (_TSPxDoConstruct) MkxDoConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_314: root of subtree no. 1 can not be made a xDoConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_314;
return ( (NODEPTR) _currn);
}/* Mkrule_314 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_315 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_315 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_315 _currn;
#ifdef __cplusplus
_currn = new _TPrule_315;
#else
_currn = (_TPPrule_315) TreeNodeAlloc (sizeof (struct _TPrule_315));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_315;
_currn->_desc1 = (_TSPxCaseConstruct) MkxCaseConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_315: root of subtree no. 1 can not be made a xCaseConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_315;
return ( (NODEPTR) _currn);
}/* Mkrule_315 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_316 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_316 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_316 _currn;
#ifdef __cplusplus
_currn = new _TPrule_316;
#else
_currn = (_TPPrule_316) TreeNodeAlloc (sizeof (struct _TPrule_316));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_316;
_currn->_desc1 = (_TSPxEquivalenceSetList) MkxEquivalenceSetList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_316: root of subtree no. 1 can not be made a xEquivalenceSetList node ", 0, _coordref);
_currn->_desc2 = (_TSPxEquivalenceSet) MkxEquivalenceSet (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_316: root of subtree no. 2 can not be made a xEquivalenceSet node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_316;
return ( (NODEPTR) _currn);
}/* Mkrule_316 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_317 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_317 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_317 _currn;
#ifdef __cplusplus
_currn = new _TPrule_317;
#else
_currn = (_TPPrule_317) TreeNodeAlloc (sizeof (struct _TPrule_317));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_317;
_currn->_desc1 = (_TSPxEquivalenceSet) MkxEquivalenceSet (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_317: root of subtree no. 1 can not be made a xEquivalenceSet node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_317;
return ( (NODEPTR) _currn);
}/* Mkrule_317 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_318 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_318 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_318 _currn;
#ifdef __cplusplus
_currn = new _TPrule_318;
#else
_currn = (_TPPrule_318) TreeNodeAlloc (sizeof (struct _TPrule_318));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_318;
_currn->_desc1 = (_TSPxEquivalenceObject) MkxEquivalenceObject (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_318: root of subtree no. 1 can not be made a xEquivalenceObject node ", 0, _coordref);
_currn->_desc2 = (_TSPxEquivalenceObjectList) MkxEquivalenceObjectList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_318: root of subtree no. 2 can not be made a xEquivalenceObjectList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_318;
return ( (NODEPTR) _currn);
}/* Mkrule_318 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_319 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_319 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_319 _currn;
#ifdef __cplusplus
_currn = new _TPrule_319;
#else
_currn = (_TPPrule_319) TreeNodeAlloc (sizeof (struct _TPrule_319));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_319;
_currn->_desc1 = (_TSPxEquivalenceObjectList) MkxEquivalenceObjectList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_319: root of subtree no. 1 can not be made a xEquivalenceObjectList node ", 0, _coordref);
_currn->_desc2 = (_TSPxEquivalenceObject) MkxEquivalenceObject (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_319: root of subtree no. 2 can not be made a xEquivalenceObject node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_319;
return ( (NODEPTR) _currn);
}/* Mkrule_319 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_320 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_320 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_320 _currn;
#ifdef __cplusplus
_currn = new _TPrule_320;
#else
_currn = (_TPPrule_320) TreeNodeAlloc (sizeof (struct _TPrule_320));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_320;
_currn->_desc1 = (_TSPxEquivalenceObject) MkxEquivalenceObject (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_320: root of subtree no. 1 can not be made a xEquivalenceObject node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_320;
return ( (NODEPTR) _currn);
}/* Mkrule_320 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_321 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_321 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_321 _currn;
#ifdef __cplusplus
_currn = new _TPrule_321;
#else
_currn = (_TPPrule_321) TreeNodeAlloc (sizeof (struct _TPrule_321));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_321;
_currn->_desc1 = (_TSPxVariable) MkxVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_321: root of subtree no. 1 can not be made a xVariable node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_321;
return ( (NODEPTR) _currn);
}/* Mkrule_321 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_322 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_322 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_322 _currn;
#ifdef __cplusplus
_currn = new _TPrule_322;
#else
_currn = (_TPPrule_322) TreeNodeAlloc (sizeof (struct _TPrule_322));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_322;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_322: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEntryName) MkxEntryName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_322: root of subtree no. 2 can not be made a xEntryName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_322;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_322 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_323 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_323 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_323 _currn;
#ifdef __cplusplus
_currn = new _TPrule_323;
#else
_currn = (_TPPrule_323) TreeNodeAlloc (sizeof (struct _TPrule_323));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_323;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_323: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEntryName) MkxEntryName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_323: root of subtree no. 2 can not be made a xEntryName node ", 0, _coordref);
_currn->_desc3 = (_TSPxFormalParameterList) MkxFormalParameterList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_323: root of subtree no. 3 can not be made a xFormalParameterList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_323;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_323 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_324 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, int _TERM1)
#else
NODEPTR Mkrule_324 (_coordref,_desc1,_desc2,_desc3,_desc4, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	int _TERM1;
#endif
{	_TPPrule_324 _currn;
#ifdef __cplusplus
_currn = new _TPrule_324;
#else
_currn = (_TPPrule_324) TreeNodeAlloc (sizeof (struct _TPrule_324));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_324;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_324: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEntryName) MkxEntryName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_324: root of subtree no. 2 can not be made a xEntryName node ", 0, _coordref);
_currn->_desc3 = (_TSPxFormalParameterList) MkxFormalParameterList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_324: root of subtree no. 3 can not be made a xFormalParameterList node ", 0, _coordref);
_currn->_desc4 = (_TSPxName) MkxName (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_324: root of subtree no. 4 can not be made a xName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_324;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_324 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_325 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_325 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_325 _currn;
#ifdef __cplusplus
_currn = new _TPrule_325;
#else
_currn = (_TPPrule_325) TreeNodeAlloc (sizeof (struct _TPrule_325));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_325;
_SETCOORD(_currn)
_TERMACT_rule_325;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_325 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_326 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_326 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_326 _currn;
#ifdef __cplusplus
_currn = new _TPrule_326;
#else
_currn = (_TPPrule_326) TreeNodeAlloc (sizeof (struct _TPrule_326));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_326;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_326: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxTypeName) MkxTypeName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_326: root of subtree no. 2 can not be made a xTypeName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_326;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_326 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_327 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_327 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_327 _currn;
#ifdef __cplusplus
_currn = new _TPrule_327;
#else
_currn = (_TPPrule_327) TreeNodeAlloc (sizeof (struct _TPrule_327));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_327;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_327: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_327;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_327 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_328 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_328 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_328 _currn;
#ifdef __cplusplus
_currn = new _TPrule_328;
#else
_currn = (_TPPrule_328) TreeNodeAlloc (sizeof (struct _TPrule_328));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_328;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_328: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxTypeName) MkxTypeName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_328: root of subtree no. 2 can not be made a xTypeName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_328;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_328 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_329 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_329 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_329 _currn;
#ifdef __cplusplus
_currn = new _TPrule_329;
#else
_currn = (_TPPrule_329) TreeNodeAlloc (sizeof (struct _TPrule_329));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_329;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_329: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_329;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_329 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_330 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_330 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_330 _currn;
#ifdef __cplusplus
_currn = new _TPrule_330;
#else
_currn = (_TPPrule_330) TreeNodeAlloc (sizeof (struct _TPrule_330));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_330;
_SETCOORD(_currn)
_TERMACT_rule_330;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_330 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_331 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_331 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_331 _currn;
#ifdef __cplusplus
_currn = new _TPrule_331;
#else
_currn = (_TPPrule_331) TreeNodeAlloc (sizeof (struct _TPrule_331));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_331;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_331: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_331: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_331;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_331 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_332 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_332 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_332 _currn;
#ifdef __cplusplus
_currn = new _TPrule_332;
#else
_currn = (_TPPrule_332) TreeNodeAlloc (sizeof (struct _TPrule_332));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_332;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_332: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_332;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_332 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_333 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_333 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_333 _currn;
#ifdef __cplusplus
_currn = new _TPrule_333;
#else
_currn = (_TPPrule_333) TreeNodeAlloc (sizeof (struct _TPrule_333));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_333;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_333: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_333: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_333;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_333 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_334 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_334 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_334 _currn;
#ifdef __cplusplus
_currn = new _TPrule_334;
#else
_currn = (_TPPrule_334) TreeNodeAlloc (sizeof (struct _TPrule_334));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_334;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_334: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_334;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_334 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_335 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_335 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_335 _currn;
#ifdef __cplusplus
_currn = new _TPrule_335;
#else
_currn = (_TPPrule_335) TreeNodeAlloc (sizeof (struct _TPrule_335));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_335;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_335: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_335: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_335;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_335 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_336 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_336 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_336 _currn;
#ifdef __cplusplus
_currn = new _TPrule_336;
#else
_currn = (_TPPrule_336) TreeNodeAlloc (sizeof (struct _TPrule_336));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_336;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_336: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_336;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_336 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_337 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_337 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_337 _currn;
#ifdef __cplusplus
_currn = new _TPrule_337;
#else
_currn = (_TPPrule_337) TreeNodeAlloc (sizeof (struct _TPrule_337));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_337;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_337: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_337: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_337;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_337 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_338 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_338 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_338 _currn;
#ifdef __cplusplus
_currn = new _TPrule_338;
#else
_currn = (_TPPrule_338) TreeNodeAlloc (sizeof (struct _TPrule_338));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_338;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_338: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_338;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_338 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_339 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_339 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_339 _currn;
#ifdef __cplusplus
_currn = new _TPrule_339;
#else
_currn = (_TPPrule_339) TreeNodeAlloc (sizeof (struct _TPrule_339));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_339;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_339: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_339;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_339 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_340 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_340 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_340 _currn;
#ifdef __cplusplus
_currn = new _TPrule_340;
#else
_currn = (_TPPrule_340) TreeNodeAlloc (sizeof (struct _TPrule_340));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_340;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_340: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_340: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_340;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_340 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_341 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_341 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_341 _currn;
#ifdef __cplusplus
_currn = new _TPrule_341;
#else
_currn = (_TPPrule_341) TreeNodeAlloc (sizeof (struct _TPrule_341));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_341;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_341: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_341;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_341 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_342 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_342 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_342 _currn;
#ifdef __cplusplus
_currn = new _TPrule_342;
#else
_currn = (_TPPrule_342) TreeNodeAlloc (sizeof (struct _TPrule_342));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_342;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_342: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_342: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_342;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_342 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_343 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_343 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_343 _currn;
#ifdef __cplusplus
_currn = new _TPrule_343;
#else
_currn = (_TPPrule_343) TreeNodeAlloc (sizeof (struct _TPrule_343));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_343;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_343: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_343;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_343 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_344 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_344 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_344 _currn;
#ifdef __cplusplus
_currn = new _TPrule_344;
#else
_currn = (_TPPrule_344) TreeNodeAlloc (sizeof (struct _TPrule_344));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_344;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_344: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndWhereStmt) MkxEndWhereStmt (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_344: root of subtree no. 2 can not be made a xEndWhereStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_344;
return ( (NODEPTR) _currn);
}/* Mkrule_344 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_345 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_345 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_345 _currn;
#ifdef __cplusplus
_currn = new _TPrule_345;
#else
_currn = (_TPPrule_345) TreeNodeAlloc (sizeof (struct _TPrule_345));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_345;
_currn->_desc1 = (_TSPxEndWhereStmt) MkxEndWhereStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_345: root of subtree no. 1 can not be made a xEndWhereStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_345;
return ( (NODEPTR) _currn);
}/* Mkrule_345 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_346 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_346 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_346 _currn;
#ifdef __cplusplus
_currn = new _TPrule_346;
#else
_currn = (_TPPrule_346) TreeNodeAlloc (sizeof (struct _TPrule_346));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_346;
_currn->_desc1 = (_TSPxStmt) MkxStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_346: root of subtree no. 1 can not be made a xStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxElsewherePart) MkxElsewherePart (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_346: root of subtree no. 2 can not be made a xElsewherePart node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_346;
return ( (NODEPTR) _currn);
}/* Mkrule_346 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_347 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_347 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_347 _currn;
#ifdef __cplusplus
_currn = new _TPrule_347;
#else
_currn = (_TPPrule_347) TreeNodeAlloc (sizeof (struct _TPrule_347));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_347;
_currn->_desc1 = (_TSPxEndIfStmt) MkxEndIfStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_347: root of subtree no. 1 can not be made a xEndIfStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_347;
return ( (NODEPTR) _currn);
}/* Mkrule_347 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_348 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_348 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_348 _currn;
#ifdef __cplusplus
_currn = new _TPrule_348;
#else
_currn = (_TPPrule_348) TreeNodeAlloc (sizeof (struct _TPrule_348));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_348;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_348: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndIfStmt) MkxEndIfStmt (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_348: root of subtree no. 2 can not be made a xEndIfStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_348;
return ( (NODEPTR) _currn);
}/* Mkrule_348 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_349 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_349 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_349 _currn;
#ifdef __cplusplus
_currn = new _TPrule_349;
#else
_currn = (_TPPrule_349) TreeNodeAlloc (sizeof (struct _TPrule_349));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_349;
_currn->_desc1 = (_TSPxStmt) MkxStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_349: root of subtree no. 1 can not be made a xStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxThenPart) MkxThenPart (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_349: root of subtree no. 2 can not be made a xThenPart node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_349;
return ( (NODEPTR) _currn);
}/* Mkrule_349 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_350 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_350 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_350 _currn;
#ifdef __cplusplus
_currn = new _TPrule_350;
#else
_currn = (_TPPrule_350) TreeNodeAlloc (sizeof (struct _TPrule_350));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_350;
_currn->_desc1 = (_TSPxStmt) MkxStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_350: root of subtree no. 1 can not be made a xStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxElsePart) MkxElsePart (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_350: root of subtree no. 2 can not be made a xElsePart node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_350;
return ( (NODEPTR) _currn);
}/* Mkrule_350 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_351 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_351 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_351 _currn;
#ifdef __cplusplus
_currn = new _TPrule_351;
#else
_currn = (_TPPrule_351) TreeNodeAlloc (sizeof (struct _TPrule_351));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_351;
_SETCOORD(_currn)
_TERMACT_rule_351;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xScon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_351 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_352 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_352 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_352 _currn;
#ifdef __cplusplus
_currn = new _TPrule_352;
#else
_currn = (_TPPrule_352) TreeNodeAlloc (sizeof (struct _TPrule_352));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_352;
_SETCOORD(_currn)
_TERMACT_rule_352;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_352 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_353 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_353 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_353 _currn;
#ifdef __cplusplus
_currn = new _TPrule_353;
#else
_currn = (_TPPrule_353) TreeNodeAlloc (sizeof (struct _TPrule_353));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_353;
_SETCOORD(_currn)
_TERMACT_rule_353;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xHcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_353 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_354 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_354 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_354 _currn;
#ifdef __cplusplus
_currn = new _TPrule_354;
#else
_currn = (_TPPrule_354) TreeNodeAlloc (sizeof (struct _TPrule_354));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_354;
_SETCOORD(_currn)
_TERMACT_rule_354;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xFcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_354 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_355 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_355 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_355 _currn;
#ifdef __cplusplus
_currn = new _TPrule_355;
#else
_currn = (_TPPrule_355) TreeNodeAlloc (sizeof (struct _TPrule_355));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_355;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_355: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_355;
return ( (NODEPTR) _currn);
}/* Mkrule_355 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_356 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_356 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_356 _currn;
#ifdef __cplusplus
_currn = new _TPrule_356;
#else
_currn = (_TPPrule_356) TreeNodeAlloc (sizeof (struct _TPrule_356));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_356;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_356: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_356;
return ( (NODEPTR) _currn);
}/* Mkrule_356 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_357 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_357 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_357 _currn;
#ifdef __cplusplus
_currn = new _TPrule_357;
#else
_currn = (_TPPrule_357) TreeNodeAlloc (sizeof (struct _TPrule_357));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_357;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_357: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_currn->_desc2 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_357: root of subtree no. 2 can not be made a xSectionSubscriptList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_357;
return ( (NODEPTR) _currn);
}/* Mkrule_357 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_358 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_358 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_358 _currn;
#ifdef __cplusplus
_currn = new _TPrule_358;
#else
_currn = (_TPPrule_358) TreeNodeAlloc (sizeof (struct _TPrule_358));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_358;
_currn->_desc1 = (_TSPxPrivateSequenceStmt) MkxPrivateSequenceStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_358: root of subtree no. 1 can not be made a xPrivateSequenceStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_358;
return ( (NODEPTR) _currn);
}/* Mkrule_358 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_359 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_359 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_359 _currn;
#ifdef __cplusplus
_currn = new _TPrule_359;
#else
_currn = (_TPPrule_359) TreeNodeAlloc (sizeof (struct _TPrule_359));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_359;
_currn->_desc1 = (_TSPxComponentDefStmt) MkxComponentDefStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_359: root of subtree no. 1 can not be made a xComponentDefStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_359;
return ( (NODEPTR) _currn);
}/* Mkrule_359 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_360 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_360 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_360 _currn;
#ifdef __cplusplus
_currn = new _TPrule_360;
#else
_currn = (_TPPrule_360) TreeNodeAlloc (sizeof (struct _TPrule_360));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_360;
_currn->_desc1 = (_TSPxDerivedTypeBodyConstruct) MkxDerivedTypeBodyConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_360: root of subtree no. 1 can not be made a xDerivedTypeBodyConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_360;
return ( (NODEPTR) _currn);
}/* Mkrule_360 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_361 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_361 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_361 _currn;
#ifdef __cplusplus
_currn = new _TPrule_361;
#else
_currn = (_TPPrule_361) TreeNodeAlloc (sizeof (struct _TPrule_361));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_361;
_currn->_desc1 = (_TSPxDerivedTypeBody) MkxDerivedTypeBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_361: root of subtree no. 1 can not be made a xDerivedTypeBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxDerivedTypeBodyConstruct) MkxDerivedTypeBodyConstruct (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_361: root of subtree no. 2 can not be made a xDerivedTypeBodyConstruct node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_361;
return ( (NODEPTR) _currn);
}/* Mkrule_361 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_362 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_362 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_362 _currn;
#ifdef __cplusplus
_currn = new _TPrule_362;
#else
_currn = (_TPPrule_362) TreeNodeAlloc (sizeof (struct _TPrule_362));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_362;
_SETCOORD(_currn)
_TERMACT_rule_362;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xDop", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_362 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_363 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_363 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_363 _currn;
#ifdef __cplusplus
_currn = new _TPrule_363;
#else
_currn = (_TPPrule_363) TreeNodeAlloc (sizeof (struct _TPrule_363));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_363;
_currn->_desc1 = (_TSPxUnOp) MkxUnOp (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_363: root of subtree no. 1 can not be made a xUnOp node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_363;
return ( (NODEPTR) _currn);
}/* Mkrule_363 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_364 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_364 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_364 _currn;
#ifdef __cplusplus
_currn = new _TPrule_364;
#else
_currn = (_TPPrule_364) TreeNodeAlloc (sizeof (struct _TPrule_364));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_364;
_SETCOORD(_currn)
_TERMACT_rule_364;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xDop", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_364 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_365 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_365 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_365 _currn;
#ifdef __cplusplus
_currn = new _TPrule_365;
#else
_currn = (_TPPrule_365) TreeNodeAlloc (sizeof (struct _TPrule_365));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_365;
_currn->_desc1 = (_TSPxBinOp) MkxBinOp (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_365: root of subtree no. 1 can not be made a xBinOp node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_365;
return ( (NODEPTR) _currn);
}/* Mkrule_365 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_366 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_366 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_366 _currn;
#ifdef __cplusplus
_currn = new _TPrule_366;
#else
_currn = (_TPPrule_366) TreeNodeAlloc (sizeof (struct _TPrule_366));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_366;
_SETCOORD(_currn)
_TERMACT_rule_366;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xDop", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_366 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_367 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_367 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_367 _currn;
#ifdef __cplusplus
_currn = new _TPrule_367;
#else
_currn = (_TPPrule_367) TreeNodeAlloc (sizeof (struct _TPrule_367));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_367;
_currn->_desc1 = (_TSPxStmt) MkxStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_367: root of subtree no. 1 can not be made a xStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_367;
return ( (NODEPTR) _currn);
}/* Mkrule_367 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_368 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_368 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_368 _currn;
#ifdef __cplusplus
_currn = new _TPrule_368;
#else
_currn = (_TPPrule_368) TreeNodeAlloc (sizeof (struct _TPrule_368));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_368;
_currn->_desc1 = (_TSPxInterfaceBlock) MkxInterfaceBlock (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_368: root of subtree no. 1 can not be made a xInterfaceBlock node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_368;
return ( (NODEPTR) _currn);
}/* Mkrule_368 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_369 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_369 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_369 _currn;
#ifdef __cplusplus
_currn = new _TPrule_369;
#else
_currn = (_TPPrule_369) TreeNodeAlloc (sizeof (struct _TPrule_369));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_369;
_currn->_desc1 = (_TSPxDerivedTypeDef) MkxDerivedTypeDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_369: root of subtree no. 1 can not be made a xDerivedTypeDef node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_369;
return ( (NODEPTR) _currn);
}/* Mkrule_369 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_370 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, NODEPTR _desc5)
#else
NODEPTR Mkrule_370 (_coordref,_desc1,_desc2,_desc3,_desc4,_desc5)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	NODEPTR _desc5;
#endif
{	_TPPrule_370 _currn;
#ifdef __cplusplus
_currn = new _TPrule_370;
#else
_currn = (_TPPrule_370) TreeNodeAlloc (sizeof (struct _TPrule_370));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_370;
_currn->_desc1 = (_TSPxDataIDoObjectList) MkxDataIDoObjectList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_370: root of subtree no. 1 can not be made a xDataIDoObjectList node ", 0, _coordref);
_currn->_desc2 = (_TSPxImpliedDoVariable) MkxImpliedDoVariable (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_370: root of subtree no. 2 can not be made a xImpliedDoVariable node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_370: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_370: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_currn->_desc5 = (_TSPxExpr) MkxExpr (_coordref, _desc5);	
if (((NODEPTR)_currn->_desc5) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_370: root of subtree no. 5 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_370;
return ( (NODEPTR) _currn);
}/* Mkrule_370 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_371 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4)
#else
NODEPTR Mkrule_371 (_coordref,_desc1,_desc2,_desc3,_desc4)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
#endif
{	_TPPrule_371 _currn;
#ifdef __cplusplus
_currn = new _TPrule_371;
#else
_currn = (_TPPrule_371) TreeNodeAlloc (sizeof (struct _TPrule_371));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_371;
_currn->_desc1 = (_TSPxDataIDoObjectList) MkxDataIDoObjectList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_371: root of subtree no. 1 can not be made a xDataIDoObjectList node ", 0, _coordref);
_currn->_desc2 = (_TSPxImpliedDoVariable) MkxImpliedDoVariable (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_371: root of subtree no. 2 can not be made a xImpliedDoVariable node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_371: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_371: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_371;
return ( (NODEPTR) _currn);
}/* Mkrule_371 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_372 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_372 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_372 _currn;
#ifdef __cplusplus
_currn = new _TPrule_372;
#else
_currn = (_TPPrule_372) TreeNodeAlloc (sizeof (struct _TPrule_372));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_372;
_currn->_desc1 = (_TSPxDataIDoObjectList) MkxDataIDoObjectList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_372: root of subtree no. 1 can not be made a xDataIDoObjectList node ", 0, _coordref);
_currn->_desc2 = (_TSPxDataStmtObject) MkxDataStmtObject (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_372: root of subtree no. 2 can not be made a xDataStmtObject node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_372;
return ( (NODEPTR) _currn);
}/* Mkrule_372 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_373 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_373 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_373 _currn;
#ifdef __cplusplus
_currn = new _TPrule_373;
#else
_currn = (_TPPrule_373) TreeNodeAlloc (sizeof (struct _TPrule_373));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_373;
_currn->_desc1 = (_TSPxDataStmtObject) MkxDataStmtObject (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_373: root of subtree no. 1 can not be made a xDataStmtObject node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_373;
return ( (NODEPTR) _currn);
}/* Mkrule_373 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_374 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_374 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_374 _currn;
#ifdef __cplusplus
_currn = new _TPrule_374;
#else
_currn = (_TPPrule_374) TreeNodeAlloc (sizeof (struct _TPrule_374));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_374;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_374: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_374;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_374 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_375 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_375 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_375 _currn;
#ifdef __cplusplus
_currn = new _TPrule_375;
#else
_currn = (_TPPrule_375) TreeNodeAlloc (sizeof (struct _TPrule_375));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_375;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_375: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_375;
return ( (NODEPTR) _currn);
}/* Mkrule_375 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_376 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_376 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_376 _currn;
#ifdef __cplusplus
_currn = new _TPrule_376;
#else
_currn = (_TPPrule_376) TreeNodeAlloc (sizeof (struct _TPrule_376));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_376;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_376: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_376;
return ( (NODEPTR) _currn);
}/* Mkrule_376 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_377 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_377 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_377 _currn;
#ifdef __cplusplus
_currn = new _TPrule_377;
#else
_currn = (_TPPrule_377) TreeNodeAlloc (sizeof (struct _TPrule_377));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_377;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_377: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_377;
return ( (NODEPTR) _currn);
}/* Mkrule_377 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_378 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_378 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_378 _currn;
#ifdef __cplusplus
_currn = new _TPrule_378;
#else
_currn = (_TPPrule_378) TreeNodeAlloc (sizeof (struct _TPrule_378));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_378;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_378: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_378;
return ( (NODEPTR) _currn);
}/* Mkrule_378 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_379 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_379 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_379 _currn;
#ifdef __cplusplus
_currn = new _TPrule_379;
#else
_currn = (_TPPrule_379) TreeNodeAlloc (sizeof (struct _TPrule_379));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_379;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_379: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_379;
return ( (NODEPTR) _currn);
}/* Mkrule_379 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_380 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_380 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_380 _currn;
#ifdef __cplusplus
_currn = new _TPrule_380;
#else
_currn = (_TPPrule_380) TreeNodeAlloc (sizeof (struct _TPrule_380));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_380;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_380: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_380;
return ( (NODEPTR) _currn);
}/* Mkrule_380 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_381 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_381 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_381 _currn;
#ifdef __cplusplus
_currn = new _TPrule_381;
#else
_currn = (_TPPrule_381) TreeNodeAlloc (sizeof (struct _TPrule_381));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_381;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_381: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_381;
return ( (NODEPTR) _currn);
}/* Mkrule_381 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_382 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_382 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_382 _currn;
#ifdef __cplusplus
_currn = new _TPrule_382;
#else
_currn = (_TPPrule_382) TreeNodeAlloc (sizeof (struct _TPrule_382));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_382;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_382: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_382;
return ( (NODEPTR) _currn);
}/* Mkrule_382 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_383 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_383 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_383 _currn;
#ifdef __cplusplus
_currn = new _TPrule_383;
#else
_currn = (_TPPrule_383) TreeNodeAlloc (sizeof (struct _TPrule_383));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_383;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_383: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_383;
return ( (NODEPTR) _currn);
}/* Mkrule_383 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_384 (POSITION *_coordref)
#else
NODEPTR Mkrule_384 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_384 _currn;
#ifdef __cplusplus
_currn = new _TPrule_384;
#else
_currn = (_TPPrule_384) TreeNodeAlloc (sizeof (struct _TPrule_384));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_384;
_SETCOORD(_currn)
_TERMACT_rule_384;
return ( (NODEPTR) _currn);
}/* Mkrule_384 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_385 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_385 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_385 _currn;
#ifdef __cplusplus
_currn = new _TPrule_385;
#else
_currn = (_TPPrule_385) TreeNodeAlloc (sizeof (struct _TPrule_385));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_385;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_385: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_385;
return ( (NODEPTR) _currn);
}/* Mkrule_385 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_386 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_386 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_386 _currn;
#ifdef __cplusplus
_currn = new _TPrule_386;
#else
_currn = (_TPPrule_386) TreeNodeAlloc (sizeof (struct _TPrule_386));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_386;
_currn->_desc1 = (_TSPxComponentDeclList) MkxComponentDeclList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_386: root of subtree no. 1 can not be made a xComponentDeclList node ", 0, _coordref);
_currn->_desc2 = (_TSPxComponentDecl) MkxComponentDecl (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_386: root of subtree no. 2 can not be made a xComponentDecl node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_386;
return ( (NODEPTR) _currn);
}/* Mkrule_386 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_387 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_387 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_387 _currn;
#ifdef __cplusplus
_currn = new _TPrule_387;
#else
_currn = (_TPPrule_387) TreeNodeAlloc (sizeof (struct _TPrule_387));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_387;
_currn->_desc1 = (_TSPxComponentDecl) MkxComponentDecl (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_387: root of subtree no. 1 can not be made a xComponentDecl node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_387;
return ( (NODEPTR) _currn);
}/* Mkrule_387 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_388 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_388 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_388 _currn;
#ifdef __cplusplus
_currn = new _TPrule_388;
#else
_currn = (_TPPrule_388) TreeNodeAlloc (sizeof (struct _TPrule_388));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_388;
_currn->_desc1 = (_TSPxComponentName) MkxComponentName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_388: root of subtree no. 1 can not be made a xComponentName node ", 0, _coordref);
_currn->_desc2 = (_TSPxComponentInitialization) MkxComponentInitialization (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_388: root of subtree no. 2 can not be made a xComponentInitialization node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_388;
return ( (NODEPTR) _currn);
}/* Mkrule_388 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_389 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_389 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_389 _currn;
#ifdef __cplusplus
_currn = new _TPrule_389;
#else
_currn = (_TPPrule_389) TreeNodeAlloc (sizeof (struct _TPrule_389));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_389;
_currn->_desc1 = (_TSPxComponentName) MkxComponentName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_389: root of subtree no. 1 can not be made a xComponentName node ", 0, _coordref);
_currn->_desc2 = (_TSPxCharLength) MkxCharLength (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_389: root of subtree no. 2 can not be made a xCharLength node ", 0, _coordref);
_currn->_desc3 = (_TSPxComponentInitialization) MkxComponentInitialization (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_389: root of subtree no. 3 can not be made a xComponentInitialization node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_389;
return ( (NODEPTR) _currn);
}/* Mkrule_389 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_390 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_390 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_390 _currn;
#ifdef __cplusplus
_currn = new _TPrule_390;
#else
_currn = (_TPPrule_390) TreeNodeAlloc (sizeof (struct _TPrule_390));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_390;
_currn->_desc1 = (_TSPxComponentAttrSpecList) MkxComponentAttrSpecList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_390: root of subtree no. 1 can not be made a xComponentAttrSpecList node ", 0, _coordref);
_currn->_desc2 = (_TSPxComponentAttrSpec) MkxComponentAttrSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_390: root of subtree no. 2 can not be made a xComponentAttrSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_390;
return ( (NODEPTR) _currn);
}/* Mkrule_390 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_391 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_391 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_391 _currn;
#ifdef __cplusplus
_currn = new _TPrule_391;
#else
_currn = (_TPPrule_391) TreeNodeAlloc (sizeof (struct _TPrule_391));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_391;
_currn->_desc1 = (_TSPxComponentAttrSpec) MkxComponentAttrSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_391: root of subtree no. 1 can not be made a xComponentAttrSpec node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_391;
return ( (NODEPTR) _currn);
}/* Mkrule_391 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_392 (POSITION *_coordref)
#else
NODEPTR Mkrule_392 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_392 _currn;
#ifdef __cplusplus
_currn = new _TPrule_392;
#else
_currn = (_TPPrule_392) TreeNodeAlloc (sizeof (struct _TPrule_392));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_392;
_SETCOORD(_currn)
_TERMACT_rule_392;
return ( (NODEPTR) _currn);
}/* Mkrule_392 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_393 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_393 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_393 _currn;
#ifdef __cplusplus
_currn = new _TPrule_393;
#else
_currn = (_TPPrule_393) TreeNodeAlloc (sizeof (struct _TPrule_393));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_393;
_currn->_desc1 = (_TSPxDataRef) MkxDataRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_393: root of subtree no. 1 can not be made a xDataRef node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_393;
return ( (NODEPTR) _currn);
}/* Mkrule_393 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_394 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_394 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_394 _currn;
#ifdef __cplusplus
_currn = new _TPrule_394;
#else
_currn = (_TPPrule_394) TreeNodeAlloc (sizeof (struct _TPrule_394));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_394;
_currn->_desc1 = (_TSPxDataRef) MkxDataRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_394: root of subtree no. 1 can not be made a xDataRef node ", 0, _coordref);
_currn->_desc2 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_394: root of subtree no. 2 can not be made a xSectionSubscriptList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_394;
return ( (NODEPTR) _currn);
}/* Mkrule_394 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_395 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_395 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_395 _currn;
#ifdef __cplusplus
_currn = new _TPrule_395;
#else
_currn = (_TPPrule_395) TreeNodeAlloc (sizeof (struct _TPrule_395));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_395;
_currn->_desc1 = (_TSPxDataRef) MkxDataRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_395: root of subtree no. 1 can not be made a xDataRef node ", 0, _coordref);
_currn->_desc2 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_395: root of subtree no. 2 can not be made a xSectionSubscriptList node ", 0, _coordref);
_currn->_desc3 = (_TSPxSubstringRange) MkxSubstringRange (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_395: root of subtree no. 3 can not be made a xSubstringRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_395;
return ( (NODEPTR) _currn);
}/* Mkrule_395 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_396 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_396 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_396 _currn;
#ifdef __cplusplus
_currn = new _TPrule_396;
#else
_currn = (_TPPrule_396) TreeNodeAlloc (sizeof (struct _TPrule_396));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_396;
_currn->_desc1 = (_TSPxVariableName) MkxVariableName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_396: root of subtree no. 1 can not be made a xVariableName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_396;
return ( (NODEPTR) _currn);
}/* Mkrule_396 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_397 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_397 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_397 _currn;
#ifdef __cplusplus
_currn = new _TPrule_397;
#else
_currn = (_TPPrule_397) TreeNodeAlloc (sizeof (struct _TPrule_397));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_397;
_currn->_desc1 = (_TSPxArrayDeclarator) MkxArrayDeclarator (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_397: root of subtree no. 1 can not be made a xArrayDeclarator node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_397;
return ( (NODEPTR) _currn);
}/* Mkrule_397 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_398 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_398 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_398 _currn;
#ifdef __cplusplus
_currn = new _TPrule_398;
#else
_currn = (_TPPrule_398) TreeNodeAlloc (sizeof (struct _TPrule_398));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_398;
_SETCOORD(_currn)
_TERMACT_rule_398;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_398 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_399 (POSITION *_coordref)
#else
NODEPTR Mkrule_399 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_399 _currn;
#ifdef __cplusplus
_currn = new _TPrule_399;
#else
_currn = (_TPPrule_399) TreeNodeAlloc (sizeof (struct _TPrule_399));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_399;
_SETCOORD(_currn)
_TERMACT_rule_399;
return ( (NODEPTR) _currn);
}/* Mkrule_399 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_400 (POSITION *_coordref)
#else
NODEPTR Mkrule_400 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_400 _currn;
#ifdef __cplusplus
_currn = new _TPrule_400;
#else
_currn = (_TPPrule_400) TreeNodeAlloc (sizeof (struct _TPrule_400));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_400;
_SETCOORD(_currn)
_TERMACT_rule_400;
return ( (NODEPTR) _currn);
}/* Mkrule_400 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_401 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_401 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_401 _currn;
#ifdef __cplusplus
_currn = new _TPrule_401;
#else
_currn = (_TPPrule_401) TreeNodeAlloc (sizeof (struct _TPrule_401));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_401;
_currn->_desc1 = (_TSPxCommonBlockObject) MkxCommonBlockObject (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_401: root of subtree no. 1 can not be made a xCommonBlockObject node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_401;
return ( (NODEPTR) _currn);
}/* Mkrule_401 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_402 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_402 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_402 _currn;
#ifdef __cplusplus
_currn = new _TPrule_402;
#else
_currn = (_TPPrule_402) TreeNodeAlloc (sizeof (struct _TPrule_402));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_402;
_currn->_desc1 = (_TSPxComlist) MkxComlist (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_402: root of subtree no. 1 can not be made a xComlist node ", 0, _coordref);
_currn->_desc2 = (_TSPxComblock) MkxComblock (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_402: root of subtree no. 2 can not be made a xComblock node ", 0, _coordref);
_currn->_desc3 = (_TSPxCommonBlockObject) MkxCommonBlockObject (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_402: root of subtree no. 3 can not be made a xCommonBlockObject node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_402;
return ( (NODEPTR) _currn);
}/* Mkrule_402 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_403 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_403 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_403 _currn;
#ifdef __cplusplus
_currn = new _TPrule_403;
#else
_currn = (_TPPrule_403) TreeNodeAlloc (sizeof (struct _TPrule_403));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_403;
_currn->_desc1 = (_TSPxComlist) MkxComlist (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_403: root of subtree no. 1 can not be made a xComlist node ", 0, _coordref);
_currn->_desc2 = (_TSPxCommonBlockObject) MkxCommonBlockObject (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_403: root of subtree no. 2 can not be made a xCommonBlockObject node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_403;
return ( (NODEPTR) _currn);
}/* Mkrule_403 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_404 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_404 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_404 _currn;
#ifdef __cplusplus
_currn = new _TPrule_404;
#else
_currn = (_TPPrule_404) TreeNodeAlloc (sizeof (struct _TPrule_404));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_404;
_currn->_desc1 = (_TSPxComlist) MkxComlist (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_404: root of subtree no. 1 can not be made a xComlist node ", 0, _coordref);
_currn->_desc2 = (_TSPxComblock) MkxComblock (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_404: root of subtree no. 2 can not be made a xComblock node ", 0, _coordref);
_currn->_desc3 = (_TSPxCommonBlockObject) MkxCommonBlockObject (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_404: root of subtree no. 3 can not be made a xCommonBlockObject node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_404;
return ( (NODEPTR) _currn);
}/* Mkrule_404 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_405 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_405 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_405 _currn;
#ifdef __cplusplus
_currn = new _TPrule_405;
#else
_currn = (_TPPrule_405) TreeNodeAlloc (sizeof (struct _TPrule_405));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_405;
_currn->_desc1 = (_TSPxComblock) MkxComblock (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_405: root of subtree no. 1 can not be made a xComblock node ", 0, _coordref);
_currn->_desc2 = (_TSPxCommonBlockObject) MkxCommonBlockObject (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_405: root of subtree no. 2 can not be made a xCommonBlockObject node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_405;
return ( (NODEPTR) _currn);
}/* Mkrule_405 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_406 (POSITION *_coordref)
#else
NODEPTR Mkrule_406 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_406 _currn;
#ifdef __cplusplus
_currn = new _TPrule_406;
#else
_currn = (_TPPrule_406) TreeNodeAlloc (sizeof (struct _TPrule_406));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_406;
_SETCOORD(_currn)
_TERMACT_rule_406;
return ( (NODEPTR) _currn);
}/* Mkrule_406 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_407 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_407 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_407 _currn;
#ifdef __cplusplus
_currn = new _TPrule_407;
#else
_currn = (_TPPrule_407) TreeNodeAlloc (sizeof (struct _TPrule_407));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_407;
_currn->_desc1 = (_TSPxUnitIdentifier) MkxUnitIdentifier (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_407: root of subtree no. 1 can not be made a xUnitIdentifier node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_407;
return ( (NODEPTR) _currn);
}/* Mkrule_407 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_408 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_408 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_408 _currn;
#ifdef __cplusplus
_currn = new _TPrule_408;
#else
_currn = (_TPPrule_408) TreeNodeAlloc (sizeof (struct _TPrule_408));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_408;
_currn->_desc1 = (_TSPxIoControlSpecList) MkxIoControlSpecList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_408: root of subtree no. 1 can not be made a xIoControlSpecList node ", 0, _coordref);
_currn->_desc2 = (_TSPxIoControlSpec) MkxIoControlSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_408: root of subtree no. 2 can not be made a xIoControlSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_408;
return ( (NODEPTR) _currn);
}/* Mkrule_408 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_409 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_409 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_409 _currn;
#ifdef __cplusplus
_currn = new _TPrule_409;
#else
_currn = (_TPPrule_409) TreeNodeAlloc (sizeof (struct _TPrule_409));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_409;
_currn->_desc1 = (_TSPxIoControlSpec) MkxIoControlSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_409: root of subtree no. 1 can not be made a xIoControlSpec node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_409;
return ( (NODEPTR) _currn);
}/* Mkrule_409 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_410 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_410 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_410 _currn;
#ifdef __cplusplus
_currn = new _TPrule_410;
#else
_currn = (_TPPrule_410) TreeNodeAlloc (sizeof (struct _TPrule_410));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_410;
_currn->_desc1 = (_TSPxUnitIdentifier) MkxUnitIdentifier (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_410: root of subtree no. 1 can not be made a xUnitIdentifier node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_410;
return ( (NODEPTR) _currn);
}/* Mkrule_410 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_411 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_411 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_411 _currn;
#ifdef __cplusplus
_currn = new _TPrule_411;
#else
_currn = (_TPPrule_411) TreeNodeAlloc (sizeof (struct _TPrule_411));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_411;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_411: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_411;
return ( (NODEPTR) _currn);
}/* Mkrule_411 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_412 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_412 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_412 _currn;
#ifdef __cplusplus
_currn = new _TPrule_412;
#else
_currn = (_TPPrule_412) TreeNodeAlloc (sizeof (struct _TPrule_412));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_412;
_currn->_desc1 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_412: root of subtree no. 1 can not be made a xScalarVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_412;
return ( (NODEPTR) _currn);
}/* Mkrule_412 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_413 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_413 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_413 _currn;
#ifdef __cplusplus
_currn = new _TPrule_413;
#else
_currn = (_TPPrule_413) TreeNodeAlloc (sizeof (struct _TPrule_413));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_413;
_currn->_desc1 = (_TSPxLblRef) MkxLblRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_413: root of subtree no. 1 can not be made a xLblRef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_413;
return ( (NODEPTR) _currn);
}/* Mkrule_413 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_414 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_414 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_414 _currn;
#ifdef __cplusplus
_currn = new _TPrule_414;
#else
_currn = (_TPPrule_414) TreeNodeAlloc (sizeof (struct _TPrule_414));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_414;
_currn->_desc1 = (_TSPxCaseValueRangeList) MkxCaseValueRangeList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_414: root of subtree no. 1 can not be made a xCaseValueRangeList node ", 0, _coordref);
_currn->_desc2 = (_TSPxCaseValueRange) MkxCaseValueRange (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_414: root of subtree no. 2 can not be made a xCaseValueRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_414;
return ( (NODEPTR) _currn);
}/* Mkrule_414 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_415 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_415 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_415 _currn;
#ifdef __cplusplus
_currn = new _TPrule_415;
#else
_currn = (_TPPrule_415) TreeNodeAlloc (sizeof (struct _TPrule_415));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_415;
_currn->_desc1 = (_TSPxCaseValueRange) MkxCaseValueRange (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_415: root of subtree no. 1 can not be made a xCaseValueRange node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_415;
return ( (NODEPTR) _currn);
}/* Mkrule_415 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_416 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_416 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_416 _currn;
#ifdef __cplusplus
_currn = new _TPrule_416;
#else
_currn = (_TPPrule_416) TreeNodeAlloc (sizeof (struct _TPrule_416));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_416;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_416: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_416;
return ( (NODEPTR) _currn);
}/* Mkrule_416 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_417 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_417 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_417 _currn;
#ifdef __cplusplus
_currn = new _TPrule_417;
#else
_currn = (_TPPrule_417) TreeNodeAlloc (sizeof (struct _TPrule_417));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_417;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_417: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_417;
return ( (NODEPTR) _currn);
}/* Mkrule_417 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_418 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_418 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_418 _currn;
#ifdef __cplusplus
_currn = new _TPrule_418;
#else
_currn = (_TPPrule_418) TreeNodeAlloc (sizeof (struct _TPrule_418));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_418;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_418: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_418: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_418;
return ( (NODEPTR) _currn);
}/* Mkrule_418 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_419 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_419 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_419 _currn;
#ifdef __cplusplus
_currn = new _TPrule_419;
#else
_currn = (_TPPrule_419) TreeNodeAlloc (sizeof (struct _TPrule_419));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_419;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_419: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_419;
return ( (NODEPTR) _currn);
}/* Mkrule_419 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_420 (POSITION *_coordref)
#else
NODEPTR Mkrule_420 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_420 _currn;
#ifdef __cplusplus
_currn = new _TPrule_420;
#else
_currn = (_TPPrule_420) TreeNodeAlloc (sizeof (struct _TPrule_420));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_420;
_SETCOORD(_currn)
_TERMACT_rule_420;
return ( (NODEPTR) _currn);
}/* Mkrule_420 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_421 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_421 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_421 _currn;
#ifdef __cplusplus
_currn = new _TPrule_421;
#else
_currn = (_TPPrule_421) TreeNodeAlloc (sizeof (struct _TPrule_421));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_421;
_currn->_desc1 = (_TSPxCaseValueRangeList) MkxCaseValueRangeList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_421: root of subtree no. 1 can not be made a xCaseValueRangeList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_421;
return ( (NODEPTR) _currn);
}/* Mkrule_421 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_422 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_422 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_422 _currn;
#ifdef __cplusplus
_currn = new _TPrule_422;
#else
_currn = (_TPPrule_422) TreeNodeAlloc (sizeof (struct _TPrule_422));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_422;
_currn->_desc1 = (_TSPxStmt) MkxStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_422: root of subtree no. 1 can not be made a xStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxSelectCaseRange) MkxSelectCaseRange (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_422: root of subtree no. 2 can not be made a xSelectCaseRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_422;
return ( (NODEPTR) _currn);
}/* Mkrule_422 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_423 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_423 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_423 _currn;
#ifdef __cplusplus
_currn = new _TPrule_423;
#else
_currn = (_TPPrule_423) TreeNodeAlloc (sizeof (struct _TPrule_423));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_423;
_currn->_desc1 = (_TSPxBodyConstruct) MkxBodyConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_423: root of subtree no. 1 can not be made a xBodyConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_423;
return ( (NODEPTR) _currn);
}/* Mkrule_423 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_424 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_424 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_424 _currn;
#ifdef __cplusplus
_currn = new _TPrule_424;
#else
_currn = (_TPPrule_424) TreeNodeAlloc (sizeof (struct _TPrule_424));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_424;
_currn->_desc1 = (_TSPxStmt) MkxStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_424: root of subtree no. 1 can not be made a xStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_424;
return ( (NODEPTR) _currn);
}/* Mkrule_424 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_425 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_425 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_425 _currn;
#ifdef __cplusplus
_currn = new _TPrule_425;
#else
_currn = (_TPPrule_425) TreeNodeAlloc (sizeof (struct _TPrule_425));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_425;
_currn->_desc1 = (_TSPxDerivedVar) MkxDerivedVar (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_425: root of subtree no. 1 can not be made a xDerivedVar node ", 0, _coordref);
_currn->_desc2 = (_TSPxCompDataRef) MkxCompDataRef (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_425: root of subtree no. 2 can not be made a xCompDataRef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_425;
return ( (NODEPTR) _currn);
}/* Mkrule_425 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_426 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_426 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_426 _currn;
#ifdef __cplusplus
_currn = new _TPrule_426;
#else
_currn = (_TPPrule_426) TreeNodeAlloc (sizeof (struct _TPrule_426));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_426;
_SETCOORD(_currn)
_TERMACT_rule_426;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xZcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_426 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_427 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_427 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_427 _currn;
#ifdef __cplusplus
_currn = new _TPrule_427;
#else
_currn = (_TPPrule_427) TreeNodeAlloc (sizeof (struct _TPrule_427));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_427;
_SETCOORD(_currn)
_TERMACT_rule_427;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xOcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_427 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_428 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_428 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_428 _currn;
#ifdef __cplusplus
_currn = new _TPrule_428;
#else
_currn = (_TPPrule_428) TreeNodeAlloc (sizeof (struct _TPrule_428));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_428;
_SETCOORD(_currn)
_TERMACT_rule_428;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xBcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_428 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_429 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_429 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_429 _currn;
#ifdef __cplusplus
_currn = new _TPrule_429;
#else
_currn = (_TPPrule_429) TreeNodeAlloc (sizeof (struct _TPrule_429));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_429;
_currn->_desc1 = (_TSPxStmt) MkxStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_429: root of subtree no. 1 can not be made a xStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxInternalSubprogram) MkxInternalSubprogram (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_429: root of subtree no. 2 can not be made a xInternalSubprogram node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_429;
return ( (NODEPTR) _currn);
}/* Mkrule_429 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_430 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_430 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_430 _currn;
#ifdef __cplusplus
_currn = new _TPrule_430;
#else
_currn = (_TPPrule_430) TreeNodeAlloc (sizeof (struct _TPrule_430));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_430;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_430: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxInternalSubprogram) MkxInternalSubprogram (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_430: root of subtree no. 2 can not be made a xInternalSubprogram node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_430;
return ( (NODEPTR) _currn);
}/* Mkrule_430 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_431 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_431 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_431 _currn;
#ifdef __cplusplus
_currn = new _TPrule_431;
#else
_currn = (_TPPrule_431) TreeNodeAlloc (sizeof (struct _TPrule_431));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_431;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_431: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxStmt) MkxStmt (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_431: root of subtree no. 2 can not be made a xStmt node ", 0, _coordref);
_currn->_desc3 = (_TSPxInternalSubprogram) MkxInternalSubprogram (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_431: root of subtree no. 3 can not be made a xInternalSubprogram node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_431;
return ( (NODEPTR) _currn);
}/* Mkrule_431 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_432 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_432 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_432 _currn;
#ifdef __cplusplus
_currn = new _TPrule_432;
#else
_currn = (_TPPrule_432) TreeNodeAlloc (sizeof (struct _TPrule_432));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_432;
_currn->_desc1 = (_TSPxStmt) MkxStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_432: root of subtree no. 1 can not be made a xStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_432;
return ( (NODEPTR) _currn);
}/* Mkrule_432 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_433 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_433 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_433 _currn;
#ifdef __cplusplus
_currn = new _TPrule_433;
#else
_currn = (_TPPrule_433) TreeNodeAlloc (sizeof (struct _TPrule_433));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_433;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_433: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_433;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_433 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_434 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_434 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_434 _currn;
#ifdef __cplusplus
_currn = new _TPrule_434;
#else
_currn = (_TPPrule_434) TreeNodeAlloc (sizeof (struct _TPrule_434));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_434;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_434: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxBlockDataName) MkxBlockDataName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_434: root of subtree no. 2 can not be made a xBlockDataName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_434;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_434 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_435 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_435 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_435 _currn;
#ifdef __cplusplus
_currn = new _TPrule_435;
#else
_currn = (_TPPrule_435) TreeNodeAlloc (sizeof (struct _TPrule_435));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_435;
_SETCOORD(_currn)
_TERMACT_rule_435;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_435 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_436 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_436 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_436 _currn;
#ifdef __cplusplus
_currn = new _TPrule_436;
#else
_currn = (_TPPrule_436) TreeNodeAlloc (sizeof (struct _TPrule_436));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_436;
_currn->_desc1 = (_TSPxBodyConstruct) MkxBodyConstruct (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_436: root of subtree no. 1 can not be made a xBodyConstruct node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_436;
return ( (NODEPTR) _currn);
}/* Mkrule_436 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_437 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_437 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_437 _currn;
#ifdef __cplusplus
_currn = new _TPrule_437;
#else
_currn = (_TPPrule_437) TreeNodeAlloc (sizeof (struct _TPrule_437));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_437;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_437: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxBodyConstruct) MkxBodyConstruct (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_437: root of subtree no. 2 can not be made a xBodyConstruct node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_437;
return ( (NODEPTR) _currn);
}/* Mkrule_437 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_438 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_438 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_438 _currn;
#ifdef __cplusplus
_currn = new _TPrule_438;
#else
_currn = (_TPPrule_438) TreeNodeAlloc (sizeof (struct _TPrule_438));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_438;
_SETCOORD(_currn)
_TERMACT_rule_438;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_438 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_439 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, NODEPTR _desc5)
#else
NODEPTR Mkrule_439 (_coordref,_desc1,_desc2,_desc3,_desc4,_desc5)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	NODEPTR _desc5;
#endif
{	_TPPrule_439 _currn;
#ifdef __cplusplus
_currn = new _TPrule_439;
#else
_currn = (_TPPrule_439) TreeNodeAlloc (sizeof (struct _TPrule_439));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_439;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_439: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxImpliedDoVariable) MkxImpliedDoVariable (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_439: root of subtree no. 2 can not be made a xImpliedDoVariable node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_439: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_439: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_currn->_desc5 = (_TSPxExpr) MkxExpr (_coordref, _desc5);	
if (((NODEPTR)_currn->_desc5) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_439: root of subtree no. 5 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_439;
return ( (NODEPTR) _currn);
}/* Mkrule_439 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_440 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4)
#else
NODEPTR Mkrule_440 (_coordref,_desc1,_desc2,_desc3,_desc4)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
#endif
{	_TPPrule_440 _currn;
#ifdef __cplusplus
_currn = new _TPrule_440;
#else
_currn = (_TPPrule_440) TreeNodeAlloc (sizeof (struct _TPrule_440));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_440;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_440: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxImpliedDoVariable) MkxImpliedDoVariable (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_440: root of subtree no. 2 can not be made a xImpliedDoVariable node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_440: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_440: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_440;
return ( (NODEPTR) _currn);
}/* Mkrule_440 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_441 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_441 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_441 _currn;
#ifdef __cplusplus
_currn = new _TPrule_441;
#else
_currn = (_TPPrule_441) TreeNodeAlloc (sizeof (struct _TPrule_441));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_441;
_currn->_desc1 = (_TSPxForallStmt) MkxForallStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_441: root of subtree no. 1 can not be made a xForallStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_441;
return ( (NODEPTR) _currn);
}/* Mkrule_441 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_442 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_442 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_442 _currn;
#ifdef __cplusplus
_currn = new _TPrule_442;
#else
_currn = (_TPPrule_442) TreeNodeAlloc (sizeof (struct _TPrule_442));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_442;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_442: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxAccessSpec) MkxAccessSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_442: root of subtree no. 2 can not be made a xAccessSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_442;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_442 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_443 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_443 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_443 _currn;
#ifdef __cplusplus
_currn = new _TPrule_443;
#else
_currn = (_TPPrule_443) TreeNodeAlloc (sizeof (struct _TPrule_443));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_443;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_443: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxAccessSpec) MkxAccessSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_443: root of subtree no. 2 can not be made a xAccessSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPxAccessIdList) MkxAccessIdList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_443: root of subtree no. 3 can not be made a xAccessIdList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_443;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_443 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_444 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_444 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_444 _currn;
#ifdef __cplusplus
_currn = new _TPrule_444;
#else
_currn = (_TPPrule_444) TreeNodeAlloc (sizeof (struct _TPrule_444));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_444;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_444: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxAccessSpec) MkxAccessSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_444: root of subtree no. 2 can not be made a xAccessSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPxAccessIdList) MkxAccessIdList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_444: root of subtree no. 3 can not be made a xAccessIdList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_444;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_444 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_445 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_445 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_445 _currn;
#ifdef __cplusplus
_currn = new _TPrule_445;
#else
_currn = (_TPPrule_445) TreeNodeAlloc (sizeof (struct _TPrule_445));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_445;
_currn->_desc1 = (_TSPxAccessIdList) MkxAccessIdList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_445: root of subtree no. 1 can not be made a xAccessIdList node ", 0, _coordref);
_currn->_desc2 = (_TSPxAccessId) MkxAccessId (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_445: root of subtree no. 2 can not be made a xAccessId node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_445;
return ( (NODEPTR) _currn);
}/* Mkrule_445 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_446 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_446 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_446 _currn;
#ifdef __cplusplus
_currn = new _TPrule_446;
#else
_currn = (_TPPrule_446) TreeNodeAlloc (sizeof (struct _TPrule_446));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_446;
_currn->_desc1 = (_TSPxAccessId) MkxAccessId (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_446: root of subtree no. 1 can not be made a xAccessId node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_446;
return ( (NODEPTR) _currn);
}/* Mkrule_446 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_447 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_447 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_447 _currn;
#ifdef __cplusplus
_currn = new _TPrule_447;
#else
_currn = (_TPPrule_447) TreeNodeAlloc (sizeof (struct _TPrule_447));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_447;
_currn->_desc1 = (_TSPxGenericSpec) MkxGenericSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_447: root of subtree no. 1 can not be made a xGenericSpec node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_447;
return ( (NODEPTR) _currn);
}/* Mkrule_447 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_448 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_448 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_448 _currn;
#ifdef __cplusplus
_currn = new _TPrule_448;
#else
_currn = (_TPPrule_448) TreeNodeAlloc (sizeof (struct _TPrule_448));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_448;
_currn->_desc1 = (_TSPxGenericName) MkxGenericName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_448: root of subtree no. 1 can not be made a xGenericName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_448;
return ( (NODEPTR) _currn);
}/* Mkrule_448 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_449 (POSITION *_coordref)
#else
NODEPTR Mkrule_449 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_449 _currn;
#ifdef __cplusplus
_currn = new _TPrule_449;
#else
_currn = (_TPPrule_449) TreeNodeAlloc (sizeof (struct _TPrule_449));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_449;
_SETCOORD(_currn)
_TERMACT_rule_449;
return ( (NODEPTR) _currn);
}/* Mkrule_449 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_450 (POSITION *_coordref)
#else
NODEPTR Mkrule_450 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_450 _currn;
#ifdef __cplusplus
_currn = new _TPrule_450;
#else
_currn = (_TPPrule_450) TreeNodeAlloc (sizeof (struct _TPrule_450));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_450;
_SETCOORD(_currn)
_TERMACT_rule_450;
return ( (NODEPTR) _currn);
}/* Mkrule_450 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_451 (POSITION *_coordref)
#else
NODEPTR Mkrule_451 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_451 _currn;
#ifdef __cplusplus
_currn = new _TPrule_451;
#else
_currn = (_TPPrule_451) TreeNodeAlloc (sizeof (struct _TPrule_451));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_451;
_SETCOORD(_currn)
_TERMACT_rule_451;
return ( (NODEPTR) _currn);
}/* Mkrule_451 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_452 (POSITION *_coordref)
#else
NODEPTR Mkrule_452 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_452 _currn;
#ifdef __cplusplus
_currn = new _TPrule_452;
#else
_currn = (_TPPrule_452) TreeNodeAlloc (sizeof (struct _TPrule_452));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_452;
_SETCOORD(_currn)
_TERMACT_rule_452;
return ( (NODEPTR) _currn);
}/* Mkrule_452 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_453 (POSITION *_coordref)
#else
NODEPTR Mkrule_453 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_453 _currn;
#ifdef __cplusplus
_currn = new _TPrule_453;
#else
_currn = (_TPPrule_453) TreeNodeAlloc (sizeof (struct _TPrule_453));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_453;
_SETCOORD(_currn)
_TERMACT_rule_453;
return ( (NODEPTR) _currn);
}/* Mkrule_453 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_454 (POSITION *_coordref)
#else
NODEPTR Mkrule_454 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_454 _currn;
#ifdef __cplusplus
_currn = new _TPrule_454;
#else
_currn = (_TPPrule_454) TreeNodeAlloc (sizeof (struct _TPrule_454));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_454;
_SETCOORD(_currn)
_TERMACT_rule_454;
return ( (NODEPTR) _currn);
}/* Mkrule_454 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_455 (POSITION *_coordref)
#else
NODEPTR Mkrule_455 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_455 _currn;
#ifdef __cplusplus
_currn = new _TPrule_455;
#else
_currn = (_TPPrule_455) TreeNodeAlloc (sizeof (struct _TPrule_455));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_455;
_SETCOORD(_currn)
_TERMACT_rule_455;
return ( (NODEPTR) _currn);
}/* Mkrule_455 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_456 (POSITION *_coordref)
#else
NODEPTR Mkrule_456 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_456 _currn;
#ifdef __cplusplus
_currn = new _TPrule_456;
#else
_currn = (_TPPrule_456) TreeNodeAlloc (sizeof (struct _TPrule_456));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_456;
_SETCOORD(_currn)
_TERMACT_rule_456;
return ( (NODEPTR) _currn);
}/* Mkrule_456 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_457 (POSITION *_coordref)
#else
NODEPTR Mkrule_457 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_457 _currn;
#ifdef __cplusplus
_currn = new _TPrule_457;
#else
_currn = (_TPPrule_457) TreeNodeAlloc (sizeof (struct _TPrule_457));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_457;
_SETCOORD(_currn)
_TERMACT_rule_457;
return ( (NODEPTR) _currn);
}/* Mkrule_457 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_458 (POSITION *_coordref)
#else
NODEPTR Mkrule_458 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_458 _currn;
#ifdef __cplusplus
_currn = new _TPrule_458;
#else
_currn = (_TPPrule_458) TreeNodeAlloc (sizeof (struct _TPrule_458));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_458;
_SETCOORD(_currn)
_TERMACT_rule_458;
return ( (NODEPTR) _currn);
}/* Mkrule_458 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_459 (POSITION *_coordref)
#else
NODEPTR Mkrule_459 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_459 _currn;
#ifdef __cplusplus
_currn = new _TPrule_459;
#else
_currn = (_TPPrule_459) TreeNodeAlloc (sizeof (struct _TPrule_459));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_459;
_SETCOORD(_currn)
_TERMACT_rule_459;
return ( (NODEPTR) _currn);
}/* Mkrule_459 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_460 (POSITION *_coordref)
#else
NODEPTR Mkrule_460 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_460 _currn;
#ifdef __cplusplus
_currn = new _TPrule_460;
#else
_currn = (_TPPrule_460) TreeNodeAlloc (sizeof (struct _TPrule_460));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_460;
_SETCOORD(_currn)
_TERMACT_rule_460;
return ( (NODEPTR) _currn);
}/* Mkrule_460 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_461 (POSITION *_coordref)
#else
NODEPTR Mkrule_461 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_461 _currn;
#ifdef __cplusplus
_currn = new _TPrule_461;
#else
_currn = (_TPPrule_461) TreeNodeAlloc (sizeof (struct _TPrule_461));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_461;
_SETCOORD(_currn)
_TERMACT_rule_461;
return ( (NODEPTR) _currn);
}/* Mkrule_461 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_462 (POSITION *_coordref)
#else
NODEPTR Mkrule_462 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_462 _currn;
#ifdef __cplusplus
_currn = new _TPrule_462;
#else
_currn = (_TPPrule_462) TreeNodeAlloc (sizeof (struct _TPrule_462));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_462;
_SETCOORD(_currn)
_TERMACT_rule_462;
return ( (NODEPTR) _currn);
}/* Mkrule_462 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_463 (POSITION *_coordref)
#else
NODEPTR Mkrule_463 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_463 _currn;
#ifdef __cplusplus
_currn = new _TPrule_463;
#else
_currn = (_TPPrule_463) TreeNodeAlloc (sizeof (struct _TPrule_463));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_463;
_SETCOORD(_currn)
_TERMACT_rule_463;
return ( (NODEPTR) _currn);
}/* Mkrule_463 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_464 (POSITION *_coordref)
#else
NODEPTR Mkrule_464 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_464 _currn;
#ifdef __cplusplus
_currn = new _TPrule_464;
#else
_currn = (_TPPrule_464) TreeNodeAlloc (sizeof (struct _TPrule_464));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_464;
_SETCOORD(_currn)
_TERMACT_rule_464;
return ( (NODEPTR) _currn);
}/* Mkrule_464 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_465 (POSITION *_coordref)
#else
NODEPTR Mkrule_465 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_465 _currn;
#ifdef __cplusplus
_currn = new _TPrule_465;
#else
_currn = (_TPPrule_465) TreeNodeAlloc (sizeof (struct _TPrule_465));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_465;
_SETCOORD(_currn)
_TERMACT_rule_465;
return ( (NODEPTR) _currn);
}/* Mkrule_465 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_466 (POSITION *_coordref)
#else
NODEPTR Mkrule_466 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_466 _currn;
#ifdef __cplusplus
_currn = new _TPrule_466;
#else
_currn = (_TPPrule_466) TreeNodeAlloc (sizeof (struct _TPrule_466));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_466;
_SETCOORD(_currn)
_TERMACT_rule_466;
return ( (NODEPTR) _currn);
}/* Mkrule_466 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_467 (POSITION *_coordref)
#else
NODEPTR Mkrule_467 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_467 _currn;
#ifdef __cplusplus
_currn = new _TPrule_467;
#else
_currn = (_TPPrule_467) TreeNodeAlloc (sizeof (struct _TPrule_467));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_467;
_SETCOORD(_currn)
_TERMACT_rule_467;
return ( (NODEPTR) _currn);
}/* Mkrule_467 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_468 (POSITION *_coordref)
#else
NODEPTR Mkrule_468 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_468 _currn;
#ifdef __cplusplus
_currn = new _TPrule_468;
#else
_currn = (_TPPrule_468) TreeNodeAlloc (sizeof (struct _TPrule_468));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_468;
_SETCOORD(_currn)
_TERMACT_rule_468;
return ( (NODEPTR) _currn);
}/* Mkrule_468 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_469 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_469 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_469 _currn;
#ifdef __cplusplus
_currn = new _TPrule_469;
#else
_currn = (_TPPrule_469) TreeNodeAlloc (sizeof (struct _TPrule_469));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_469;
_currn->_desc1 = (_TSPxSFDataRef) MkxSFDataRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_469: root of subtree no. 1 can not be made a xSFDataRef node ", 0, _coordref);
_currn->_desc2 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_469: root of subtree no. 2 can not be made a xSectionSubscriptList node ", 0, _coordref);
_currn->_desc3 = (_TSPxCompName) MkxCompName (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_469: root of subtree no. 3 can not be made a xCompName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_469;
return ( (NODEPTR) _currn);
}/* Mkrule_469 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_470 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_470 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_470 _currn;
#ifdef __cplusplus
_currn = new _TPrule_470;
#else
_currn = (_TPPrule_470) TreeNodeAlloc (sizeof (struct _TPrule_470));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_470;
_currn->_desc1 = (_TSPxSFDataRef) MkxSFDataRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_470: root of subtree no. 1 can not be made a xSFDataRef node ", 0, _coordref);
_currn->_desc2 = (_TSPxCompName) MkxCompName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_470: root of subtree no. 2 can not be made a xCompName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_470;
return ( (NODEPTR) _currn);
}/* Mkrule_470 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_471 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_471 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_471 _currn;
#ifdef __cplusplus
_currn = new _TPrule_471;
#else
_currn = (_TPPrule_471) TreeNodeAlloc (sizeof (struct _TPrule_471));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_471;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_471: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_currn->_desc2 = (_TSPxCompName) MkxCompName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_471: root of subtree no. 2 can not be made a xCompName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_471;
return ( (NODEPTR) _currn);
}/* Mkrule_471 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_472 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_472 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_472 _currn;
#ifdef __cplusplus
_currn = new _TPrule_472;
#else
_currn = (_TPPrule_472) TreeNodeAlloc (sizeof (struct _TPrule_472));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_472;
_currn->_desc1 = (_TSPxSFDataRef) MkxSFDataRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_472: root of subtree no. 1 can not be made a xSFDataRef node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_472;
return ( (NODEPTR) _currn);
}/* Mkrule_472 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_473 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_473 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_473 _currn;
#ifdef __cplusplus
_currn = new _TPrule_473;
#else
_currn = (_TPPrule_473) TreeNodeAlloc (sizeof (struct _TPrule_473));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_473;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_473: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_currn->_desc2 = (_TSPxArgList) MkxArgList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_473: root of subtree no. 2 can not be made a xArgList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_473;
return ( (NODEPTR) _currn);
}/* Mkrule_473 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_474 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_474 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_474 _currn;
#ifdef __cplusplus
_currn = new _TPrule_474;
#else
_currn = (_TPPrule_474) TreeNodeAlloc (sizeof (struct _TPrule_474));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_474;
_currn->_desc1 = (_TSPxVariableName) MkxVariableName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_474: root of subtree no. 1 can not be made a xVariableName node ", 0, _coordref);
_currn->_desc2 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_474: root of subtree no. 2 can not be made a xSectionSubscriptList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_474;
return ( (NODEPTR) _currn);
}/* Mkrule_474 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_475 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_475 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_475 _currn;
#ifdef __cplusplus
_currn = new _TPrule_475;
#else
_currn = (_TPPrule_475) TreeNodeAlloc (sizeof (struct _TPrule_475));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_475;
_currn->_desc1 = (_TSPxSubscriptTriplet) MkxSubscriptTriplet (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_475: root of subtree no. 1 can not be made a xSubscriptTriplet node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_475;
return ( (NODEPTR) _currn);
}/* Mkrule_475 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_476 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_476 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_476 _currn;
#ifdef __cplusplus
_currn = new _TPrule_476;
#else
_currn = (_TPPrule_476) TreeNodeAlloc (sizeof (struct _TPrule_476));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_476;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_476: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_476;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_476 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_477 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_477 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_477 _currn;
#ifdef __cplusplus
_currn = new _TPrule_477;
#else
_currn = (_TPPrule_477) TreeNodeAlloc (sizeof (struct _TPrule_477));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_477;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_477: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_477: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_477;
return ( (NODEPTR) _currn);
}/* Mkrule_477 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_478 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_478 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_478 _currn;
#ifdef __cplusplus
_currn = new _TPrule_478;
#else
_currn = (_TPPrule_478) TreeNodeAlloc (sizeof (struct _TPrule_478));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_478;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_478: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_478: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_478;
return ( (NODEPTR) _currn);
}/* Mkrule_478 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_479 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_479 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_479 _currn;
#ifdef __cplusplus
_currn = new _TPrule_479;
#else
_currn = (_TPPrule_479) TreeNodeAlloc (sizeof (struct _TPrule_479));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_479;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_479: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_479;
return ( (NODEPTR) _currn);
}/* Mkrule_479 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_480 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_480 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_480 _currn;
#ifdef __cplusplus
_currn = new _TPrule_480;
#else
_currn = (_TPPrule_480) TreeNodeAlloc (sizeof (struct _TPrule_480));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_480;
_currn->_desc1 = (_TSPxSFDummyArgNameList) MkxSFDummyArgNameList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_480: root of subtree no. 1 can not be made a xSFDummyArgNameList node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_480: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_480;
return ( (NODEPTR) _currn);
}/* Mkrule_480 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_481 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_481 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_481 _currn;
#ifdef __cplusplus
_currn = new _TPrule_481;
#else
_currn = (_TPPrule_481) TreeNodeAlloc (sizeof (struct _TPrule_481));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_481;
_currn->_desc1 = (_TSPxSFDummyArgNameList) MkxSFDummyArgNameList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_481: root of subtree no. 1 can not be made a xSFDummyArgNameList node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_481: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_481;
return ( (NODEPTR) _currn);
}/* Mkrule_481 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_482 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_482 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_482 _currn;
#ifdef __cplusplus
_currn = new _TPrule_482;
#else
_currn = (_TPPrule_482) TreeNodeAlloc (sizeof (struct _TPrule_482));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_482;
_currn->_desc1 = (_TSPxSFDummyArgNameList) MkxSFDummyArgNameList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_482: root of subtree no. 1 can not be made a xSFDummyArgNameList node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_482: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_482: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_482;
return ( (NODEPTR) _currn);
}/* Mkrule_482 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_483 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_483 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_483 _currn;
#ifdef __cplusplus
_currn = new _TPrule_483;
#else
_currn = (_TPPrule_483) TreeNodeAlloc (sizeof (struct _TPrule_483));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_483;
_currn->_desc1 = (_TSPxSFDummyArgNameList) MkxSFDummyArgNameList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_483: root of subtree no. 1 can not be made a xSFDummyArgNameList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_483;
return ( (NODEPTR) _currn);
}/* Mkrule_483 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_484 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_484 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_484 _currn;
#ifdef __cplusplus
_currn = new _TPrule_484;
#else
_currn = (_TPPrule_484) TreeNodeAlloc (sizeof (struct _TPrule_484));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_484;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_484: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_484;
return ( (NODEPTR) _currn);
}/* Mkrule_484 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_485 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_485 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_485 _currn;
#ifdef __cplusplus
_currn = new _TPrule_485;
#else
_currn = (_TPPrule_485) TreeNodeAlloc (sizeof (struct _TPrule_485));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_485;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_485: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_485;
return ( (NODEPTR) _currn);
}/* Mkrule_485 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_486 (POSITION *_coordref)
#else
NODEPTR Mkrule_486 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_486 _currn;
#ifdef __cplusplus
_currn = new _TPrule_486;
#else
_currn = (_TPPrule_486) TreeNodeAlloc (sizeof (struct _TPrule_486));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_486;
_SETCOORD(_currn)
_TERMACT_rule_486;
return ( (NODEPTR) _currn);
}/* Mkrule_486 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_487 (POSITION *_coordref)
#else
NODEPTR Mkrule_487 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_487 _currn;
#ifdef __cplusplus
_currn = new _TPrule_487;
#else
_currn = (_TPPrule_487) TreeNodeAlloc (sizeof (struct _TPrule_487));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_487;
_SETCOORD(_currn)
_TERMACT_rule_487;
return ( (NODEPTR) _currn);
}/* Mkrule_487 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_488 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_488 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_488 _currn;
#ifdef __cplusplus
_currn = new _TPrule_488;
#else
_currn = (_TPPrule_488) TreeNodeAlloc (sizeof (struct _TPrule_488));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_488;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_488: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_488: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_488;
return ( (NODEPTR) _currn);
}/* Mkrule_488 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_489 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_489 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_489 _currn;
#ifdef __cplusplus
_currn = new _TPrule_489;
#else
_currn = (_TPPrule_489) TreeNodeAlloc (sizeof (struct _TPrule_489));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_489;
_currn->_desc1 = (_TSPxSFDummyArgNameList) MkxSFDummyArgNameList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_489: root of subtree no. 1 can not be made a xSFDummyArgNameList node ", 0, _coordref);
_currn->_desc2 = (_TSPxSFDummyArgName) MkxSFDummyArgName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_489: root of subtree no. 2 can not be made a xSFDummyArgName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_489;
return ( (NODEPTR) _currn);
}/* Mkrule_489 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_490 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_490 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_490 _currn;
#ifdef __cplusplus
_currn = new _TPrule_490;
#else
_currn = (_TPPrule_490) TreeNodeAlloc (sizeof (struct _TPrule_490));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_490;
_currn->_desc1 = (_TSPxSFDummyArgName) MkxSFDummyArgName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_490: root of subtree no. 1 can not be made a xSFDummyArgName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_490;
return ( (NODEPTR) _currn);
}/* Mkrule_490 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_491 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_491 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_491 _currn;
#ifdef __cplusplus
_currn = new _TPrule_491;
#else
_currn = (_TPPrule_491) TreeNodeAlloc (sizeof (struct _TPrule_491));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_491;
_currn->_desc1 = (_TSPxSFDummyArgNameList) MkxSFDummyArgNameList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_491: root of subtree no. 1 can not be made a xSFDummyArgNameList node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_491: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_491;
return ( (NODEPTR) _currn);
}/* Mkrule_491 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_492 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_492 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_492 _currn;
#ifdef __cplusplus
_currn = new _TPrule_492;
#else
_currn = (_TPPrule_492) TreeNodeAlloc (sizeof (struct _TPrule_492));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_492;
_currn->_desc1 = (_TSPxExprList) MkxExprList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_492: root of subtree no. 1 can not be made a xExprList node ", 0, _coordref);
_currn->_desc2 = (_TSPxSectionSubscript) MkxSectionSubscript (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_492: root of subtree no. 2 can not be made a xSectionSubscript node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_492;
return ( (NODEPTR) _currn);
}/* Mkrule_492 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_493 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_493 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_493 _currn;
#ifdef __cplusplus
_currn = new _TPrule_493;
#else
_currn = (_TPPrule_493) TreeNodeAlloc (sizeof (struct _TPrule_493));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_493;
_currn->_desc1 = (_TSPxExprList) MkxExprList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_493: root of subtree no. 1 can not be made a xExprList node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_493: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_493;
return ( (NODEPTR) _currn);
}/* Mkrule_493 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_494 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_494 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_494 _currn;
#ifdef __cplusplus
_currn = new _TPrule_494;
#else
_currn = (_TPPrule_494) TreeNodeAlloc (sizeof (struct _TPrule_494));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_494;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_494: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_494;
return ( (NODEPTR) _currn);
}/* Mkrule_494 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_495 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_495 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_495 _currn;
#ifdef __cplusplus
_currn = new _TPrule_495;
#else
_currn = (_TPPrule_495) TreeNodeAlloc (sizeof (struct _TPrule_495));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_495;
_currn->_desc1 = (_TSPxSFVarName) MkxSFVarName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_495: root of subtree no. 1 can not be made a xSFVarName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_495;
return ( (NODEPTR) _currn);
}/* Mkrule_495 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_496 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_496 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_496 _currn;
#ifdef __cplusplus
_currn = new _TPrule_496;
#else
_currn = (_TPPrule_496) TreeNodeAlloc (sizeof (struct _TPrule_496));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_496;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_496: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_496;
return ( (NODEPTR) _currn);
}/* Mkrule_496 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_497 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_497 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_497 _currn;
#ifdef __cplusplus
_currn = new _TPrule_497;
#else
_currn = (_TPPrule_497) TreeNodeAlloc (sizeof (struct _TPrule_497));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_497;
_currn->_desc1 = (_TSPxVariableName) MkxVariableName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_497: root of subtree no. 1 can not be made a xVariableName node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_497: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_497: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_497;
return ( (NODEPTR) _currn);
}/* Mkrule_497 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_498 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4)
#else
NODEPTR Mkrule_498 (_coordref,_desc1,_desc2,_desc3,_desc4)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
#endif
{	_TPPrule_498 _currn;
#ifdef __cplusplus
_currn = new _TPrule_498;
#else
_currn = (_TPPrule_498) TreeNodeAlloc (sizeof (struct _TPrule_498));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_498;
_currn->_desc1 = (_TSPxVariableName) MkxVariableName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_498: root of subtree no. 1 can not be made a xVariableName node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_498: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_498: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_498: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_498;
return ( (NODEPTR) _currn);
}/* Mkrule_498 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_499 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_499 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_499 _currn;
#ifdef __cplusplus
_currn = new _TPrule_499;
#else
_currn = (_TPPrule_499) TreeNodeAlloc (sizeof (struct _TPrule_499));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_499;
_SETCOORD(_currn)
_TERMACT_rule_499;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_499 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_500 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_500 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_500 _currn;
#ifdef __cplusplus
_currn = new _TPrule_500;
#else
_currn = (_TPPrule_500) TreeNodeAlloc (sizeof (struct _TPrule_500));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_500;
_currn->_desc1 = (_TSPxDataRef) MkxDataRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_500: root of subtree no. 1 can not be made a xDataRef node ", 0, _coordref);
_currn->_desc2 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_500: root of subtree no. 2 can not be made a xSectionSubscriptList node ", 0, _coordref);
_currn->_desc3 = (_TSPxCompName) MkxCompName (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_500: root of subtree no. 3 can not be made a xCompName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_500;
return ( (NODEPTR) _currn);
}/* Mkrule_500 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_501 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_501 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_501 _currn;
#ifdef __cplusplus
_currn = new _TPrule_501;
#else
_currn = (_TPPrule_501) TreeNodeAlloc (sizeof (struct _TPrule_501));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_501;
_currn->_desc1 = (_TSPxDataRef) MkxDataRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_501: root of subtree no. 1 can not be made a xDataRef node ", 0, _coordref);
_currn->_desc2 = (_TSPxCompName) MkxCompName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_501: root of subtree no. 2 can not be made a xCompName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_501;
return ( (NODEPTR) _currn);
}/* Mkrule_501 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_502 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_502 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_502 _currn;
#ifdef __cplusplus
_currn = new _TPrule_502;
#else
_currn = (_TPPrule_502) TreeNodeAlloc (sizeof (struct _TPrule_502));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_502;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_502: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_502;
return ( (NODEPTR) _currn);
}/* Mkrule_502 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_503 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_503 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_503 _currn;
#ifdef __cplusplus
_currn = new _TPrule_503;
#else
_currn = (_TPPrule_503) TreeNodeAlloc (sizeof (struct _TPrule_503));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_503;
_currn->_desc1 = (_TSPxDataRef) MkxDataRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_503: root of subtree no. 1 can not be made a xDataRef node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_503;
return ( (NODEPTR) _currn);
}/* Mkrule_503 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_504 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_504 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_504 _currn;
#ifdef __cplusplus
_currn = new _TPrule_504;
#else
_currn = (_TPPrule_504) TreeNodeAlloc (sizeof (struct _TPrule_504));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_504;
_currn->_desc1 = (_TSPxStructureComponent) MkxStructureComponent (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_504: root of subtree no. 1 can not be made a xStructureComponent node ", 0, _coordref);
_currn->_desc2 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_504: root of subtree no. 2 can not be made a xSectionSubscriptList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_504;
return ( (NODEPTR) _currn);
}/* Mkrule_504 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_505 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_505 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_505 _currn;
#ifdef __cplusplus
_currn = new _TPrule_505;
#else
_currn = (_TPPrule_505) TreeNodeAlloc (sizeof (struct _TPrule_505));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_505;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_505: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_currn->_desc2 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_505: root of subtree no. 2 can not be made a xSectionSubscriptList node ", 0, _coordref);
_currn->_desc3 = (_TSPxSubstringRange) MkxSubstringRange (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_505: root of subtree no. 3 can not be made a xSubstringRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_505;
return ( (NODEPTR) _currn);
}/* Mkrule_505 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_506 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_506 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_506 _currn;
#ifdef __cplusplus
_currn = new _TPrule_506;
#else
_currn = (_TPPrule_506) TreeNodeAlloc (sizeof (struct _TPrule_506));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_506;
_currn->_desc1 = (_TSPxDataRef) MkxDataRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_506: root of subtree no. 1 can not be made a xDataRef node ", 0, _coordref);
_currn->_desc2 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_506: root of subtree no. 2 can not be made a xSectionSubscriptList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_506;
return ( (NODEPTR) _currn);
}/* Mkrule_506 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_507 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_507 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_507 _currn;
#ifdef __cplusplus
_currn = new _TPrule_507;
#else
_currn = (_TPPrule_507) TreeNodeAlloc (sizeof (struct _TPrule_507));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_507;
_currn->_desc1 = (_TSPxDataRef) MkxDataRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_507: root of subtree no. 1 can not be made a xDataRef node ", 0, _coordref);
_currn->_desc2 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_507: root of subtree no. 2 can not be made a xSectionSubscriptList node ", 0, _coordref);
_currn->_desc3 = (_TSPxSubstringRange) MkxSubstringRange (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_507: root of subtree no. 3 can not be made a xSubstringRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_507;
return ( (NODEPTR) _currn);
}/* Mkrule_507 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_508 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_508 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_508 _currn;
#ifdef __cplusplus
_currn = new _TPrule_508;
#else
_currn = (_TPPrule_508) TreeNodeAlloc (sizeof (struct _TPrule_508));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_508;
_currn->_desc1 = (_TSPxSFDummyArgNameList) MkxSFDummyArgNameList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_508: root of subtree no. 1 can not be made a xSFDummyArgNameList node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_508: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_508;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_508 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_509 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, NODEPTR _desc5, int _TERM1)
#else
NODEPTR Mkrule_509 (_coordref,_desc1,_desc2,_desc3,_desc4,_desc5, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	NODEPTR _desc5;
	int _TERM1;
#endif
{	_TPPrule_509 _currn;
#ifdef __cplusplus
_currn = new _TPrule_509;
#else
_currn = (_TPPrule_509) TreeNodeAlloc (sizeof (struct _TPrule_509));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_509;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_509: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_509: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxSFDummyArgNameList) MkxSFDummyArgNameList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_509: root of subtree no. 3 can not be made a xSFDummyArgNameList node ", 0, _coordref);
_currn->_desc4 = (_TSPxSubstringRange) MkxSubstringRange (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_509: root of subtree no. 4 can not be made a xSubstringRange node ", 0, _coordref);
_currn->_desc5 = (_TSPxExpr) MkxExpr (_coordref, _desc5);	
if (((NODEPTR)_currn->_desc5) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_509: root of subtree no. 5 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_509;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_509 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_510 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_510 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_510 _currn;
#ifdef __cplusplus
_currn = new _TPrule_510;
#else
_currn = (_TPPrule_510) TreeNodeAlloc (sizeof (struct _TPrule_510));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_510;
_currn->_desc1 = (_TSPxNamedConstantUse) MkxNamedConstantUse (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_510: root of subtree no. 1 can not be made a xNamedConstantUse node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_510;
return ( (NODEPTR) _currn);
}/* Mkrule_510 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_511 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_511 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_511 _currn;
#ifdef __cplusplus
_currn = new _TPrule_511;
#else
_currn = (_TPPrule_511) TreeNodeAlloc (sizeof (struct _TPrule_511));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_511;
_SETCOORD(_currn)
_TERMACT_rule_511;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_511 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_512 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_512 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_512 _currn;
#ifdef __cplusplus
_currn = new _TPrule_512;
#else
_currn = (_TPPrule_512) TreeNodeAlloc (sizeof (struct _TPrule_512));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_512;
_SETCOORD(_currn)
_TERMACT_rule_512;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_512 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_513 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_513 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_513 _currn;
#ifdef __cplusplus
_currn = new _TPrule_513;
#else
_currn = (_TPPrule_513) TreeNodeAlloc (sizeof (struct _TPrule_513));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_513;
_SETCOORD(_currn)
_TERMACT_rule_513;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_513 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_514 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_514 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_514 _currn;
#ifdef __cplusplus
_currn = new _TPrule_514;
#else
_currn = (_TPPrule_514) TreeNodeAlloc (sizeof (struct _TPrule_514));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_514;
_SETCOORD(_currn)
_TERMACT_rule_514;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_514 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_515 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_515 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_515 _currn;
#ifdef __cplusplus
_currn = new _TPrule_515;
#else
_currn = (_TPPrule_515) TreeNodeAlloc (sizeof (struct _TPrule_515));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_515;
_SETCOORD(_currn)
_TERMACT_rule_515;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_515 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_516 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_516 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_516 _currn;
#ifdef __cplusplus
_currn = new _TPrule_516;
#else
_currn = (_TPPrule_516) TreeNodeAlloc (sizeof (struct _TPrule_516));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_516;
_SETCOORD(_currn)
_TERMACT_rule_516;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_516 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_517 (POSITION *_coordref)
#else
NODEPTR Mkrule_517 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_517 _currn;
#ifdef __cplusplus
_currn = new _TPrule_517;
#else
_currn = (_TPPrule_517) TreeNodeAlloc (sizeof (struct _TPrule_517));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_517;
_SETCOORD(_currn)
_TERMACT_rule_517;
return ( (NODEPTR) _currn);
}/* Mkrule_517 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_518 (POSITION *_coordref)
#else
NODEPTR Mkrule_518 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_518 _currn;
#ifdef __cplusplus
_currn = new _TPrule_518;
#else
_currn = (_TPPrule_518) TreeNodeAlloc (sizeof (struct _TPrule_518));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_518;
_SETCOORD(_currn)
_TERMACT_rule_518;
return ( (NODEPTR) _currn);
}/* Mkrule_518 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_519 (POSITION *_coordref)
#else
NODEPTR Mkrule_519 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_519 _currn;
#ifdef __cplusplus
_currn = new _TPrule_519;
#else
_currn = (_TPPrule_519) TreeNodeAlloc (sizeof (struct _TPrule_519));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_519;
_SETCOORD(_currn)
_TERMACT_rule_519;
return ( (NODEPTR) _currn);
}/* Mkrule_519 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_520 (POSITION *_coordref)
#else
NODEPTR Mkrule_520 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_520 _currn;
#ifdef __cplusplus
_currn = new _TPrule_520;
#else
_currn = (_TPPrule_520) TreeNodeAlloc (sizeof (struct _TPrule_520));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_520;
_SETCOORD(_currn)
_TERMACT_rule_520;
return ( (NODEPTR) _currn);
}/* Mkrule_520 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_521 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_521 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_521 _currn;
#ifdef __cplusplus
_currn = new _TPrule_521;
#else
_currn = (_TPPrule_521) TreeNodeAlloc (sizeof (struct _TPrule_521));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_521;
_currn->_desc1 = (_TSPxIntentSpec) MkxIntentSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_521: root of subtree no. 1 can not be made a xIntentSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_521;
return ( (NODEPTR) _currn);
}/* Mkrule_521 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_522 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_522 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_522 _currn;
#ifdef __cplusplus
_currn = new _TPrule_522;
#else
_currn = (_TPPrule_522) TreeNodeAlloc (sizeof (struct _TPrule_522));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_522;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_522: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_522;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xHcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_522 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_523 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_523 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_523 _currn;
#ifdef __cplusplus
_currn = new _TPrule_523;
#else
_currn = (_TPPrule_523) TreeNodeAlloc (sizeof (struct _TPrule_523));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_523;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_523: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_currn->_desc2 = (_TSPxLblRef) MkxLblRef (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_523: root of subtree no. 2 can not be made a xLblRef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_523;
return ( (NODEPTR) _currn);
}/* Mkrule_523 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_524 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_524 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_524 _currn;
#ifdef __cplusplus
_currn = new _TPrule_524;
#else
_currn = (_TPPrule_524) TreeNodeAlloc (sizeof (struct _TPrule_524));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_524;
_currn->_desc1 = (_TSPxLblRef) MkxLblRef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_524: root of subtree no. 1 can not be made a xLblRef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_524;
return ( (NODEPTR) _currn);
}/* Mkrule_524 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_525 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_525 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_525 _currn;
#ifdef __cplusplus
_currn = new _TPrule_525;
#else
_currn = (_TPPrule_525) TreeNodeAlloc (sizeof (struct _TPrule_525));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_525;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_525: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_525: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_525;
return ( (NODEPTR) _currn);
}/* Mkrule_525 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_526 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_526 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_526 _currn;
#ifdef __cplusplus
_currn = new _TPrule_526;
#else
_currn = (_TPPrule_526) TreeNodeAlloc (sizeof (struct _TPrule_526));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_526;
_SETCOORD(_currn)
_TERMACT_rule_526;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_526 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_527 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_527 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_527 _currn;
#ifdef __cplusplus
_currn = new _TPrule_527;
#else
_currn = (_TPPrule_527) TreeNodeAlloc (sizeof (struct _TPrule_527));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_527;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_527: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxModuleName) MkxModuleName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_527: root of subtree no. 2 can not be made a xModuleName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_527;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_527 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_528 (POSITION *_coordref)
#else
NODEPTR Mkrule_528 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_528 _currn;
#ifdef __cplusplus
_currn = new _TPrule_528;
#else
_currn = (_TPPrule_528) TreeNodeAlloc (sizeof (struct _TPrule_528));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_528;
_SETCOORD(_currn)
_TERMACT_rule_528;
return ( (NODEPTR) _currn);
}/* Mkrule_528 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_529 (POSITION *_coordref)
#else
NODEPTR Mkrule_529 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_529 _currn;
#ifdef __cplusplus
_currn = new _TPrule_529;
#else
_currn = (_TPPrule_529) TreeNodeAlloc (sizeof (struct _TPrule_529));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_529;
_SETCOORD(_currn)
_TERMACT_rule_529;
return ( (NODEPTR) _currn);
}/* Mkrule_529 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_530 (POSITION *_coordref)
#else
NODEPTR Mkrule_530 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_530 _currn;
#ifdef __cplusplus
_currn = new _TPrule_530;
#else
_currn = (_TPPrule_530) TreeNodeAlloc (sizeof (struct _TPrule_530));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_530;
_SETCOORD(_currn)
_TERMACT_rule_530;
return ( (NODEPTR) _currn);
}/* Mkrule_530 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_531 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_531 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_531 _currn;
#ifdef __cplusplus
_currn = new _TPrule_531;
#else
_currn = (_TPPrule_531) TreeNodeAlloc (sizeof (struct _TPrule_531));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_531;
_currn->_desc1 = (_TSPxPrefixSpecList) MkxPrefixSpecList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_531: root of subtree no. 1 can not be made a xPrefixSpecList node ", 0, _coordref);
_currn->_desc2 = (_TSPxPrefixSpec) MkxPrefixSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_531: root of subtree no. 2 can not be made a xPrefixSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_531;
return ( (NODEPTR) _currn);
}/* Mkrule_531 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_532 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_532 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_532 _currn;
#ifdef __cplusplus
_currn = new _TPrule_532;
#else
_currn = (_TPPrule_532) TreeNodeAlloc (sizeof (struct _TPrule_532));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_532;
_currn->_desc1 = (_TSPxPrefixSpec) MkxPrefixSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_532: root of subtree no. 1 can not be made a xPrefixSpec node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_532;
return ( (NODEPTR) _currn);
}/* Mkrule_532 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_533 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_533 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_533 _currn;
#ifdef __cplusplus
_currn = new _TPrule_533;
#else
_currn = (_TPPrule_533) TreeNodeAlloc (sizeof (struct _TPrule_533));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_533;
_currn->_desc1 = (_TSPxPrefixSpecList) MkxPrefixSpecList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_533: root of subtree no. 1 can not be made a xPrefixSpecList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_533;
return ( (NODEPTR) _currn);
}/* Mkrule_533 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_534 (POSITION *_coordref)
#else
NODEPTR Mkrule_534 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_534 _currn;
#ifdef __cplusplus
_currn = new _TPrule_534;
#else
_currn = (_TPPrule_534) TreeNodeAlloc (sizeof (struct _TPrule_534));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_534;
_SETCOORD(_currn)
_TERMACT_rule_534;
return ( (NODEPTR) _currn);
}/* Mkrule_534 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_535 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_535 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_535 _currn;
#ifdef __cplusplus
_currn = new _TPrule_535;
#else
_currn = (_TPPrule_535) TreeNodeAlloc (sizeof (struct _TPrule_535));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_535;
_SETCOORD(_currn)
_TERMACT_rule_535;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_535 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_536 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_536 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_536 _currn;
#ifdef __cplusplus
_currn = new _TPrule_536;
#else
_currn = (_TPPrule_536) TreeNodeAlloc (sizeof (struct _TPrule_536));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_536;
_currn->_desc1 = (_TSPxPrefixSpecList) MkxPrefixSpecList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_536: root of subtree no. 1 can not be made a xPrefixSpecList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_536;
return ( (NODEPTR) _currn);
}/* Mkrule_536 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_537 (POSITION *_coordref)
#else
NODEPTR Mkrule_537 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_537 _currn;
#ifdef __cplusplus
_currn = new _TPrule_537;
#else
_currn = (_TPPrule_537) TreeNodeAlloc (sizeof (struct _TPrule_537));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_537;
_SETCOORD(_currn)
_TERMACT_rule_537;
return ( (NODEPTR) _currn);
}/* Mkrule_537 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_538 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_538 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_538 _currn;
#ifdef __cplusplus
_currn = new _TPrule_538;
#else
_currn = (_TPPrule_538) TreeNodeAlloc (sizeof (struct _TPrule_538));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_538;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_538: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxSubroutinePrefix) MkxSubroutinePrefix (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_538: root of subtree no. 2 can not be made a xSubroutinePrefix node ", 0, _coordref);
_currn->_desc3 = (_TSPxSubroutineName) MkxSubroutineName (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_538: root of subtree no. 3 can not be made a xSubroutineName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_538;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_538 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_539 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, int _TERM1)
#else
NODEPTR Mkrule_539 (_coordref,_desc1,_desc2,_desc3,_desc4, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	int _TERM1;
#endif
{	_TPPrule_539 _currn;
#ifdef __cplusplus
_currn = new _TPrule_539;
#else
_currn = (_TPPrule_539) TreeNodeAlloc (sizeof (struct _TPrule_539));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_539;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_539: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxSubroutinePrefix) MkxSubroutinePrefix (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_539: root of subtree no. 2 can not be made a xSubroutinePrefix node ", 0, _coordref);
_currn->_desc3 = (_TSPxSubroutineName) MkxSubroutineName (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_539: root of subtree no. 3 can not be made a xSubroutineName node ", 0, _coordref);
_currn->_desc4 = (_TSPxFormalParameterList) MkxFormalParameterList (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_539: root of subtree no. 4 can not be made a xFormalParameterList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_539;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_539 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_540 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_540 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_540 _currn;
#ifdef __cplusplus
_currn = new _TPrule_540;
#else
_currn = (_TPPrule_540) TreeNodeAlloc (sizeof (struct _TPrule_540));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_540;
_currn->_desc1 = (_TSPxFormalParameterList) MkxFormalParameterList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_540: root of subtree no. 1 can not be made a xFormalParameterList node ", 0, _coordref);
_currn->_desc2 = (_TSPxFormalParameter) MkxFormalParameter (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_540: root of subtree no. 2 can not be made a xFormalParameter node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_540;
return ( (NODEPTR) _currn);
}/* Mkrule_540 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_541 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_541 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_541 _currn;
#ifdef __cplusplus
_currn = new _TPrule_541;
#else
_currn = (_TPPrule_541) TreeNodeAlloc (sizeof (struct _TPrule_541));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_541;
_currn->_desc1 = (_TSPxFormalParameter) MkxFormalParameter (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_541: root of subtree no. 1 can not be made a xFormalParameter node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_541;
return ( (NODEPTR) _currn);
}/* Mkrule_541 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_542 (POSITION *_coordref)
#else
NODEPTR Mkrule_542 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_542 _currn;
#ifdef __cplusplus
_currn = new _TPrule_542;
#else
_currn = (_TPPrule_542) TreeNodeAlloc (sizeof (struct _TPrule_542));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_542;
_SETCOORD(_currn)
_TERMACT_rule_542;
return ( (NODEPTR) _currn);
}/* Mkrule_542 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_543 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_543 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_543 _currn;
#ifdef __cplusplus
_currn = new _TPrule_543;
#else
_currn = (_TPPrule_543) TreeNodeAlloc (sizeof (struct _TPrule_543));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_543;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_543: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxProgramName) MkxProgramName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_543: root of subtree no. 2 can not be made a xProgramName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_543;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_543 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_544 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_544 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_544 _currn;
#ifdef __cplusplus
_currn = new _TPrule_544;
#else
_currn = (_TPPrule_544) TreeNodeAlloc (sizeof (struct _TPrule_544));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_544;
_SETCOORD(_currn)
_TERMACT_rule_544;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xScon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_544 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_545 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_545 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_545 _currn;
#ifdef __cplusplus
_currn = new _TPrule_545;
#else
_currn = (_TPPrule_545) TreeNodeAlloc (sizeof (struct _TPrule_545));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_545;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_545: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_545: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_545;
return ( (NODEPTR) _currn);
}/* Mkrule_545 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_546 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_546 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_546 _currn;
#ifdef __cplusplus
_currn = new _TPrule_546;
#else
_currn = (_TPPrule_546) TreeNodeAlloc (sizeof (struct _TPrule_546));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_546;
_currn->_desc1 = (_TSPxComplexConst) MkxComplexConst (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_546: root of subtree no. 1 can not be made a xComplexConst node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_546;
return ( (NODEPTR) _currn);
}/* Mkrule_546 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_547 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_547 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_547 _currn;
#ifdef __cplusplus
_currn = new _TPrule_547;
#else
_currn = (_TPPrule_547) TreeNodeAlloc (sizeof (struct _TPrule_547));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_547;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_547: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_547;
return ( (NODEPTR) _currn);
}/* Mkrule_547 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_548 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_548 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_548 _currn;
#ifdef __cplusplus
_currn = new _TPrule_548;
#else
_currn = (_TPPrule_548) TreeNodeAlloc (sizeof (struct _TPrule_548));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_548;
_SETCOORD(_currn)
_TERMACT_rule_548;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xHcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_548 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_549 (POSITION *_coordref)
#else
NODEPTR Mkrule_549 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_549 _currn;
#ifdef __cplusplus
_currn = new _TPrule_549;
#else
_currn = (_TPPrule_549) TreeNodeAlloc (sizeof (struct _TPrule_549));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_549;
_SETCOORD(_currn)
_TERMACT_rule_549;
return ( (NODEPTR) _currn);
}/* Mkrule_549 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_550 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_550 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_550 _currn;
#ifdef __cplusplus
_currn = new _TPrule_550;
#else
_currn = (_TPPrule_550) TreeNodeAlloc (sizeof (struct _TPrule_550));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_550;
_currn->_desc1 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_550: root of subtree no. 1 can not be made a xSectionSubscriptList node ", 0, _coordref);
_currn->_desc2 = (_TSPxArg) MkxArg (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_550: root of subtree no. 2 can not be made a xArg node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_550;
return ( (NODEPTR) _currn);
}/* Mkrule_550 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_551 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_551 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_551 _currn;
#ifdef __cplusplus
_currn = new _TPrule_551;
#else
_currn = (_TPPrule_551) TreeNodeAlloc (sizeof (struct _TPrule_551));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_551;
_currn->_desc1 = (_TSPxArgList) MkxArgList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_551: root of subtree no. 1 can not be made a xArgList node ", 0, _coordref);
_currn->_desc2 = (_TSPxArg) MkxArg (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_551: root of subtree no. 2 can not be made a xArg node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_551;
return ( (NODEPTR) _currn);
}/* Mkrule_551 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_552 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_552 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_552 _currn;
#ifdef __cplusplus
_currn = new _TPrule_552;
#else
_currn = (_TPPrule_552) TreeNodeAlloc (sizeof (struct _TPrule_552));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_552;
_currn->_desc1 = (_TSPxArg) MkxArg (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_552: root of subtree no. 1 can not be made a xArg node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_552;
return ( (NODEPTR) _currn);
}/* Mkrule_552 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_553 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_553 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_553 _currn;
#ifdef __cplusplus
_currn = new _TPrule_553;
#else
_currn = (_TPPrule_553) TreeNodeAlloc (sizeof (struct _TPrule_553));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_553;
_SETCOORD(_currn)
_TERMACT_rule_553;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_553 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_554 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_554 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_554 _currn;
#ifdef __cplusplus
_currn = new _TPrule_554;
#else
_currn = (_TPPrule_554) TreeNodeAlloc (sizeof (struct _TPrule_554));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_554;
_SETCOORD(_currn)
_TERMACT_rule_554;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_554 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_555 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_555 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_555 _currn;
#ifdef __cplusplus
_currn = new _TPrule_555;
#else
_currn = (_TPPrule_555) TreeNodeAlloc (sizeof (struct _TPrule_555));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_555;
_SETCOORD(_currn)
_TERMACT_rule_555;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_555 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_556 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_556 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_556 _currn;
#ifdef __cplusplus
_currn = new _TPrule_556;
#else
_currn = (_TPPrule_556) TreeNodeAlloc (sizeof (struct _TPrule_556));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_556;
_currn->_desc1 = (_TSPThreadSpec) MkThreadSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_556: root of subtree no. 1 can not be made a ThreadSpec node ", 0, _coordref);
_currn->_desc2 = (_TSPBlockSpec) MkBlockSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_556: root of subtree no. 2 can not be made a BlockSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPDataSection) MkDataSection (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_556: root of subtree no. 3 can not be made a DataSection node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_556;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_556 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_557 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_557 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_557 _currn;
#ifdef __cplusplus
_currn = new _TPrule_557;
#else
_currn = (_TPPrule_557) TreeNodeAlloc (sizeof (struct _TPrule_557));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_557;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_557: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_557: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_557;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_557 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_558 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_558 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_558 _currn;
#ifdef __cplusplus
_currn = new _TPrule_558;
#else
_currn = (_TPPrule_558) TreeNodeAlloc (sizeof (struct _TPrule_558));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_558;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_558: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_558: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxRenameList) MkxRenameList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_558: root of subtree no. 3 can not be made a xRenameList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_558;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_558 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_559 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_559 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_559 _currn;
#ifdef __cplusplus
_currn = new _TPrule_559;
#else
_currn = (_TPPrule_559) TreeNodeAlloc (sizeof (struct _TPrule_559));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_559;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_559: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_559: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_559;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_559 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_560 (POSITION *_coordref)
#else
NODEPTR Mkrule_560 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_560 _currn;
#ifdef __cplusplus
_currn = new _TPrule_560;
#else
_currn = (_TPPrule_560) TreeNodeAlloc (sizeof (struct _TPrule_560));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_560;
_SETCOORD(_currn)
_TERMACT_rule_560;
return ( (NODEPTR) _currn);
}/* Mkrule_560 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_561 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_561 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_561 _currn;
#ifdef __cplusplus
_currn = new _TPrule_561;
#else
_currn = (_TPPrule_561) TreeNodeAlloc (sizeof (struct _TPrule_561));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_561;
_currn->_desc1 = (_TSPxDummyArgName) MkxDummyArgName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_561: root of subtree no. 1 can not be made a xDummyArgName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_561;
return ( (NODEPTR) _currn);
}/* Mkrule_561 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_562 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_562 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_562 _currn;
#ifdef __cplusplus
_currn = new _TPrule_562;
#else
_currn = (_TPPrule_562) TreeNodeAlloc (sizeof (struct _TPrule_562));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_562;
_currn->_desc1 = (_TSPxDatalist) MkxDatalist (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_562: root of subtree no. 1 can not be made a xDatalist node ", 0, _coordref);
_currn->_desc2 = (_TSPxDataStmtSet) MkxDataStmtSet (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_562: root of subtree no. 2 can not be made a xDataStmtSet node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_562;
return ( (NODEPTR) _currn);
}/* Mkrule_562 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_563 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_563 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_563 _currn;
#ifdef __cplusplus
_currn = new _TPrule_563;
#else
_currn = (_TPPrule_563) TreeNodeAlloc (sizeof (struct _TPrule_563));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_563;
_currn->_desc1 = (_TSPxDatalist) MkxDatalist (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_563: root of subtree no. 1 can not be made a xDatalist node ", 0, _coordref);
_currn->_desc2 = (_TSPxDataStmtSet) MkxDataStmtSet (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_563: root of subtree no. 2 can not be made a xDataStmtSet node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_563;
return ( (NODEPTR) _currn);
}/* Mkrule_563 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_564 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_564 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_564 _currn;
#ifdef __cplusplus
_currn = new _TPrule_564;
#else
_currn = (_TPPrule_564) TreeNodeAlloc (sizeof (struct _TPrule_564));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_564;
_currn->_desc1 = (_TSPxDataStmtSet) MkxDataStmtSet (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_564: root of subtree no. 1 can not be made a xDataStmtSet node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_564;
return ( (NODEPTR) _currn);
}/* Mkrule_564 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_565 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_565 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_565 _currn;
#ifdef __cplusplus
_currn = new _TPrule_565;
#else
_currn = (_TPPrule_565) TreeNodeAlloc (sizeof (struct _TPrule_565));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_565;
_currn->_desc1 = (_TSPxConstant) MkxConstant (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_565: root of subtree no. 1 can not be made a xConstant node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_565;
return ( (NODEPTR) _currn);
}/* Mkrule_565 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_566 (POSITION *_coordref)
#else
NODEPTR Mkrule_566 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_566 _currn;
#ifdef __cplusplus
_currn = new _TPrule_566;
#else
_currn = (_TPPrule_566) TreeNodeAlloc (sizeof (struct _TPrule_566));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_566;
_SETCOORD(_currn)
_TERMACT_rule_566;
return ( (NODEPTR) _currn);
}/* Mkrule_566 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_567 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_567 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_567 _currn;
#ifdef __cplusplus
_currn = new _TPrule_567;
#else
_currn = (_TPPrule_567) TreeNodeAlloc (sizeof (struct _TPrule_567));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_567;
_SETCOORD(_currn)
_TERMACT_rule_567;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_567 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_568 (POSITION *_coordref, int _TERM1, NODEPTR _desc1)
#else
NODEPTR Mkrule_568 (_coordref, _TERM1,_desc1)
	POSITION *_coordref;
	int _TERM1;
	NODEPTR _desc1;
#endif
{	_TPPrule_568 _currn;
#ifdef __cplusplus
_currn = new _TPrule_568;
#else
_currn = (_TPPrule_568) TreeNodeAlloc (sizeof (struct _TPrule_568));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_568;
_currn->_desc1 = (_TSPxDataStmtConstant) MkxDataStmtConstant (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_568: root of subtree no. 1 can not be made a xDataStmtConstant node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_568;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_568 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_569 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_569 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_569 _currn;
#ifdef __cplusplus
_currn = new _TPrule_569;
#else
_currn = (_TPPrule_569) TreeNodeAlloc (sizeof (struct _TPrule_569));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_569;
_currn->_desc1 = (_TSPxNamedConstantUse) MkxNamedConstantUse (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_569: root of subtree no. 1 can not be made a xNamedConstantUse node ", 0, _coordref);
_currn->_desc2 = (_TSPxDataStmtConstant) MkxDataStmtConstant (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_569: root of subtree no. 2 can not be made a xDataStmtConstant node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_569;
return ( (NODEPTR) _currn);
}/* Mkrule_569 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_570 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_570 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_570 _currn;
#ifdef __cplusplus
_currn = new _TPrule_570;
#else
_currn = (_TPPrule_570) TreeNodeAlloc (sizeof (struct _TPrule_570));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_570;
_currn->_desc1 = (_TSPxDataStmtConstant) MkxDataStmtConstant (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_570: root of subtree no. 1 can not be made a xDataStmtConstant node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_570;
return ( (NODEPTR) _currn);
}/* Mkrule_570 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_571 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_571 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_571 _currn;
#ifdef __cplusplus
_currn = new _TPrule_571;
#else
_currn = (_TPPrule_571) TreeNodeAlloc (sizeof (struct _TPrule_571));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_571;
_currn->_desc1 = (_TSPxDataStmtValueList) MkxDataStmtValueList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_571: root of subtree no. 1 can not be made a xDataStmtValueList node ", 0, _coordref);
_currn->_desc2 = (_TSPxDataStmtValue) MkxDataStmtValue (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_571: root of subtree no. 2 can not be made a xDataStmtValue node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_571;
return ( (NODEPTR) _currn);
}/* Mkrule_571 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_572 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_572 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_572 _currn;
#ifdef __cplusplus
_currn = new _TPrule_572;
#else
_currn = (_TPPrule_572) TreeNodeAlloc (sizeof (struct _TPrule_572));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_572;
_currn->_desc1 = (_TSPxDataStmtValue) MkxDataStmtValue (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_572: root of subtree no. 1 can not be made a xDataStmtValue node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_572;
return ( (NODEPTR) _currn);
}/* Mkrule_572 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_573 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_573 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_573 _currn;
#ifdef __cplusplus
_currn = new _TPrule_573;
#else
_currn = (_TPPrule_573) TreeNodeAlloc (sizeof (struct _TPrule_573));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_573;
_currn->_desc1 = (_TSPxStructureComponent) MkxStructureComponent (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_573: root of subtree no. 1 can not be made a xStructureComponent node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_573;
return ( (NODEPTR) _currn);
}/* Mkrule_573 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_574 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_574 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_574 _currn;
#ifdef __cplusplus
_currn = new _TPrule_574;
#else
_currn = (_TPPrule_574) TreeNodeAlloc (sizeof (struct _TPrule_574));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_574;
_currn->_desc1 = (_TSPxDataImpliedDo) MkxDataImpliedDo (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_574: root of subtree no. 1 can not be made a xDataImpliedDo node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_574;
return ( (NODEPTR) _currn);
}/* Mkrule_574 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_575 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_575 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_575 _currn;
#ifdef __cplusplus
_currn = new _TPrule_575;
#else
_currn = (_TPPrule_575) TreeNodeAlloc (sizeof (struct _TPrule_575));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_575;
_currn->_desc1 = (_TSPxArrayElement) MkxArrayElement (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_575: root of subtree no. 1 can not be made a xArrayElement node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_575;
return ( (NODEPTR) _currn);
}/* Mkrule_575 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_576 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_576 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_576 _currn;
#ifdef __cplusplus
_currn = new _TPrule_576;
#else
_currn = (_TPPrule_576) TreeNodeAlloc (sizeof (struct _TPrule_576));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_576;
_currn->_desc1 = (_TSPxVariable) MkxVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_576: root of subtree no. 1 can not be made a xVariable node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_576;
return ( (NODEPTR) _currn);
}/* Mkrule_576 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_577 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_577 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_577 _currn;
#ifdef __cplusplus
_currn = new _TPrule_577;
#else
_currn = (_TPPrule_577) TreeNodeAlloc (sizeof (struct _TPrule_577));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_577;
_currn->_desc1 = (_TSPxDataStmtObjectList) MkxDataStmtObjectList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_577: root of subtree no. 1 can not be made a xDataStmtObjectList node ", 0, _coordref);
_currn->_desc2 = (_TSPxDataStmtObject) MkxDataStmtObject (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_577: root of subtree no. 2 can not be made a xDataStmtObject node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_577;
return ( (NODEPTR) _currn);
}/* Mkrule_577 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_578 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_578 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_578 _currn;
#ifdef __cplusplus
_currn = new _TPrule_578;
#else
_currn = (_TPPrule_578) TreeNodeAlloc (sizeof (struct _TPrule_578));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_578;
_currn->_desc1 = (_TSPxDataStmtObject) MkxDataStmtObject (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_578: root of subtree no. 1 can not be made a xDataStmtObject node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_578;
return ( (NODEPTR) _currn);
}/* Mkrule_578 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_579 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_579 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_579 _currn;
#ifdef __cplusplus
_currn = new _TPrule_579;
#else
_currn = (_TPPrule_579) TreeNodeAlloc (sizeof (struct _TPrule_579));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_579;
_currn->_desc1 = (_TSPxDataStmtObjectList) MkxDataStmtObjectList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_579: root of subtree no. 1 can not be made a xDataStmtObjectList node ", 0, _coordref);
_currn->_desc2 = (_TSPxDataStmtValueList) MkxDataStmtValueList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_579: root of subtree no. 2 can not be made a xDataStmtValueList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_579;
return ( (NODEPTR) _currn);
}/* Mkrule_579 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_580 (POSITION *_coordref)
#else
NODEPTR Mkrule_580 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_580 _currn;
#ifdef __cplusplus
_currn = new _TPrule_580;
#else
_currn = (_TPPrule_580) TreeNodeAlloc (sizeof (struct _TPrule_580));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_580;
_SETCOORD(_currn)
_TERMACT_rule_580;
return ( (NODEPTR) _currn);
}/* Mkrule_580 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_581 (POSITION *_coordref)
#else
NODEPTR Mkrule_581 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_581 _currn;
#ifdef __cplusplus
_currn = new _TPrule_581;
#else
_currn = (_TPPrule_581) TreeNodeAlloc (sizeof (struct _TPrule_581));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_581;
_SETCOORD(_currn)
_TERMACT_rule_581;
return ( (NODEPTR) _currn);
}/* Mkrule_581 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_582 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_582 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_582 _currn;
#ifdef __cplusplus
_currn = new _TPrule_582;
#else
_currn = (_TPPrule_582) TreeNodeAlloc (sizeof (struct _TPrule_582));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_582;
_currn->_desc1 = (_TSPxAccessSpec) MkxAccessSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_582: root of subtree no. 1 can not be made a xAccessSpec node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_582;
return ( (NODEPTR) _currn);
}/* Mkrule_582 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_583 (POSITION *_coordref)
#else
NODEPTR Mkrule_583 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_583 _currn;
#ifdef __cplusplus
_currn = new _TPrule_583;
#else
_currn = (_TPPrule_583) TreeNodeAlloc (sizeof (struct _TPrule_583));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_583;
_SETCOORD(_currn)
_TERMACT_rule_583;
return ( (NODEPTR) _currn);
}/* Mkrule_583 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_584 (POSITION *_coordref)
#else
NODEPTR Mkrule_584 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_584 _currn;
#ifdef __cplusplus
_currn = new _TPrule_584;
#else
_currn = (_TPPrule_584) TreeNodeAlloc (sizeof (struct _TPrule_584));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_584;
_SETCOORD(_currn)
_TERMACT_rule_584;
return ( (NODEPTR) _currn);
}/* Mkrule_584 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_585 (POSITION *_coordref)
#else
NODEPTR Mkrule_585 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_585 _currn;
#ifdef __cplusplus
_currn = new _TPrule_585;
#else
_currn = (_TPPrule_585) TreeNodeAlloc (sizeof (struct _TPrule_585));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_585;
_SETCOORD(_currn)
_TERMACT_rule_585;
return ( (NODEPTR) _currn);
}/* Mkrule_585 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_586 (POSITION *_coordref)
#else
NODEPTR Mkrule_586 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_586 _currn;
#ifdef __cplusplus
_currn = new _TPrule_586;
#else
_currn = (_TPPrule_586) TreeNodeAlloc (sizeof (struct _TPrule_586));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_586;
_SETCOORD(_currn)
_TERMACT_rule_586;
return ( (NODEPTR) _currn);
}/* Mkrule_586 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_587 (POSITION *_coordref)
#else
NODEPTR Mkrule_587 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_587 _currn;
#ifdef __cplusplus
_currn = new _TPrule_587;
#else
_currn = (_TPPrule_587) TreeNodeAlloc (sizeof (struct _TPrule_587));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_587;
_SETCOORD(_currn)
_TERMACT_rule_587;
return ( (NODEPTR) _currn);
}/* Mkrule_587 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_588 (POSITION *_coordref)
#else
NODEPTR Mkrule_588 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_588 _currn;
#ifdef __cplusplus
_currn = new _TPrule_588;
#else
_currn = (_TPPrule_588) TreeNodeAlloc (sizeof (struct _TPrule_588));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_588;
_SETCOORD(_currn)
_TERMACT_rule_588;
return ( (NODEPTR) _currn);
}/* Mkrule_588 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_589 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_589 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_589 _currn;
#ifdef __cplusplus
_currn = new _TPrule_589;
#else
_currn = (_TPPrule_589) TreeNodeAlloc (sizeof (struct _TPrule_589));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_589;
_currn->_desc1 = (_TSPxAttrSpecSeq) MkxAttrSpecSeq (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_589: root of subtree no. 1 can not be made a xAttrSpecSeq node ", 0, _coordref);
_currn->_desc2 = (_TSPxAttrSpec) MkxAttrSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_589: root of subtree no. 2 can not be made a xAttrSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_589;
return ( (NODEPTR) _currn);
}/* Mkrule_589 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_590 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_590 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_590 _currn;
#ifdef __cplusplus
_currn = new _TPrule_590;
#else
_currn = (_TPPrule_590) TreeNodeAlloc (sizeof (struct _TPrule_590));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_590;
_currn->_desc1 = (_TSPxAttrSpec) MkxAttrSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_590: root of subtree no. 1 can not be made a xAttrSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_590;
return ( (NODEPTR) _currn);
}/* Mkrule_590 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_591 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_591 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_591 _currn;
#ifdef __cplusplus
_currn = new _TPrule_591;
#else
_currn = (_TPPrule_591) TreeNodeAlloc (sizeof (struct _TPrule_591));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_591;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_591: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxArrayDeclaratorList) MkxArrayDeclaratorList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_591: root of subtree no. 2 can not be made a xArrayDeclaratorList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_591;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_591 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_592 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_592 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_592 _currn;
#ifdef __cplusplus
_currn = new _TPrule_592;
#else
_currn = (_TPPrule_592) TreeNodeAlloc (sizeof (struct _TPrule_592));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_592;
_currn->_desc1 = (_TSPxAttrArraySpec) MkxAttrArraySpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_592: root of subtree no. 1 can not be made a xAttrArraySpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_592;
return ( (NODEPTR) _currn);
}/* Mkrule_592 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_593 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_593 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_593 _currn;
#ifdef __cplusplus
_currn = new _TPrule_593;
#else
_currn = (_TPPrule_593) TreeNodeAlloc (sizeof (struct _TPrule_593));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_593;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_593: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_593: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_593;
return ( (NODEPTR) _currn);
}/* Mkrule_593 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_594 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_594 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_594 _currn;
#ifdef __cplusplus
_currn = new _TPrule_594;
#else
_currn = (_TPPrule_594) TreeNodeAlloc (sizeof (struct _TPrule_594));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_594;
_currn->_desc1 = (_TSPxAcValueList) MkxAcValueList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_594: root of subtree no. 1 can not be made a xAcValueList node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_594: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_594;
return ( (NODEPTR) _currn);
}/* Mkrule_594 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_595 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_595 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_595 _currn;
#ifdef __cplusplus
_currn = new _TPrule_595;
#else
_currn = (_TPPrule_595) TreeNodeAlloc (sizeof (struct _TPrule_595));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_595;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_595: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_595;
return ( (NODEPTR) _currn);
}/* Mkrule_595 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_596 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_596 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_596 _currn;
#ifdef __cplusplus
_currn = new _TPrule_596;
#else
_currn = (_TPPrule_596) TreeNodeAlloc (sizeof (struct _TPrule_596));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_596;
_currn->_desc1 = (_TSPxAcValueList) MkxAcValueList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_596: root of subtree no. 1 can not be made a xAcValueList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_596;
return ( (NODEPTR) _currn);
}/* Mkrule_596 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_597 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_597 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_597 _currn;
#ifdef __cplusplus
_currn = new _TPrule_597;
#else
_currn = (_TPPrule_597) TreeNodeAlloc (sizeof (struct _TPrule_597));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_597;
_currn->_desc1 = (_TSPxAttrStmt) MkxAttrStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_597: root of subtree no. 1 can not be made a xAttrStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_597;
return ( (NODEPTR) _currn);
}/* Mkrule_597 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_598 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, NODEPTR _desc5, int _TERM1)
#else
NODEPTR Mkrule_598 (_coordref,_desc1,_desc2,_desc3,_desc4,_desc5, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	NODEPTR _desc5;
	int _TERM1;
#endif
{	_TPPrule_598 _currn;
#ifdef __cplusplus
_currn = new _TPrule_598;
#else
_currn = (_TPPrule_598) TreeNodeAlloc (sizeof (struct _TPrule_598));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_598;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_598: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxFunctionPrefix) MkxFunctionPrefix (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_598: root of subtree no. 2 can not be made a xFunctionPrefix node ", 0, _coordref);
_currn->_desc3 = (_TSPxFunctionName) MkxFunctionName (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_598: root of subtree no. 3 can not be made a xFunctionName node ", 0, _coordref);
_currn->_desc4 = (_TSPxFormalParameterList) MkxFormalParameterList (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_598: root of subtree no. 4 can not be made a xFormalParameterList node ", 0, _coordref);
_currn->_desc5 = (_TSPxName) MkxName (_coordref, _desc5);	
if (((NODEPTR)_currn->_desc5) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_598: root of subtree no. 5 can not be made a xName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_598;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_598 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_599 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, int _TERM1)
#else
NODEPTR Mkrule_599 (_coordref,_desc1,_desc2,_desc3,_desc4, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	int _TERM1;
#endif
{	_TPPrule_599 _currn;
#ifdef __cplusplus
_currn = new _TPrule_599;
#else
_currn = (_TPPrule_599) TreeNodeAlloc (sizeof (struct _TPrule_599));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_599;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_599: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxFunctionPrefix) MkxFunctionPrefix (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_599: root of subtree no. 2 can not be made a xFunctionPrefix node ", 0, _coordref);
_currn->_desc3 = (_TSPxFunctionName) MkxFunctionName (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_599: root of subtree no. 3 can not be made a xFunctionName node ", 0, _coordref);
_currn->_desc4 = (_TSPxFormalParameterList) MkxFormalParameterList (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_599: root of subtree no. 4 can not be made a xFormalParameterList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_599;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_599 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_600 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_600 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_600 _currn;
#ifdef __cplusplus
_currn = new _TPrule_600;
#else
_currn = (_TPPrule_600) TreeNodeAlloc (sizeof (struct _TPrule_600));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_600;
_currn->_desc1 = (_TSPxInvalidEntityDecl) MkxInvalidEntityDecl (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_600: root of subtree no. 1 can not be made a xInvalidEntityDecl node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_600;
return ( (NODEPTR) _currn);
}/* Mkrule_600 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_601 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4)
#else
NODEPTR Mkrule_601 (_coordref,_desc1,_desc2,_desc3,_desc4)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
#endif
{	_TPPrule_601 _currn;
#ifdef __cplusplus
_currn = new _TPrule_601;
#else
_currn = (_TPPrule_601) TreeNodeAlloc (sizeof (struct _TPrule_601));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_601;
_currn->_desc1 = (_TSPxObjectName) MkxObjectName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_601: root of subtree no. 1 can not be made a xObjectName node ", 0, _coordref);
_currn->_desc2 = (_TSPDimensionDeclarators) MkDimensionDeclarators (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_601: root of subtree no. 2 can not be made a DimensionDeclarators node ", 0, _coordref);
_currn->_desc3 = (_TSPxCharLength) MkxCharLength (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_601: root of subtree no. 3 can not be made a xCharLength node ", 0, _coordref);
_currn->_desc4 = (_TSPxInitialization) MkxInitialization (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_601: root of subtree no. 4 can not be made a xInitialization node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_601;
return ( (NODEPTR) _currn);
}/* Mkrule_601 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_602 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_602 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_602 _currn;
#ifdef __cplusplus
_currn = new _TPrule_602;
#else
_currn = (_TPPrule_602) TreeNodeAlloc (sizeof (struct _TPrule_602));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_602;
_currn->_desc1 = (_TSPxObjectName) MkxObjectName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_602: root of subtree no. 1 can not be made a xObjectName node ", 0, _coordref);
_currn->_desc2 = (_TSPDimensionDeclarators) MkDimensionDeclarators (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_602: root of subtree no. 2 can not be made a DimensionDeclarators node ", 0, _coordref);
_currn->_desc3 = (_TSPxInitialization) MkxInitialization (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_602: root of subtree no. 3 can not be made a xInitialization node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_602;
return ( (NODEPTR) _currn);
}/* Mkrule_602 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_603 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_603 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_603 _currn;
#ifdef __cplusplus
_currn = new _TPrule_603;
#else
_currn = (_TPPrule_603) TreeNodeAlloc (sizeof (struct _TPrule_603));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_603;
_currn->_desc1 = (_TSPxTypeSpec) MkxTypeSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_603: root of subtree no. 1 can not be made a xTypeSpec node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_603;
return ( (NODEPTR) _currn);
}/* Mkrule_603 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_604 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_604 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_604 _currn;
#ifdef __cplusplus
_currn = new _TPrule_604;
#else
_currn = (_TPPrule_604) TreeNodeAlloc (sizeof (struct _TPrule_604));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_604;
_currn->_desc1 = (_TSPxStructureConstructor) MkxStructureConstructor (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_604: root of subtree no. 1 can not be made a xStructureConstructor node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_604;
return ( (NODEPTR) _currn);
}/* Mkrule_604 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_605 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_605 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_605 _currn;
#ifdef __cplusplus
_currn = new _TPrule_605;
#else
_currn = (_TPPrule_605) TreeNodeAlloc (sizeof (struct _TPrule_605));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_605;
_currn->_desc1 = (_TSPxNamedConstantUse) MkxNamedConstantUse (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_605: root of subtree no. 1 can not be made a xNamedConstantUse node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_605;
return ( (NODEPTR) _currn);
}/* Mkrule_605 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_606 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_606 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_606 _currn;
#ifdef __cplusplus
_currn = new _TPrule_606;
#else
_currn = (_TPPrule_606) TreeNodeAlloc (sizeof (struct _TPrule_606));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_606;
_currn->_desc1 = (_TSPxNamedConstantUse) MkxNamedConstantUse (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_606: root of subtree no. 1 can not be made a xNamedConstantUse node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_606;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xScon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_606 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_607 (POSITION *_coordref, int _TERM1, int _TERM2)
#else
NODEPTR Mkrule_607 (_coordref, _TERM1, _TERM2)
	POSITION *_coordref;
	int _TERM1;
	int _TERM2;
#endif
{	_TPPrule_607 _currn;
#ifdef __cplusplus
_currn = new _TPrule_607;
#else
_currn = (_TPPrule_607) TreeNodeAlloc (sizeof (struct _TPrule_607));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_607;
_SETCOORD(_currn)
_TERMACT_rule_607;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xScon", _TERM2);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_607 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_608 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_608 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_608 _currn;
#ifdef __cplusplus
_currn = new _TPrule_608;
#else
_currn = (_TPPrule_608) TreeNodeAlloc (sizeof (struct _TPrule_608));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_608;
_SETCOORD(_currn)
_TERMACT_rule_608;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xHcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_608 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_609 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_609 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_609 _currn;
#ifdef __cplusplus
_currn = new _TPrule_609;
#else
_currn = (_TPPrule_609) TreeNodeAlloc (sizeof (struct _TPrule_609));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_609;
_currn->_desc1 = (_TSPxBozLiteralConstant) MkxBozLiteralConstant (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_609: root of subtree no. 1 can not be made a xBozLiteralConstant node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_609;
return ( (NODEPTR) _currn);
}/* Mkrule_609 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_610 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_610 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_610 _currn;
#ifdef __cplusplus
_currn = new _TPrule_610;
#else
_currn = (_TPPrule_610) TreeNodeAlloc (sizeof (struct _TPrule_610));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_610;
_currn->_desc1 = (_TSPxLogicalConstant) MkxLogicalConstant (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_610: root of subtree no. 1 can not be made a xLogicalConstant node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_610;
return ( (NODEPTR) _currn);
}/* Mkrule_610 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_611 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_611 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_611 _currn;
#ifdef __cplusplus
_currn = new _TPrule_611;
#else
_currn = (_TPPrule_611) TreeNodeAlloc (sizeof (struct _TPrule_611));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_611;
_currn->_desc1 = (_TSPxLogicalConstant) MkxLogicalConstant (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_611: root of subtree no. 1 can not be made a xLogicalConstant node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_611;
return ( (NODEPTR) _currn);
}/* Mkrule_611 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_612 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_612 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_612 _currn;
#ifdef __cplusplus
_currn = new _TPrule_612;
#else
_currn = (_TPPrule_612) TreeNodeAlloc (sizeof (struct _TPrule_612));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_612;
_currn->_desc1 = (_TSPxUnsignedArithmeticConstant) MkxUnsignedArithmeticConstant (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_612: root of subtree no. 1 can not be made a xUnsignedArithmeticConstant node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_612;
return ( (NODEPTR) _currn);
}/* Mkrule_612 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_613 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_613 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_613 _currn;
#ifdef __cplusplus
_currn = new _TPrule_613;
#else
_currn = (_TPPrule_613) TreeNodeAlloc (sizeof (struct _TPrule_613));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_613;
_SETCOORD(_currn)
_TERMACT_rule_613;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xScon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_613 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_614 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_614 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_614 _currn;
#ifdef __cplusplus
_currn = new _TPrule_614;
#else
_currn = (_TPPrule_614) TreeNodeAlloc (sizeof (struct _TPrule_614));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_614;
_currn->_desc1 = (_TSPxUnsignedArithmeticConstant) MkxUnsignedArithmeticConstant (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_614: root of subtree no. 1 can not be made a xUnsignedArithmeticConstant node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_614;
return ( (NODEPTR) _currn);
}/* Mkrule_614 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_615 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_615 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_615 _currn;
#ifdef __cplusplus
_currn = new _TPrule_615;
#else
_currn = (_TPPrule_615) TreeNodeAlloc (sizeof (struct _TPrule_615));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_615;
_currn->_desc1 = (_TSPxUnsignedArithmeticConstant) MkxUnsignedArithmeticConstant (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_615: root of subtree no. 1 can not be made a xUnsignedArithmeticConstant node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_615;
return ( (NODEPTR) _currn);
}/* Mkrule_615 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_616 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_616 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_616 _currn;
#ifdef __cplusplus
_currn = new _TPrule_616;
#else
_currn = (_TPPrule_616) TreeNodeAlloc (sizeof (struct _TPrule_616));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_616;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_616: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_616;
return ( (NODEPTR) _currn);
}/* Mkrule_616 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_617 (POSITION *_coordref)
#else
NODEPTR Mkrule_617 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_617 _currn;
#ifdef __cplusplus
_currn = new _TPrule_617;
#else
_currn = (_TPPrule_617) TreeNodeAlloc (sizeof (struct _TPrule_617));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_617;
_SETCOORD(_currn)
_TERMACT_rule_617;
return ( (NODEPTR) _currn);
}/* Mkrule_617 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_618 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_618 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_618 _currn;
#ifdef __cplusplus
_currn = new _TPrule_618;
#else
_currn = (_TPPrule_618) TreeNodeAlloc (sizeof (struct _TPrule_618));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_618;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_618: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_618;
return ( (NODEPTR) _currn);
}/* Mkrule_618 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_619 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_619 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_619 _currn;
#ifdef __cplusplus
_currn = new _TPrule_619;
#else
_currn = (_TPPrule_619) TreeNodeAlloc (sizeof (struct _TPrule_619));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_619;
_currn->_desc1 = (_TSPxCharLenParamValue) MkxCharLenParamValue (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_619: root of subtree no. 1 can not be made a xCharLenParamValue node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_619;
return ( (NODEPTR) _currn);
}/* Mkrule_619 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_620 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_620 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_620 _currn;
#ifdef __cplusplus
_currn = new _TPrule_620;
#else
_currn = (_TPPrule_620) TreeNodeAlloc (sizeof (struct _TPrule_620));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_620;
_currn->_desc1 = (_TSPxCharLenParamValue) MkxCharLenParamValue (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_620: root of subtree no. 1 can not be made a xCharLenParamValue node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_620: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_620;
return ( (NODEPTR) _currn);
}/* Mkrule_620 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_621 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_621 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_621 _currn;
#ifdef __cplusplus
_currn = new _TPrule_621;
#else
_currn = (_TPPrule_621) TreeNodeAlloc (sizeof (struct _TPrule_621));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_621;
_currn->_desc1 = (_TSPxCharLenParamValue) MkxCharLenParamValue (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_621: root of subtree no. 1 can not be made a xCharLenParamValue node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_621: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_621;
return ( (NODEPTR) _currn);
}/* Mkrule_621 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_622 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_622 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_622 _currn;
#ifdef __cplusplus
_currn = new _TPrule_622;
#else
_currn = (_TPPrule_622) TreeNodeAlloc (sizeof (struct _TPrule_622));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_622;
_currn->_desc1 = (_TSPxCharLenParamValue) MkxCharLenParamValue (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_622: root of subtree no. 1 can not be made a xCharLenParamValue node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_622;
return ( (NODEPTR) _currn);
}/* Mkrule_622 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_623 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_623 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_623 _currn;
#ifdef __cplusplus
_currn = new _TPrule_623;
#else
_currn = (_TPPrule_623) TreeNodeAlloc (sizeof (struct _TPrule_623));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_623;
_currn->_desc1 = (_TSPxCharLenParamValue) MkxCharLenParamValue (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_623: root of subtree no. 1 can not be made a xCharLenParamValue node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_623;
return ( (NODEPTR) _currn);
}/* Mkrule_623 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_624 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_624 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_624 _currn;
#ifdef __cplusplus
_currn = new _TPrule_624;
#else
_currn = (_TPPrule_624) TreeNodeAlloc (sizeof (struct _TPrule_624));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_624;
_SETCOORD(_currn)
_TERMACT_rule_624;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_624 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_625 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_625 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_625 _currn;
#ifdef __cplusplus
_currn = new _TPrule_625;
#else
_currn = (_TPPrule_625) TreeNodeAlloc (sizeof (struct _TPrule_625));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_625;
_currn->_desc1 = (_TSPxCharLength) MkxCharLength (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_625: root of subtree no. 1 can not be made a xCharLength node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_625;
return ( (NODEPTR) _currn);
}/* Mkrule_625 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_626 (POSITION *_coordref)
#else
NODEPTR Mkrule_626 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_626 _currn;
#ifdef __cplusplus
_currn = new _TPrule_626;
#else
_currn = (_TPPrule_626) TreeNodeAlloc (sizeof (struct _TPrule_626));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_626;
_SETCOORD(_currn)
_TERMACT_rule_626;
return ( (NODEPTR) _currn);
}/* Mkrule_626 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_627 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_627 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_627 _currn;
#ifdef __cplusplus
_currn = new _TPrule_627;
#else
_currn = (_TPPrule_627) TreeNodeAlloc (sizeof (struct _TPrule_627));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_627;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_627: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_627;
return ( (NODEPTR) _currn);
}/* Mkrule_627 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_628 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_628 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_628 _currn;
#ifdef __cplusplus
_currn = new _TPrule_628;
#else
_currn = (_TPPrule_628) TreeNodeAlloc (sizeof (struct _TPrule_628));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_628;
_SETCOORD(_currn)
_TERMACT_rule_628;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_628 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_629 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_629 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_629 _currn;
#ifdef __cplusplus
_currn = new _TPrule_629;
#else
_currn = (_TPPrule_629) TreeNodeAlloc (sizeof (struct _TPrule_629));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_629;
_currn->_desc1 = (_TSPxNamedConstant) MkxNamedConstant (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_629: root of subtree no. 1 can not be made a xNamedConstant node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_629: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_629;
return ( (NODEPTR) _currn);
}/* Mkrule_629 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_630 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_630 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_630 _currn;
#ifdef __cplusplus
_currn = new _TPrule_630;
#else
_currn = (_TPPrule_630) TreeNodeAlloc (sizeof (struct _TPrule_630));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_630;
_currn->_desc1 = (_TSPxNamedConstantDefList) MkxNamedConstantDefList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_630: root of subtree no. 1 can not be made a xNamedConstantDefList node ", 0, _coordref);
_currn->_desc2 = (_TSPxNamedConstantDef) MkxNamedConstantDef (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_630: root of subtree no. 2 can not be made a xNamedConstantDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_630;
return ( (NODEPTR) _currn);
}/* Mkrule_630 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_631 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_631 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_631 _currn;
#ifdef __cplusplus
_currn = new _TPrule_631;
#else
_currn = (_TPPrule_631) TreeNodeAlloc (sizeof (struct _TPrule_631));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_631;
_currn->_desc1 = (_TSPxNamedConstantDef) MkxNamedConstantDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_631: root of subtree no. 1 can not be made a xNamedConstantDef node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_631;
return ( (NODEPTR) _currn);
}/* Mkrule_631 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_632 (POSITION *_coordref)
#else
NODEPTR Mkrule_632 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_632 _currn;
#ifdef __cplusplus
_currn = new _TPrule_632;
#else
_currn = (_TPPrule_632) TreeNodeAlloc (sizeof (struct _TPrule_632));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_632;
_SETCOORD(_currn)
_TERMACT_rule_632;
return ( (NODEPTR) _currn);
}/* Mkrule_632 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_633 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_633 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_633 _currn;
#ifdef __cplusplus
_currn = new _TPrule_633;
#else
_currn = (_TPPrule_633) TreeNodeAlloc (sizeof (struct _TPrule_633));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_633;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_633: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_633: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_633;
return ( (NODEPTR) _currn);
}/* Mkrule_633 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_634 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_634 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_634 _currn;
#ifdef __cplusplus
_currn = new _TPrule_634;
#else
_currn = (_TPPrule_634) TreeNodeAlloc (sizeof (struct _TPrule_634));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_634;
_currn->_desc1 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_634: root of subtree no. 1 can not be made a xSectionSubscriptList node ", 0, _coordref);
_currn->_desc2 = (_TSPxSectionSubscript) MkxSectionSubscript (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_634: root of subtree no. 2 can not be made a xSectionSubscript node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_634;
return ( (NODEPTR) _currn);
}/* Mkrule_634 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_635 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_635 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_635 _currn;
#ifdef __cplusplus
_currn = new _TPrule_635;
#else
_currn = (_TPPrule_635) TreeNodeAlloc (sizeof (struct _TPrule_635));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_635;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_635: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_635;
return ( (NODEPTR) _currn);
}/* Mkrule_635 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_636 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_636 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_636 _currn;
#ifdef __cplusplus
_currn = new _TPrule_636;
#else
_currn = (_TPPrule_636) TreeNodeAlloc (sizeof (struct _TPrule_636));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_636;
_currn->_desc1 = (_TSPxAllocateObject) MkxAllocateObject (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_636: root of subtree no. 1 can not be made a xAllocateObject node ", 0, _coordref);
_currn->_desc2 = (_TSPxAllocatedShape) MkxAllocatedShape (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_636: root of subtree no. 2 can not be made a xAllocatedShape node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_636;
return ( (NODEPTR) _currn);
}/* Mkrule_636 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_637 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_637 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_637 _currn;
#ifdef __cplusplus
_currn = new _TPrule_637;
#else
_currn = (_TPPrule_637) TreeNodeAlloc (sizeof (struct _TPrule_637));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_637;
_currn->_desc1 = (_TSPAllocateDeclarators) MkAllocateDeclarators (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_637: root of subtree no. 1 can not be made a AllocateDeclarators node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_637;
return ( (NODEPTR) _currn);
}/* Mkrule_637 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_638 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_638 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_638 _currn;
#ifdef __cplusplus
_currn = new _TPrule_638;
#else
_currn = (_TPPrule_638) TreeNodeAlloc (sizeof (struct _TPrule_638));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_638;
_currn->_desc1 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_638: root of subtree no. 1 can not be made a xSectionSubscriptList node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_638;
return ( (NODEPTR) _currn);
}/* Mkrule_638 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_639 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_639 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_639 _currn;
#ifdef __cplusplus
_currn = new _TPrule_639;
#else
_currn = (_TPPrule_639) TreeNodeAlloc (sizeof (struct _TPrule_639));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_639;
_currn->_desc1 = (_TSPxArraySpec) MkxArraySpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_639: root of subtree no. 1 can not be made a xArraySpec node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_639;
return ( (NODEPTR) _currn);
}/* Mkrule_639 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_640 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_640 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_640 _currn;
#ifdef __cplusplus
_currn = new _TPrule_640;
#else
_currn = (_TPPrule_640) TreeNodeAlloc (sizeof (struct _TPrule_640));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_640;
_currn->_desc1 = (_TSPxObjectName) MkxObjectName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_640: root of subtree no. 1 can not be made a xObjectName node ", 0, _coordref);
_currn->_desc2 = (_TSPxInitialization) MkxInitialization (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_640: root of subtree no. 2 can not be made a xInitialization node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_640;
return ( (NODEPTR) _currn);
}/* Mkrule_640 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_641 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_641 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_641 _currn;
#ifdef __cplusplus
_currn = new _TPrule_641;
#else
_currn = (_TPPrule_641) TreeNodeAlloc (sizeof (struct _TPrule_641));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_641;
_currn->_desc1 = (_TSPxObjectName) MkxObjectName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_641: root of subtree no. 1 can not be made a xObjectName node ", 0, _coordref);
_currn->_desc2 = (_TSPxCharLength) MkxCharLength (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_641: root of subtree no. 2 can not be made a xCharLength node ", 0, _coordref);
_currn->_desc3 = (_TSPxInitialization) MkxInitialization (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_641: root of subtree no. 3 can not be made a xInitialization node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_641;
return ( (NODEPTR) _currn);
}/* Mkrule_641 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_642 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_642 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_642 _currn;
#ifdef __cplusplus
_currn = new _TPrule_642;
#else
_currn = (_TPPrule_642) TreeNodeAlloc (sizeof (struct _TPrule_642));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_642;
_currn->_desc1 = (_TSPxObjectName) MkxObjectName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_642: root of subtree no. 1 can not be made a xObjectName node ", 0, _coordref);
_currn->_desc2 = (_TSPxCharLength) MkxCharLength (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_642: root of subtree no. 2 can not be made a xCharLength node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_642;
return ( (NODEPTR) _currn);
}/* Mkrule_642 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_643 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_643 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_643 _currn;
#ifdef __cplusplus
_currn = new _TPrule_643;
#else
_currn = (_TPPrule_643) TreeNodeAlloc (sizeof (struct _TPrule_643));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_643;
_currn->_desc1 = (_TSPxObjectName) MkxObjectName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_643: root of subtree no. 1 can not be made a xObjectName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_643;
return ( (NODEPTR) _currn);
}/* Mkrule_643 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_644 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_644 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_644 _currn;
#ifdef __cplusplus
_currn = new _TPrule_644;
#else
_currn = (_TPPrule_644) TreeNodeAlloc (sizeof (struct _TPrule_644));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_644;
_currn->_desc1 = (_TSPxLowerBound) MkxLowerBound (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_644: root of subtree no. 1 can not be made a xLowerBound node ", 0, _coordref);
_currn->_desc2 = (_TSPxUpperBound) MkxUpperBound (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_644: root of subtree no. 2 can not be made a xUpperBound node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_644;
return ( (NODEPTR) _currn);
}/* Mkrule_644 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_645 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_645 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_645 _currn;
#ifdef __cplusplus
_currn = new _TPrule_645;
#else
_currn = (_TPPrule_645) TreeNodeAlloc (sizeof (struct _TPrule_645));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_645;
_currn->_desc1 = (_TSPxUpperBound) MkxUpperBound (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_645: root of subtree no. 1 can not be made a xUpperBound node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_645;
return ( (NODEPTR) _currn);
}/* Mkrule_645 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_646 (POSITION *_coordref)
#else
NODEPTR Mkrule_646 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_646 _currn;
#ifdef __cplusplus
_currn = new _TPrule_646;
#else
_currn = (_TPPrule_646) TreeNodeAlloc (sizeof (struct _TPrule_646));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_646;
_SETCOORD(_currn)
_TERMACT_rule_646;
return ( (NODEPTR) _currn);
}/* Mkrule_646 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_647 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_647 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_647 _currn;
#ifdef __cplusplus
_currn = new _TPrule_647;
#else
_currn = (_TPPrule_647) TreeNodeAlloc (sizeof (struct _TPrule_647));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_647;
_currn->_desc1 = (_TSPxLowerBound) MkxLowerBound (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_647: root of subtree no. 1 can not be made a xLowerBound node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_647;
return ( (NODEPTR) _currn);
}/* Mkrule_647 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_648 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_648 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_648 _currn;
#ifdef __cplusplus
_currn = new _TPrule_648;
#else
_currn = (_TPPrule_648) TreeNodeAlloc (sizeof (struct _TPrule_648));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_648;
_currn->_desc1 = (_TSPxArrayName) MkxArrayName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_648: root of subtree no. 1 can not be made a xArrayName node ", 0, _coordref);
_currn->_desc2 = (_TSPDimensionDeclarators) MkDimensionDeclarators (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_648: root of subtree no. 2 can not be made a DimensionDeclarators node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_648;
return ( (NODEPTR) _currn);
}/* Mkrule_648 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_649 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_649 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_649 _currn;
#ifdef __cplusplus
_currn = new _TPrule_649;
#else
_currn = (_TPPrule_649) TreeNodeAlloc (sizeof (struct _TPrule_649));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_649;
_SETCOORD(_currn)
_TERMACT_rule_649;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_649 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_650 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_650 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_650 _currn;
#ifdef __cplusplus
_currn = new _TPrule_650;
#else
_currn = (_TPPrule_650) TreeNodeAlloc (sizeof (struct _TPrule_650));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_650;
_SETCOORD(_currn)
_TERMACT_rule_650;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_650 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_651 (POSITION *_coordref, int _TERM1, NODEPTR _desc1)
#else
NODEPTR Mkrule_651 (_coordref, _TERM1,_desc1)
	POSITION *_coordref;
	int _TERM1;
	NODEPTR _desc1;
#endif
{	_TPPrule_651 _currn;
#ifdef __cplusplus
_currn = new _TPrule_651;
#else
_currn = (_TPPrule_651) TreeNodeAlloc (sizeof (struct _TPrule_651));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_651;
_currn->_desc1 = (_TSPxUseName) MkxUseName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_651: root of subtree no. 1 can not be made a xUseName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_651;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_651 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_652 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_652 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_652 _currn;
#ifdef __cplusplus
_currn = new _TPrule_652;
#else
_currn = (_TPPrule_652) TreeNodeAlloc (sizeof (struct _TPrule_652));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_652;
_currn->_desc1 = (_TSPxGenericSpec) MkxGenericSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_652: root of subtree no. 1 can not be made a xGenericSpec node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_652;
return ( (NODEPTR) _currn);
}/* Mkrule_652 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_653 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_653 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_653 _currn;
#ifdef __cplusplus
_currn = new _TPrule_653;
#else
_currn = (_TPPrule_653) TreeNodeAlloc (sizeof (struct _TPrule_653));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_653;
_currn->_desc1 = (_TSPxUseName) MkxUseName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_653: root of subtree no. 1 can not be made a xUseName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_653;
return ( (NODEPTR) _currn);
}/* Mkrule_653 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_654 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_654 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_654 _currn;
#ifdef __cplusplus
_currn = new _TPrule_654;
#else
_currn = (_TPPrule_654) TreeNodeAlloc (sizeof (struct _TPrule_654));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_654;
_currn->_desc1 = (_TSPxOnlyList) MkxOnlyList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_654: root of subtree no. 1 can not be made a xOnlyList node ", 0, _coordref);
_currn->_desc2 = (_TSPxOnly) MkxOnly (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_654: root of subtree no. 2 can not be made a xOnly node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_654;
return ( (NODEPTR) _currn);
}/* Mkrule_654 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_655 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_655 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_655 _currn;
#ifdef __cplusplus
_currn = new _TPrule_655;
#else
_currn = (_TPPrule_655) TreeNodeAlloc (sizeof (struct _TPrule_655));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_655;
_currn->_desc1 = (_TSPxOnly) MkxOnly (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_655: root of subtree no. 1 can not be made a xOnly node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_655;
return ( (NODEPTR) _currn);
}/* Mkrule_655 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_656 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_656 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_656 _currn;
#ifdef __cplusplus
_currn = new _TPrule_656;
#else
_currn = (_TPPrule_656) TreeNodeAlloc (sizeof (struct _TPrule_656));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_656;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_656: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_656: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxOnlyList) MkxOnlyList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_656: root of subtree no. 3 can not be made a xOnlyList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_656;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_656 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_657 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_657 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_657 _currn;
#ifdef __cplusplus
_currn = new _TPrule_657;
#else
_currn = (_TPPrule_657) TreeNodeAlloc (sizeof (struct _TPrule_657));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_657;
_currn->_desc1 = (_TSPxBlockDataStmt) MkxBlockDataStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_657: root of subtree no. 1 can not be made a xBlockDataStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndBlockDataStmt) MkxEndBlockDataStmt (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_657: root of subtree no. 2 can not be made a xEndBlockDataStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_657;
return ( (NODEPTR) _currn);
}/* Mkrule_657 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_658 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_658 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_658 _currn;
#ifdef __cplusplus
_currn = new _TPrule_658;
#else
_currn = (_TPPrule_658) TreeNodeAlloc (sizeof (struct _TPrule_658));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_658;
_currn->_desc1 = (_TSPxBlockDataStmt) MkxBlockDataStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_658: root of subtree no. 1 can not be made a xBlockDataStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxBody) MkxBody (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_658: root of subtree no. 2 can not be made a xBody node ", 0, _coordref);
_currn->_desc3 = (_TSPxEndBlockDataStmt) MkxEndBlockDataStmt (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_658: root of subtree no. 3 can not be made a xEndBlockDataStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_658;
return ( (NODEPTR) _currn);
}/* Mkrule_658 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_659 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_659 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_659 _currn;
#ifdef __cplusplus
_currn = new _TPrule_659;
#else
_currn = (_TPPrule_659) TreeNodeAlloc (sizeof (struct _TPrule_659));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_659;
_currn->_desc1 = (_TSPxMainRange) MkxMainRange (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_659: root of subtree no. 1 can not be made a xMainRange node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_659;
return ( (NODEPTR) _currn);
}/* Mkrule_659 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_660 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_660 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_660 _currn;
#ifdef __cplusplus
_currn = new _TPrule_660;
#else
_currn = (_TPPrule_660) TreeNodeAlloc (sizeof (struct _TPrule_660));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_660;
_currn->_desc1 = (_TSPxProgramStmt) MkxProgramStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_660: root of subtree no. 1 can not be made a xProgramStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxMainRange) MkxMainRange (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_660: root of subtree no. 2 can not be made a xMainRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_660;
return ( (NODEPTR) _currn);
}/* Mkrule_660 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_661 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_661 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_661 _currn;
#ifdef __cplusplus
_currn = new _TPrule_661;
#else
_currn = (_TPPrule_661) TreeNodeAlloc (sizeof (struct _TPrule_661));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_661;
_currn->_desc1 = (_TSPAccRoutine) MkAccRoutine (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_661: root of subtree no. 1 can not be made a AccRoutine node ", 0, _coordref);
_currn->_desc2 = (_TSPxSubroutineStmt) MkxSubroutineStmt (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_661: root of subtree no. 2 can not be made a xSubroutineStmt node ", 0, _coordref);
_currn->_desc3 = (_TSPxSubprogramRange) MkxSubprogramRange (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_661: root of subtree no. 3 can not be made a xSubprogramRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_661;
return ( (NODEPTR) _currn);
}/* Mkrule_661 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_662 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_662 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_662 _currn;
#ifdef __cplusplus
_currn = new _TPrule_662;
#else
_currn = (_TPPrule_662) TreeNodeAlloc (sizeof (struct _TPrule_662));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_662;
_currn->_desc1 = (_TSPxSubroutineStmt) MkxSubroutineStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_662: root of subtree no. 1 can not be made a xSubroutineStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxSubprogramRange) MkxSubprogramRange (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_662: root of subtree no. 2 can not be made a xSubprogramRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_662;
return ( (NODEPTR) _currn);
}/* Mkrule_662 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_663 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_663 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_663 _currn;
#ifdef __cplusplus
_currn = new _TPrule_663;
#else
_currn = (_TPPrule_663) TreeNodeAlloc (sizeof (struct _TPrule_663));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_663;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_663: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_currn->_desc2 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_663: root of subtree no. 2 can not be made a xSectionSubscriptList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_663;
return ( (NODEPTR) _currn);
}/* Mkrule_663 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_664 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_664 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_664 _currn;
#ifdef __cplusplus
_currn = new _TPrule_664;
#else
_currn = (_TPPrule_664) TreeNodeAlloc (sizeof (struct _TPrule_664));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_664;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_664: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_currn->_desc2 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_664: root of subtree no. 2 can not be made a xSectionSubscriptList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_664;
return ( (NODEPTR) _currn);
}/* Mkrule_664 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_665 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_665 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_665 _currn;
#ifdef __cplusplus
_currn = new _TPrule_665;
#else
_currn = (_TPPrule_665) TreeNodeAlloc (sizeof (struct _TPrule_665));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_665;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_665: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_665;
return ( (NODEPTR) _currn);
}/* Mkrule_665 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_666 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_666 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_666 _currn;
#ifdef __cplusplus
_currn = new _TPrule_666;
#else
_currn = (_TPPrule_666) TreeNodeAlloc (sizeof (struct _TPrule_666));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_666;
_currn->_desc1 = (_TSPxSubscriptTriplet) MkxSubscriptTriplet (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_666: root of subtree no. 1 can not be made a xSubscriptTriplet node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_666;
return ( (NODEPTR) _currn);
}/* Mkrule_666 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_667 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_667 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_667 _currn;
#ifdef __cplusplus
_currn = new _TPrule_667;
#else
_currn = (_TPPrule_667) TreeNodeAlloc (sizeof (struct _TPrule_667));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_667;
_currn->_desc1 = (_TSPxSectionSubscript) MkxSectionSubscript (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_667: root of subtree no. 1 can not be made a xSectionSubscript node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_667;
return ( (NODEPTR) _currn);
}/* Mkrule_667 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_668 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_668 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_668 _currn;
#ifdef __cplusplus
_currn = new _TPrule_668;
#else
_currn = (_TPPrule_668) TreeNodeAlloc (sizeof (struct _TPrule_668));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_668;
_currn->_desc1 = (_TSPAccRoutine) MkAccRoutine (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_668: root of subtree no. 1 can not be made a AccRoutine node ", 0, _coordref);
_currn->_desc2 = (_TSPxFunctionStmt) MkxFunctionStmt (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_668: root of subtree no. 2 can not be made a xFunctionStmt node ", 0, _coordref);
_currn->_desc3 = (_TSPxSubprogramRange) MkxSubprogramRange (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_668: root of subtree no. 3 can not be made a xSubprogramRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_668;
return ( (NODEPTR) _currn);
}/* Mkrule_668 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_669 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_669 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_669 _currn;
#ifdef __cplusplus
_currn = new _TPrule_669;
#else
_currn = (_TPPrule_669) TreeNodeAlloc (sizeof (struct _TPrule_669));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_669;
_currn->_desc1 = (_TSPxModule) MkxModule (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_669: root of subtree no. 1 can not be made a xModule node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_669;
return ( (NODEPTR) _currn);
}/* Mkrule_669 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_670 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_670 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_670 _currn;
#ifdef __cplusplus
_currn = new _TPrule_670;
#else
_currn = (_TPPrule_670) TreeNodeAlloc (sizeof (struct _TPrule_670));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_670;
_currn->_desc1 = (_TSPxFunctionStmt) MkxFunctionStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_670: root of subtree no. 1 can not be made a xFunctionStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxSubprogramRange) MkxSubprogramRange (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_670: root of subtree no. 2 can not be made a xSubprogramRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_670;
return ( (NODEPTR) _currn);
}/* Mkrule_670 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_671 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_671 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_671 _currn;
#ifdef __cplusplus
_currn = new _TPrule_671;
#else
_currn = (_TPPrule_671) TreeNodeAlloc (sizeof (struct _TPrule_671));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_671;
_currn->_desc1 = (_TSPxCommonBlockName) MkxCommonBlockName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_671: root of subtree no. 1 can not be made a xCommonBlockName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_671;
return ( (NODEPTR) _currn);
}/* Mkrule_671 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_672 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_672 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_672 _currn;
#ifdef __cplusplus
_currn = new _TPrule_672;
#else
_currn = (_TPPrule_672) TreeNodeAlloc (sizeof (struct _TPrule_672));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_672;
_currn->_desc1 = (_TSPxTypeSpec) MkxTypeSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_672: root of subtree no. 1 can not be made a xTypeSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_672;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xImpl", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_672 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_673 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_673 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_673 _currn;
#ifdef __cplusplus
_currn = new _TPrule_673;
#else
_currn = (_TPPrule_673) TreeNodeAlloc (sizeof (struct _TPrule_673));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_673;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_673: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxTypeSpec) MkxTypeSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_673: root of subtree no. 2 can not be made a xTypeSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPxEntityDeclList) MkxEntityDeclList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_673: root of subtree no. 3 can not be made a xEntityDeclList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_673;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_673 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_674 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_674 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_674 _currn;
#ifdef __cplusplus
_currn = new _TPrule_674;
#else
_currn = (_TPPrule_674) TreeNodeAlloc (sizeof (struct _TPrule_674));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_674;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_674: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxTypeSpec) MkxTypeSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_674: root of subtree no. 2 can not be made a xTypeSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPxEntityDeclList) MkxEntityDeclList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_674: root of subtree no. 3 can not be made a xEntityDeclList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_674;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_674 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_675 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, int _TERM1)
#else
NODEPTR Mkrule_675 (_coordref,_desc1,_desc2,_desc3,_desc4, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	int _TERM1;
#endif
{	_TPPrule_675 _currn;
#ifdef __cplusplus
_currn = new _TPrule_675;
#else
_currn = (_TPPrule_675) TreeNodeAlloc (sizeof (struct _TPrule_675));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_675;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_675: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxTypeSpec) MkxTypeSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_675: root of subtree no. 2 can not be made a xTypeSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPxAttrSpecSeq) MkxAttrSpecSeq (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_675: root of subtree no. 3 can not be made a xAttrSpecSeq node ", 0, _coordref);
_currn->_desc4 = (_TSPxEntityDeclList) MkxEntityDeclList (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_675: root of subtree no. 4 can not be made a xEntityDeclList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_675;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_675 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_676 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_676 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_676 _currn;
#ifdef __cplusplus
_currn = new _TPrule_676;
#else
_currn = (_TPPrule_676) TreeNodeAlloc (sizeof (struct _TPrule_676));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_676;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_676: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_676;
return ( (NODEPTR) _currn);
}/* Mkrule_676 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_677 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_677 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_677 _currn;
#ifdef __cplusplus
_currn = new _TPrule_677;
#else
_currn = (_TPPrule_677) TreeNodeAlloc (sizeof (struct _TPrule_677));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_677;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_677: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_677;
return ( (NODEPTR) _currn);
}/* Mkrule_677 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_678 (POSITION *_coordref)
#else
NODEPTR Mkrule_678 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_678 _currn;
#ifdef __cplusplus
_currn = new _TPrule_678;
#else
_currn = (_TPPrule_678) TreeNodeAlloc (sizeof (struct _TPrule_678));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_678;
_SETCOORD(_currn)
_TERMACT_rule_678;
return ( (NODEPTR) _currn);
}/* Mkrule_678 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_679 (POSITION *_coordref)
#else
NODEPTR Mkrule_679 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_679 _currn;
#ifdef __cplusplus
_currn = new _TPrule_679;
#else
_currn = (_TPPrule_679) TreeNodeAlloc (sizeof (struct _TPrule_679));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_679;
_SETCOORD(_currn)
_TERMACT_rule_679;
return ( (NODEPTR) _currn);
}/* Mkrule_679 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_680 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_680 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_680 _currn;
#ifdef __cplusplus
_currn = new _TPrule_680;
#else
_currn = (_TPPrule_680) TreeNodeAlloc (sizeof (struct _TPrule_680));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_680;
_currn->_desc1 = (_TSPxCharSelector) MkxCharSelector (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_680: root of subtree no. 1 can not be made a xCharSelector node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_680;
return ( (NODEPTR) _currn);
}/* Mkrule_680 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_681 (POSITION *_coordref)
#else
NODEPTR Mkrule_681 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_681 _currn;
#ifdef __cplusplus
_currn = new _TPrule_681;
#else
_currn = (_TPPrule_681) TreeNodeAlloc (sizeof (struct _TPrule_681));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_681;
_SETCOORD(_currn)
_TERMACT_rule_681;
return ( (NODEPTR) _currn);
}/* Mkrule_681 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_682 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_682 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_682 _currn;
#ifdef __cplusplus
_currn = new _TPrule_682;
#else
_currn = (_TPPrule_682) TreeNodeAlloc (sizeof (struct _TPrule_682));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_682;
_currn->_desc1 = (_TSPxCharSelector) MkxCharSelector (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_682: root of subtree no. 1 can not be made a xCharSelector node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_682;
return ( (NODEPTR) _currn);
}/* Mkrule_682 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_683 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_683 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_683 _currn;
#ifdef __cplusplus
_currn = new _TPrule_683;
#else
_currn = (_TPPrule_683) TreeNodeAlloc (sizeof (struct _TPrule_683));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_683;
_currn->_desc1 = (_TSPxCharSelector) MkxCharSelector (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_683: root of subtree no. 1 can not be made a xCharSelector node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_683;
return ( (NODEPTR) _currn);
}/* Mkrule_683 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_684 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_684 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_684 _currn;
#ifdef __cplusplus
_currn = new _TPrule_684;
#else
_currn = (_TPPrule_684) TreeNodeAlloc (sizeof (struct _TPrule_684));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_684;
_currn->_desc1 = (_TSPxCharSelector) MkxCharSelector (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_684: root of subtree no. 1 can not be made a xCharSelector node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_684;
return ( (NODEPTR) _currn);
}/* Mkrule_684 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_685 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_685 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_685 _currn;
#ifdef __cplusplus
_currn = new _TPrule_685;
#else
_currn = (_TPPrule_685) TreeNodeAlloc (sizeof (struct _TPrule_685));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_685;
_currn->_desc1 = (_TSPxCharSelector) MkxCharSelector (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_685: root of subtree no. 1 can not be made a xCharSelector node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_685;
return ( (NODEPTR) _currn);
}/* Mkrule_685 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_686 (POSITION *_coordref)
#else
NODEPTR Mkrule_686 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_686 _currn;
#ifdef __cplusplus
_currn = new _TPrule_686;
#else
_currn = (_TPPrule_686) TreeNodeAlloc (sizeof (struct _TPrule_686));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_686;
_SETCOORD(_currn)
_TERMACT_rule_686;
return ( (NODEPTR) _currn);
}/* Mkrule_686 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_687 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_687 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_687 _currn;
#ifdef __cplusplus
_currn = new _TPrule_687;
#else
_currn = (_TPPrule_687) TreeNodeAlloc (sizeof (struct _TPrule_687));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_687;
_currn->_desc1 = (_TSPxKindSelector) MkxKindSelector (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_687: root of subtree no. 1 can not be made a xKindSelector node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_687;
return ( (NODEPTR) _currn);
}/* Mkrule_687 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_688 (POSITION *_coordref)
#else
NODEPTR Mkrule_688 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_688 _currn;
#ifdef __cplusplus
_currn = new _TPrule_688;
#else
_currn = (_TPPrule_688) TreeNodeAlloc (sizeof (struct _TPrule_688));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_688;
_SETCOORD(_currn)
_TERMACT_rule_688;
return ( (NODEPTR) _currn);
}/* Mkrule_688 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_689 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_689 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_689 _currn;
#ifdef __cplusplus
_currn = new _TPrule_689;
#else
_currn = (_TPPrule_689) TreeNodeAlloc (sizeof (struct _TPrule_689));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_689;
_currn->_desc1 = (_TSPxKindSelector) MkxKindSelector (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_689: root of subtree no. 1 can not be made a xKindSelector node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_689;
return ( (NODEPTR) _currn);
}/* Mkrule_689 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_690 (POSITION *_coordref)
#else
NODEPTR Mkrule_690 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_690 _currn;
#ifdef __cplusplus
_currn = new _TPrule_690;
#else
_currn = (_TPPrule_690) TreeNodeAlloc (sizeof (struct _TPrule_690));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_690;
_SETCOORD(_currn)
_TERMACT_rule_690;
return ( (NODEPTR) _currn);
}/* Mkrule_690 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_691 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_691 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_691 _currn;
#ifdef __cplusplus
_currn = new _TPrule_691;
#else
_currn = (_TPPrule_691) TreeNodeAlloc (sizeof (struct _TPrule_691));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_691;
_currn->_desc1 = (_TSPxKindSelector) MkxKindSelector (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_691: root of subtree no. 1 can not be made a xKindSelector node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_691;
return ( (NODEPTR) _currn);
}/* Mkrule_691 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_692 (POSITION *_coordref)
#else
NODEPTR Mkrule_692 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_692 _currn;
#ifdef __cplusplus
_currn = new _TPrule_692;
#else
_currn = (_TPPrule_692) TreeNodeAlloc (sizeof (struct _TPrule_692));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_692;
_SETCOORD(_currn)
_TERMACT_rule_692;
return ( (NODEPTR) _currn);
}/* Mkrule_692 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_693 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_693 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_693 _currn;
#ifdef __cplusplus
_currn = new _TPrule_693;
#else
_currn = (_TPPrule_693) TreeNodeAlloc (sizeof (struct _TPrule_693));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_693;
_currn->_desc1 = (_TSPxKindSelector) MkxKindSelector (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_693: root of subtree no. 1 can not be made a xKindSelector node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_693;
return ( (NODEPTR) _currn);
}/* Mkrule_693 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_694 (POSITION *_coordref)
#else
NODEPTR Mkrule_694 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_694 _currn;
#ifdef __cplusplus
_currn = new _TPrule_694;
#else
_currn = (_TPPrule_694) TreeNodeAlloc (sizeof (struct _TPrule_694));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_694;
_SETCOORD(_currn)
_TERMACT_rule_694;
return ( (NODEPTR) _currn);
}/* Mkrule_694 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_695 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_695 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_695 _currn;
#ifdef __cplusplus
_currn = new _TPrule_695;
#else
_currn = (_TPPrule_695) TreeNodeAlloc (sizeof (struct _TPrule_695));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_695;
_currn->_desc1 = (_TSPxEntityDeclList) MkxEntityDeclList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_695: root of subtree no. 1 can not be made a xEntityDeclList node ", 0, _coordref);
_currn->_desc2 = (_TSPxEntityDecl) MkxEntityDecl (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_695: root of subtree no. 2 can not be made a xEntityDecl node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_695;
return ( (NODEPTR) _currn);
}/* Mkrule_695 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_696 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_696 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_696 _currn;
#ifdef __cplusplus
_currn = new _TPrule_696;
#else
_currn = (_TPPrule_696) TreeNodeAlloc (sizeof (struct _TPrule_696));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_696;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_696: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxTypeSpec) MkxTypeSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_696: root of subtree no. 2 can not be made a xTypeSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPxComponentDeclList) MkxComponentDeclList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_696: root of subtree no. 3 can not be made a xComponentDeclList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_696;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_696 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_697 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_697 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_697 _currn;
#ifdef __cplusplus
_currn = new _TPrule_697;
#else
_currn = (_TPPrule_697) TreeNodeAlloc (sizeof (struct _TPrule_697));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_697;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_697: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxTypeSpec) MkxTypeSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_697: root of subtree no. 2 can not be made a xTypeSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPxComponentDeclList) MkxComponentDeclList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_697: root of subtree no. 3 can not be made a xComponentDeclList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_697;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_697 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_698 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, int _TERM1)
#else
NODEPTR Mkrule_698 (_coordref,_desc1,_desc2,_desc3,_desc4, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	int _TERM1;
#endif
{	_TPPrule_698 _currn;
#ifdef __cplusplus
_currn = new _TPrule_698;
#else
_currn = (_TPPrule_698) TreeNodeAlloc (sizeof (struct _TPrule_698));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_698;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_698: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxTypeSpec) MkxTypeSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_698: root of subtree no. 2 can not be made a xTypeSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPxComponentAttrSpecList) MkxComponentAttrSpecList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_698: root of subtree no. 3 can not be made a xComponentAttrSpecList node ", 0, _coordref);
_currn->_desc4 = (_TSPxComponentDeclList) MkxComponentDeclList (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_698: root of subtree no. 4 can not be made a xComponentDeclList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_698;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_698 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_699 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_699 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_699 _currn;
#ifdef __cplusplus
_currn = new _TPrule_699;
#else
_currn = (_TPPrule_699) TreeNodeAlloc (sizeof (struct _TPrule_699));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_699;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_699: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxIoControlSpecList) MkxIoControlSpecList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_699: root of subtree no. 2 can not be made a xIoControlSpecList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_699;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_699 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_700 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_700 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_700 _currn;
#ifdef __cplusplus
_currn = new _TPrule_700;
#else
_currn = (_TPPrule_700) TreeNodeAlloc (sizeof (struct _TPrule_700));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_700;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_700: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxUnitIdentifier) MkxUnitIdentifier (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_700: root of subtree no. 2 can not be made a xUnitIdentifier node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_700;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_700 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_701 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_701 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_701 _currn;
#ifdef __cplusplus
_currn = new _TPrule_701;
#else
_currn = (_TPPrule_701) TreeNodeAlloc (sizeof (struct _TPrule_701));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_701;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_701: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_701: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_701;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_701 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_702 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_702 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_702 _currn;
#ifdef __cplusplus
_currn = new _TPrule_702;
#else
_currn = (_TPPrule_702) TreeNodeAlloc (sizeof (struct _TPrule_702));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_702;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_702: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_702: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_702;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_702 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_703 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_703 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_703 _currn;
#ifdef __cplusplus
_currn = new _TPrule_703;
#else
_currn = (_TPPrule_703) TreeNodeAlloc (sizeof (struct _TPrule_703));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_703;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_703: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_703;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_703 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_704 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_704 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_704 _currn;
#ifdef __cplusplus
_currn = new _TPrule_704;
#else
_currn = (_TPPrule_704) TreeNodeAlloc (sizeof (struct _TPrule_704));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_704;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_704: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_704;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_704 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_705 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_705 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_705 _currn;
#ifdef __cplusplus
_currn = new _TPrule_705;
#else
_currn = (_TPPrule_705) TreeNodeAlloc (sizeof (struct _TPrule_705));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_705;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_705: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_705: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_currn->_desc3 = (_TSPxEndName) MkxEndName (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_705: root of subtree no. 3 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_705;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_705 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_706 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_706 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_706 _currn;
#ifdef __cplusplus
_currn = new _TPrule_706;
#else
_currn = (_TPPrule_706) TreeNodeAlloc (sizeof (struct _TPrule_706));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_706;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_706: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_706: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_706;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_706 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_707 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_707 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_707 _currn;
#ifdef __cplusplus
_currn = new _TPrule_707;
#else
_currn = (_TPPrule_707) TreeNodeAlloc (sizeof (struct _TPrule_707));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_707;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_707: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_707: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_707;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_707 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_708 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_708 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_708 _currn;
#ifdef __cplusplus
_currn = new _TPrule_708;
#else
_currn = (_TPPrule_708) TreeNodeAlloc (sizeof (struct _TPrule_708));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_708;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_708: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_708;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_708 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_709 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_709 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_709 _currn;
#ifdef __cplusplus
_currn = new _TPrule_709;
#else
_currn = (_TPPrule_709) TreeNodeAlloc (sizeof (struct _TPrule_709));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_709;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_709: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_709: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_709: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_709;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_709 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_710 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_710 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_710 _currn;
#ifdef __cplusplus
_currn = new _TPrule_710;
#else
_currn = (_TPPrule_710) TreeNodeAlloc (sizeof (struct _TPrule_710));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_710;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_710: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_710: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_currn->_desc3 = (_TSPxStmt) MkxStmt (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_710: root of subtree no. 3 can not be made a xStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_710;
return ( (NODEPTR) _currn);
}/* Mkrule_710 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_711 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_711 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_711 _currn;
#ifdef __cplusplus
_currn = new _TPrule_711;
#else
_currn = (_TPPrule_711) TreeNodeAlloc (sizeof (struct _TPrule_711));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_711;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_711: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_711: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_711;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_711 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_712 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_712 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_712 _currn;
#ifdef __cplusplus
_currn = new _TPrule_712;
#else
_currn = (_TPPrule_712) TreeNodeAlloc (sizeof (struct _TPrule_712));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_712;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_712: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxPointerObjectList) MkxPointerObjectList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_712: root of subtree no. 2 can not be made a xPointerObjectList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_712;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_712 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_713 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_713 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_713 _currn;
#ifdef __cplusplus
_currn = new _TPrule_713;
#else
_currn = (_TPPrule_713) TreeNodeAlloc (sizeof (struct _TPrule_713));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_713;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_713: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxCaseSelector) MkxCaseSelector (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_713: root of subtree no. 2 can not be made a xCaseSelector node ", 0, _coordref);
_currn->_desc3 = (_TSPxName) MkxName (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_713: root of subtree no. 3 can not be made a xName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_713;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_713 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_714 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_714 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_714 _currn;
#ifdef __cplusplus
_currn = new _TPrule_714;
#else
_currn = (_TPPrule_714) TreeNodeAlloc (sizeof (struct _TPrule_714));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_714;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_714: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxCaseSelector) MkxCaseSelector (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_714: root of subtree no. 2 can not be made a xCaseSelector node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_714;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_714 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_715 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_715 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_715 _currn;
#ifdef __cplusplus
_currn = new _TPrule_715;
#else
_currn = (_TPPrule_715) TreeNodeAlloc (sizeof (struct _TPrule_715));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_715;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_715: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_715: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_715;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_715 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_716 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_716 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_716 _currn;
#ifdef __cplusplus
_currn = new _TPrule_716;
#else
_currn = (_TPPrule_716) TreeNodeAlloc (sizeof (struct _TPrule_716));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_716;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_716: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_716;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_716 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_717 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_717 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_717 _currn;
#ifdef __cplusplus
_currn = new _TPrule_717;
#else
_currn = (_TPPrule_717) TreeNodeAlloc (sizeof (struct _TPrule_717));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_717;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_717: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_717: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_717;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_717 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_718 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_718 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_718 _currn;
#ifdef __cplusplus
_currn = new _TPrule_718;
#else
_currn = (_TPPrule_718) TreeNodeAlloc (sizeof (struct _TPrule_718));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_718;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_718: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_718;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_718 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_719 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_719 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_719 _currn;
#ifdef __cplusplus
_currn = new _TPrule_719;
#else
_currn = (_TPPrule_719) TreeNodeAlloc (sizeof (struct _TPrule_719));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_719;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_719: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_719: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_719: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_719;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_719 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_720 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_720 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_720 _currn;
#ifdef __cplusplus
_currn = new _TPrule_720;
#else
_currn = (_TPPrule_720) TreeNodeAlloc (sizeof (struct _TPrule_720));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_720;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_720: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_720: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_720: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_720;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_720 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_721 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_721 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_721 _currn;
#ifdef __cplusplus
_currn = new _TPrule_721;
#else
_currn = (_TPPrule_721) TreeNodeAlloc (sizeof (struct _TPrule_721));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_721;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_721: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_721: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_721;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_721 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_722 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_722 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_722 _currn;
#ifdef __cplusplus
_currn = new _TPrule_722;
#else
_currn = (_TPPrule_722) TreeNodeAlloc (sizeof (struct _TPrule_722));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_722;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_722: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_722: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_722;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_722 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_723 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_723 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_723 _currn;
#ifdef __cplusplus
_currn = new _TPrule_723;
#else
_currn = (_TPPrule_723) TreeNodeAlloc (sizeof (struct _TPrule_723));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_723;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_723: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_723: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_723;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_723 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_724 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_724 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_724 _currn;
#ifdef __cplusplus
_currn = new _TPrule_724;
#else
_currn = (_TPPrule_724) TreeNodeAlloc (sizeof (struct _TPrule_724));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_724;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_724: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_724;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_724 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_725 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_725 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_725 _currn;
#ifdef __cplusplus
_currn = new _TPrule_725;
#else
_currn = (_TPPrule_725) TreeNodeAlloc (sizeof (struct _TPrule_725));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_725;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_725: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_725: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_725;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_725 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_726 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_726 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_726 _currn;
#ifdef __cplusplus
_currn = new _TPrule_726;
#else
_currn = (_TPPrule_726) TreeNodeAlloc (sizeof (struct _TPrule_726));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_726;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_726: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_726;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_726 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_727 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_727 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_727 _currn;
#ifdef __cplusplus
_currn = new _TPrule_727;
#else
_currn = (_TPPrule_727) TreeNodeAlloc (sizeof (struct _TPrule_727));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_727;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_727: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxAllocateObjectList) MkxAllocateObjectList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_727: root of subtree no. 2 can not be made a xAllocateObjectList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_727;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_727 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_728 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_728 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_728 _currn;
#ifdef __cplusplus
_currn = new _TPrule_728;
#else
_currn = (_TPPrule_728) TreeNodeAlloc (sizeof (struct _TPrule_728));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_728;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_728: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxAllocateObjectList) MkxAllocateObjectList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_728: root of subtree no. 2 can not be made a xAllocateObjectList node ", 0, _coordref);
_currn->_desc3 = (_TSPxVariable) MkxVariable (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_728: root of subtree no. 3 can not be made a xVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_728;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_728 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_729 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_729 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_729 _currn;
#ifdef __cplusplus
_currn = new _TPrule_729;
#else
_currn = (_TPPrule_729) TreeNodeAlloc (sizeof (struct _TPrule_729));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_729;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_729: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxAllocationList) MkxAllocationList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_729: root of subtree no. 2 can not be made a xAllocationList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_729;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_729 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_730 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_730 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_730 _currn;
#ifdef __cplusplus
_currn = new _TPrule_730;
#else
_currn = (_TPPrule_730) TreeNodeAlloc (sizeof (struct _TPrule_730));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_730;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_730: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxAllocationList) MkxAllocationList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_730: root of subtree no. 2 can not be made a xAllocationList node ", 0, _coordref);
_currn->_desc3 = (_TSPxVariable) MkxVariable (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_730: root of subtree no. 3 can not be made a xVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_730;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_730 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_731 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_731 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_731 _currn;
#ifdef __cplusplus
_currn = new _TPrule_731;
#else
_currn = (_TPPrule_731) TreeNodeAlloc (sizeof (struct _TPrule_731));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_731;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_731: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxPointerStmtObjectList) MkxPointerStmtObjectList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_731: root of subtree no. 2 can not be made a xPointerStmtObjectList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_731;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_731 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_732 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_732 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_732 _currn;
#ifdef __cplusplus
_currn = new _TPrule_732;
#else
_currn = (_TPPrule_732) TreeNodeAlloc (sizeof (struct _TPrule_732));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_732;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_732: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_732;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_732 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_733 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_733 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_733 _currn;
#ifdef __cplusplus
_currn = new _TPrule_733;
#else
_currn = (_TPPrule_733) TreeNodeAlloc (sizeof (struct _TPrule_733));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_733;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_733: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_733: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_733;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_733 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_734 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_734 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_734 _currn;
#ifdef __cplusplus
_currn = new _TPrule_734;
#else
_currn = (_TPPrule_734) TreeNodeAlloc (sizeof (struct _TPrule_734));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_734;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_734: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_734;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_734 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_735 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_735 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_735 _currn;
#ifdef __cplusplus
_currn = new _TPrule_735;
#else
_currn = (_TPPrule_735) TreeNodeAlloc (sizeof (struct _TPrule_735));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_735;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_735: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_735: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_735;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_735 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_736 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_736 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_736 _currn;
#ifdef __cplusplus
_currn = new _TPrule_736;
#else
_currn = (_TPPrule_736) TreeNodeAlloc (sizeof (struct _TPrule_736));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_736;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_736: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_736;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_736 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_737 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_737 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_737 _currn;
#ifdef __cplusplus
_currn = new _TPrule_737;
#else
_currn = (_TPPrule_737) TreeNodeAlloc (sizeof (struct _TPrule_737));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_737;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_737: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxForallHeader) MkxForallHeader (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_737: root of subtree no. 2 can not be made a xForallHeader node ", 0, _coordref);
_currn->_desc3 = (_TSPxStmt) MkxStmt (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_737: root of subtree no. 3 can not be made a xStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_737;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_737 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_738 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_738 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_738 _currn;
#ifdef __cplusplus
_currn = new _TPrule_738;
#else
_currn = (_TPPrule_738) TreeNodeAlloc (sizeof (struct _TPrule_738));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_738;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_738: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_738: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxForallHeader) MkxForallHeader (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_738: root of subtree no. 3 can not be made a xForallHeader node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_738;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_738 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_739 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_739 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_739 _currn;
#ifdef __cplusplus
_currn = new _TPrule_739;
#else
_currn = (_TPPrule_739) TreeNodeAlloc (sizeof (struct _TPrule_739));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_739;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_739: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxForallHeader) MkxForallHeader (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_739: root of subtree no. 2 can not be made a xForallHeader node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_739;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_739 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_740 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_740 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_740 _currn;
#ifdef __cplusplus
_currn = new _TPrule_740;
#else
_currn = (_TPPrule_740) TreeNodeAlloc (sizeof (struct _TPrule_740));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_740;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_740: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_740: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_currn->_desc3 = (_TSPxEndName) MkxEndName (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_740: root of subtree no. 3 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_740;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_740 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_741 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_741 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_741 _currn;
#ifdef __cplusplus
_currn = new _TPrule_741;
#else
_currn = (_TPPrule_741) TreeNodeAlloc (sizeof (struct _TPrule_741));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_741;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_741: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_741: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_currn->_desc3 = (_TSPxEndName) MkxEndName (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_741: root of subtree no. 3 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_741;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_741 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_742 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_742 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_742 _currn;
#ifdef __cplusplus
_currn = new _TPrule_742;
#else
_currn = (_TPPrule_742) TreeNodeAlloc (sizeof (struct _TPrule_742));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_742;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_742: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_742: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_742;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_742 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_743 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_743 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_743 _currn;
#ifdef __cplusplus
_currn = new _TPrule_743;
#else
_currn = (_TPPrule_743) TreeNodeAlloc (sizeof (struct _TPrule_743));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_743;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_743: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_743: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_743;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_743 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_744 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_744 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_744 _currn;
#ifdef __cplusplus
_currn = new _TPrule_744;
#else
_currn = (_TPPrule_744) TreeNodeAlloc (sizeof (struct _TPrule_744));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_744;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_744: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_744: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_744;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_744 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_745 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_745 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_745 _currn;
#ifdef __cplusplus
_currn = new _TPrule_745;
#else
_currn = (_TPPrule_745) TreeNodeAlloc (sizeof (struct _TPrule_745));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_745;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_745: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_745: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxLoopControl) MkxLoopControl (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_745: root of subtree no. 3 can not be made a xLoopControl node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_745;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_745 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_746 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_746 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_746 _currn;
#ifdef __cplusplus
_currn = new _TPrule_746;
#else
_currn = (_TPPrule_746) TreeNodeAlloc (sizeof (struct _TPrule_746));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_746;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_746: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_746: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxLblRef) MkxLblRef (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_746: root of subtree no. 3 can not be made a xLblRef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_746;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_746 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_747 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, int _TERM1)
#else
NODEPTR Mkrule_747 (_coordref,_desc1,_desc2,_desc3,_desc4, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	int _TERM1;
#endif
{	_TPPrule_747 _currn;
#ifdef __cplusplus
_currn = new _TPrule_747;
#else
_currn = (_TPPrule_747) TreeNodeAlloc (sizeof (struct _TPrule_747));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_747;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_747: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_747: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxLblRef) MkxLblRef (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_747: root of subtree no. 3 can not be made a xLblRef node ", 0, _coordref);
_currn->_desc4 = (_TSPxLoopControl) MkxLoopControl (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_747: root of subtree no. 4 can not be made a xLoopControl node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_747;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_747 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_748 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_748 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_748 _currn;
#ifdef __cplusplus
_currn = new _TPrule_748;
#else
_currn = (_TPPrule_748) TreeNodeAlloc (sizeof (struct _TPrule_748));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_748;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_748: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxLblRef) MkxLblRef (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_748: root of subtree no. 2 can not be made a xLblRef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_748;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_748 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_749 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_749 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_749 _currn;
#ifdef __cplusplus
_currn = new _TPrule_749;
#else
_currn = (_TPPrule_749) TreeNodeAlloc (sizeof (struct _TPrule_749));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_749;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_749: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_749;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_749 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_750 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_750 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_750 _currn;
#ifdef __cplusplus
_currn = new _TPrule_750;
#else
_currn = (_TPPrule_750) TreeNodeAlloc (sizeof (struct _TPrule_750));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_750;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_750: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxLoopControl) MkxLoopControl (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_750: root of subtree no. 2 can not be made a xLoopControl node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_750;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_750 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_751 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_751 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_751 _currn;
#ifdef __cplusplus
_currn = new _TPrule_751;
#else
_currn = (_TPPrule_751) TreeNodeAlloc (sizeof (struct _TPrule_751));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_751;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_751: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_751: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_751;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_751 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_752 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_752 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_752 _currn;
#ifdef __cplusplus
_currn = new _TPrule_752;
#else
_currn = (_TPPrule_752) TreeNodeAlloc (sizeof (struct _TPrule_752));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_752;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_752: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_752;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_752 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_753 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_753 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_753 _currn;
#ifdef __cplusplus
_currn = new _TPrule_753;
#else
_currn = (_TPPrule_753) TreeNodeAlloc (sizeof (struct _TPrule_753));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_753;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_753: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_753;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_753 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_754 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_754 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_754 _currn;
#ifdef __cplusplus
_currn = new _TPrule_754;
#else
_currn = (_TPPrule_754) TreeNodeAlloc (sizeof (struct _TPrule_754));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_754;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_754: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_754: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_754;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_754 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_755 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, int _TERM1)
#else
NODEPTR Mkrule_755 (_coordref,_desc1,_desc2,_desc3,_desc4, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	int _TERM1;
#endif
{	_TPPrule_755 _currn;
#ifdef __cplusplus
_currn = new _TPrule_755;
#else
_currn = (_TPPrule_755) TreeNodeAlloc (sizeof (struct _TPrule_755));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_755;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_755: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxDerivedName) MkxDerivedName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_755: root of subtree no. 2 can not be made a xDerivedName node ", 0, _coordref);
_currn->_desc3 = (_TSPxDataRef) MkxDataRef (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_755: root of subtree no. 3 can not be made a xDataRef node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_755: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_755;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_755 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_756 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, int _TERM1)
#else
NODEPTR Mkrule_756 (_coordref,_desc1,_desc2,_desc3,_desc4, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	int _TERM1;
#endif
{	_TPPrule_756 _currn;
#ifdef __cplusplus
_currn = new _TPrule_756;
#else
_currn = (_TPPrule_756) TreeNodeAlloc (sizeof (struct _TPrule_756));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_756;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_756: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxDerivedName) MkxDerivedName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_756: root of subtree no. 2 can not be made a xDerivedName node ", 0, _coordref);
_currn->_desc3 = (_TSPxCompDataRef) MkxCompDataRef (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_756: root of subtree no. 3 can not be made a xCompDataRef node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_756: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_756;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_756 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_757 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_757 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_757 _currn;
#ifdef __cplusplus
_currn = new _TPrule_757;
#else
_currn = (_TPPrule_757) TreeNodeAlloc (sizeof (struct _TPrule_757));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_757;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_757: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_757: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_757;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_757 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_758 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_758 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_758 _currn;
#ifdef __cplusplus
_currn = new _TPrule_758;
#else
_currn = (_TPPrule_758) TreeNodeAlloc (sizeof (struct _TPrule_758));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_758;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_758: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_758: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_758;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_758 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_759 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_759 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_759 _currn;
#ifdef __cplusplus
_currn = new _TPrule_759;
#else
_currn = (_TPPrule_759) TreeNodeAlloc (sizeof (struct _TPrule_759));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_759;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_759: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_759;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_759 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_760 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_760 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_760 _currn;
#ifdef __cplusplus
_currn = new _TPrule_760;
#else
_currn = (_TPPrule_760) TreeNodeAlloc (sizeof (struct _TPrule_760));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_760;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_760: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_760;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_760 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_761 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_761 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_761 _currn;
#ifdef __cplusplus
_currn = new _TPrule_761;
#else
_currn = (_TPPrule_761) TreeNodeAlloc (sizeof (struct _TPrule_761));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_761;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_761: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_761;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_761 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_762 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_762 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_762 _currn;
#ifdef __cplusplus
_currn = new _TPrule_762;
#else
_currn = (_TPPrule_762) TreeNodeAlloc (sizeof (struct _TPrule_762));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_762;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_762: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_762: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_762;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_762 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_763 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_763 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_763 _currn;
#ifdef __cplusplus
_currn = new _TPrule_763;
#else
_currn = (_TPPrule_763) TreeNodeAlloc (sizeof (struct _TPrule_763));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_763;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_763: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_763: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_763;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_763 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_764 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_764 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_764 _currn;
#ifdef __cplusplus
_currn = new _TPrule_764;
#else
_currn = (_TPPrule_764) TreeNodeAlloc (sizeof (struct _TPrule_764));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_764;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_764: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_764;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_764 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_765 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_765 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_765 _currn;
#ifdef __cplusplus
_currn = new _TPrule_765;
#else
_currn = (_TPPrule_765) TreeNodeAlloc (sizeof (struct _TPrule_765));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_765;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_765: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_765;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_765 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_766 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_766 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_766 _currn;
#ifdef __cplusplus
_currn = new _TPrule_766;
#else
_currn = (_TPPrule_766) TreeNodeAlloc (sizeof (struct _TPrule_766));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_766;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_766: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_766;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_766 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_767 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_767 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_767 _currn;
#ifdef __cplusplus
_currn = new _TPrule_767;
#else
_currn = (_TPPrule_767) TreeNodeAlloc (sizeof (struct _TPrule_767));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_767;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_767: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_767: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_767;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_767 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_768 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_768 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_768 _currn;
#ifdef __cplusplus
_currn = new _TPrule_768;
#else
_currn = (_TPPrule_768) TreeNodeAlloc (sizeof (struct _TPrule_768));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_768;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_768: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_768: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_768;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_768 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_769 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_769 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_769 _currn;
#ifdef __cplusplus
_currn = new _TPrule_769;
#else
_currn = (_TPPrule_769) TreeNodeAlloc (sizeof (struct _TPrule_769));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_769;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_769: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_769;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_769 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_770 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_770 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_770 _currn;
#ifdef __cplusplus
_currn = new _TPrule_770;
#else
_currn = (_TPPrule_770) TreeNodeAlloc (sizeof (struct _TPrule_770));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_770;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_770: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_770;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_770 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_771 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_771 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_771 _currn;
#ifdef __cplusplus
_currn = new _TPrule_771;
#else
_currn = (_TPPrule_771) TreeNodeAlloc (sizeof (struct _TPrule_771));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_771;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_771: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_771;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_771 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_772 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_772 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_772 _currn;
#ifdef __cplusplus
_currn = new _TPrule_772;
#else
_currn = (_TPPrule_772) TreeNodeAlloc (sizeof (struct _TPrule_772));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_772;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_772: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_772: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_772;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_772 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_773 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_773 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_773 _currn;
#ifdef __cplusplus
_currn = new _TPrule_773;
#else
_currn = (_TPPrule_773) TreeNodeAlloc (sizeof (struct _TPrule_773));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_773;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_773: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_773: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_773;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_773 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_774 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_774 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_774 _currn;
#ifdef __cplusplus
_currn = new _TPrule_774;
#else
_currn = (_TPPrule_774) TreeNodeAlloc (sizeof (struct _TPrule_774));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_774;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_774: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_774;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_774 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_775 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_775 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_775 _currn;
#ifdef __cplusplus
_currn = new _TPrule_775;
#else
_currn = (_TPPrule_775) TreeNodeAlloc (sizeof (struct _TPrule_775));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_775;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_775: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_775;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_775 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_776 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_776 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_776 _currn;
#ifdef __cplusplus
_currn = new _TPrule_776;
#else
_currn = (_TPPrule_776) TreeNodeAlloc (sizeof (struct _TPrule_776));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_776;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_776: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_776: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_776: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_776;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_776 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_777 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_777 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_777 _currn;
#ifdef __cplusplus
_currn = new _TPrule_777;
#else
_currn = (_TPPrule_777) TreeNodeAlloc (sizeof (struct _TPrule_777));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_777;
_currn->_desc1 = (_TSPxArraySpec) MkxArraySpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_777: root of subtree no. 1 can not be made a xArraySpec node ", 0, _coordref);
_currn->_desc2 = (_TSPxDeferredShapeSpec) MkxDeferredShapeSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_777: root of subtree no. 2 can not be made a xDeferredShapeSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_777;
return ( (NODEPTR) _currn);
}/* Mkrule_777 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_778 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_778 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_778 _currn;
#ifdef __cplusplus
_currn = new _TPrule_778;
#else
_currn = (_TPPrule_778) TreeNodeAlloc (sizeof (struct _TPrule_778));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_778;
_currn->_desc1 = (_TSPxDeferredShapeSpec) MkxDeferredShapeSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_778: root of subtree no. 1 can not be made a xDeferredShapeSpec node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_778;
return ( (NODEPTR) _currn);
}/* Mkrule_778 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_779 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_779 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_779 _currn;
#ifdef __cplusplus
_currn = new _TPrule_779;
#else
_currn = (_TPPrule_779) TreeNodeAlloc (sizeof (struct _TPrule_779));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_779;
_currn->_desc1 = (_TSPxArraySpec) MkxArraySpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_779: root of subtree no. 1 can not be made a xArraySpec node ", 0, _coordref);
_currn->_desc2 = (_TSPxLowerBound) MkxLowerBound (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_779: root of subtree no. 2 can not be made a xLowerBound node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_779;
return ( (NODEPTR) _currn);
}/* Mkrule_779 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_780 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_780 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_780 _currn;
#ifdef __cplusplus
_currn = new _TPrule_780;
#else
_currn = (_TPPrule_780) TreeNodeAlloc (sizeof (struct _TPrule_780));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_780;
_currn->_desc1 = (_TSPxLowerBound) MkxLowerBound (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_780: root of subtree no. 1 can not be made a xLowerBound node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_780;
return ( (NODEPTR) _currn);
}/* Mkrule_780 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_781 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_781 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_781 _currn;
#ifdef __cplusplus
_currn = new _TPrule_781;
#else
_currn = (_TPPrule_781) TreeNodeAlloc (sizeof (struct _TPrule_781));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_781;
_currn->_desc1 = (_TSPxArraySpec) MkxArraySpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_781: root of subtree no. 1 can not be made a xArraySpec node ", 0, _coordref);
_currn->_desc2 = (_TSPxExplicitShapeSpec) MkxExplicitShapeSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_781: root of subtree no. 2 can not be made a xExplicitShapeSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_781;
return ( (NODEPTR) _currn);
}/* Mkrule_781 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_782 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_782 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_782 _currn;
#ifdef __cplusplus
_currn = new _TPrule_782;
#else
_currn = (_TPPrule_782) TreeNodeAlloc (sizeof (struct _TPrule_782));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_782;
_currn->_desc1 = (_TSPxArraySpec) MkxArraySpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_782: root of subtree no. 1 can not be made a xArraySpec node ", 0, _coordref);
_currn->_desc2 = (_TSPxLowerBound) MkxLowerBound (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_782: root of subtree no. 2 can not be made a xLowerBound node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_782;
return ( (NODEPTR) _currn);
}/* Mkrule_782 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_783 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_783 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_783 _currn;
#ifdef __cplusplus
_currn = new _TPrule_783;
#else
_currn = (_TPPrule_783) TreeNodeAlloc (sizeof (struct _TPrule_783));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_783;
_currn->_desc1 = (_TSPxArraySpec) MkxArraySpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_783: root of subtree no. 1 can not be made a xArraySpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_783;
return ( (NODEPTR) _currn);
}/* Mkrule_783 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_784 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_784 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_784 _currn;
#ifdef __cplusplus
_currn = new _TPrule_784;
#else
_currn = (_TPPrule_784) TreeNodeAlloc (sizeof (struct _TPrule_784));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_784;
_currn->_desc1 = (_TSPxArraySpec) MkxArraySpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_784: root of subtree no. 1 can not be made a xArraySpec node ", 0, _coordref);
_currn->_desc2 = (_TSPxAssumedShapeSpec) MkxAssumedShapeSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_784: root of subtree no. 2 can not be made a xAssumedShapeSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_784;
return ( (NODEPTR) _currn);
}/* Mkrule_784 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_785 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_785 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_785 _currn;
#ifdef __cplusplus
_currn = new _TPrule_785;
#else
_currn = (_TPPrule_785) TreeNodeAlloc (sizeof (struct _TPrule_785));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_785;
_currn->_desc1 = (_TSPxExplicitShapeSpec) MkxExplicitShapeSpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_785: root of subtree no. 1 can not be made a xExplicitShapeSpec node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_785;
return ( (NODEPTR) _currn);
}/* Mkrule_785 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_786 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_786 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_786 _currn;
#ifdef __cplusplus
_currn = new _TPrule_786;
#else
_currn = (_TPPrule_786) TreeNodeAlloc (sizeof (struct _TPrule_786));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_786;
_currn->_desc1 = (_TSPxLowerBound) MkxLowerBound (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_786: root of subtree no. 1 can not be made a xLowerBound node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_786;
return ( (NODEPTR) _currn);
}/* Mkrule_786 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_787 (POSITION *_coordref)
#else
NODEPTR Mkrule_787 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_787 _currn;
#ifdef __cplusplus
_currn = new _TPrule_787;
#else
_currn = (_TPPrule_787) TreeNodeAlloc (sizeof (struct _TPrule_787));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_787;
_SETCOORD(_currn)
_TERMACT_rule_787;
return ( (NODEPTR) _currn);
}/* Mkrule_787 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_788 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_788 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_788 _currn;
#ifdef __cplusplus
_currn = new _TPrule_788;
#else
_currn = (_TPPrule_788) TreeNodeAlloc (sizeof (struct _TPrule_788));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_788;
_currn->_desc1 = (_TSPxArraySpec) MkxArraySpec (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_788: root of subtree no. 1 can not be made a xArraySpec node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_788;
return ( (NODEPTR) _currn);
}/* Mkrule_788 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_789 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_789 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_789 _currn;
#ifdef __cplusplus
_currn = new _TPrule_789;
#else
_currn = (_TPPrule_789) TreeNodeAlloc (sizeof (struct _TPrule_789));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_789;
_currn->_desc1 = (_TSPxComponentName) MkxComponentName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_789: root of subtree no. 1 can not be made a xComponentName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_789;
return ( (NODEPTR) _currn);
}/* Mkrule_789 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_790 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_790 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_790 _currn;
#ifdef __cplusplus
_currn = new _TPrule_790;
#else
_currn = (_TPPrule_790) TreeNodeAlloc (sizeof (struct _TPrule_790));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_790;
_currn->_desc1 = (_TSPxComponentName) MkxComponentName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_790: root of subtree no. 1 can not be made a xComponentName node ", 0, _coordref);
_currn->_desc2 = (_TSPxCharLength) MkxCharLength (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_790: root of subtree no. 2 can not be made a xCharLength node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_790;
return ( (NODEPTR) _currn);
}/* Mkrule_790 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_791 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_791 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_791 _currn;
#ifdef __cplusplus
_currn = new _TPrule_791;
#else
_currn = (_TPPrule_791) TreeNodeAlloc (sizeof (struct _TPrule_791));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_791;
_currn->_desc1 = (_TSPxComponentName) MkxComponentName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_791: root of subtree no. 1 can not be made a xComponentName node ", 0, _coordref);
_currn->_desc2 = (_TSPDimensionDeclarators) MkDimensionDeclarators (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_791: root of subtree no. 2 can not be made a DimensionDeclarators node ", 0, _coordref);
_currn->_desc3 = (_TSPxCharLength) MkxCharLength (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_791: root of subtree no. 3 can not be made a xCharLength node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_791;
return ( (NODEPTR) _currn);
}/* Mkrule_791 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_792 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_792 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_792 _currn;
#ifdef __cplusplus
_currn = new _TPrule_792;
#else
_currn = (_TPPrule_792) TreeNodeAlloc (sizeof (struct _TPrule_792));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_792;
_currn->_desc1 = (_TSPxComponentName) MkxComponentName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_792: root of subtree no. 1 can not be made a xComponentName node ", 0, _coordref);
_currn->_desc2 = (_TSPDimensionDeclarators) MkDimensionDeclarators (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_792: root of subtree no. 2 can not be made a DimensionDeclarators node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_792;
return ( (NODEPTR) _currn);
}/* Mkrule_792 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_793 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_793 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_793 _currn;
#ifdef __cplusplus
_currn = new _TPrule_793;
#else
_currn = (_TPPrule_793) TreeNodeAlloc (sizeof (struct _TPrule_793));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_793;
_currn->_desc1 = (_TSPxObjectName) MkxObjectName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_793: root of subtree no. 1 can not be made a xObjectName node ", 0, _coordref);
_currn->_desc2 = (_TSPDimensionDeclarators) MkDimensionDeclarators (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_793: root of subtree no. 2 can not be made a DimensionDeclarators node ", 0, _coordref);
_currn->_desc3 = (_TSPxCharLength) MkxCharLength (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_793: root of subtree no. 3 can not be made a xCharLength node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_793;
return ( (NODEPTR) _currn);
}/* Mkrule_793 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_794 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_794 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_794 _currn;
#ifdef __cplusplus
_currn = new _TPrule_794;
#else
_currn = (_TPPrule_794) TreeNodeAlloc (sizeof (struct _TPrule_794));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_794;
_currn->_desc1 = (_TSPxObjectName) MkxObjectName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_794: root of subtree no. 1 can not be made a xObjectName node ", 0, _coordref);
_currn->_desc2 = (_TSPDimensionDeclarators) MkDimensionDeclarators (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_794: root of subtree no. 2 can not be made a DimensionDeclarators node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_794;
return ( (NODEPTR) _currn);
}/* Mkrule_794 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_795 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_795 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_795 _currn;
#ifdef __cplusplus
_currn = new _TPrule_795;
#else
_currn = (_TPPrule_795) TreeNodeAlloc (sizeof (struct _TPrule_795));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_795;
_currn->_desc1 = (_TSPxVariableName) MkxVariableName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_795: root of subtree no. 1 can not be made a xVariableName node ", 0, _coordref);
_currn->_desc2 = (_TSPDimensionDeclarators) MkDimensionDeclarators (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_795: root of subtree no. 2 can not be made a DimensionDeclarators node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_795;
return ( (NODEPTR) _currn);
}/* Mkrule_795 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_796 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_796 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_796 _currn;
#ifdef __cplusplus
_currn = new _TPrule_796;
#else
_currn = (_TPPrule_796) TreeNodeAlloc (sizeof (struct _TPrule_796));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_796;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_796: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_796: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_796: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_796;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_796 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_797 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, NODEPTR _desc5, int _TERM1)
#else
NODEPTR Mkrule_797 (_coordref,_desc1,_desc2,_desc3,_desc4,_desc5, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	NODEPTR _desc5;
	int _TERM1;
#endif
{	_TPPrule_797 _currn;
#ifdef __cplusplus
_currn = new _TPrule_797;
#else
_currn = (_TPPrule_797) TreeNodeAlloc (sizeof (struct _TPrule_797));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_797;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_797: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_797: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxExprList) MkxExprList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_797: root of subtree no. 3 can not be made a xExprList node ", 0, _coordref);
_currn->_desc4 = (_TSPxSubstringRange) MkxSubstringRange (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_797: root of subtree no. 4 can not be made a xSubstringRange node ", 0, _coordref);
_currn->_desc5 = (_TSPxExpr) MkxExpr (_coordref, _desc5);	
if (((NODEPTR)_currn->_desc5) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_797: root of subtree no. 5 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_797;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_797 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_798 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, int _TERM1)
#else
NODEPTR Mkrule_798 (_coordref,_desc1,_desc2,_desc3,_desc4, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	int _TERM1;
#endif
{	_TPPrule_798 _currn;
#ifdef __cplusplus
_currn = new _TPrule_798;
#else
_currn = (_TPPrule_798) TreeNodeAlloc (sizeof (struct _TPrule_798));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_798;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_798: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_798: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxExprList) MkxExprList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_798: root of subtree no. 3 can not be made a xExprList node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_798: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_798;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_798 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_799 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_799 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_799 _currn;
#ifdef __cplusplus
_currn = new _TPrule_799;
#else
_currn = (_TPPrule_799) TreeNodeAlloc (sizeof (struct _TPrule_799));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_799;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_799: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPGoToKw) MkGoToKw (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_799: root of subtree no. 2 can not be made a GoToKw node ", 0, _coordref);
_currn->_desc3 = (_TSPxVariableName) MkxVariableName (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_799: root of subtree no. 3 can not be made a xVariableName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_799;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_799 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_800 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, int _TERM1)
#else
NODEPTR Mkrule_800 (_coordref,_desc1,_desc2,_desc3,_desc4, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	int _TERM1;
#endif
{	_TPPrule_800 _currn;
#ifdef __cplusplus
_currn = new _TPrule_800;
#else
_currn = (_TPPrule_800) TreeNodeAlloc (sizeof (struct _TPrule_800));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_800;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_800: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPGoToKw) MkGoToKw (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_800: root of subtree no. 2 can not be made a GoToKw node ", 0, _coordref);
_currn->_desc3 = (_TSPxVariableName) MkxVariableName (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_800: root of subtree no. 3 can not be made a xVariableName node ", 0, _coordref);
_currn->_desc4 = (_TSPxLblRefList) MkxLblRefList (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_800: root of subtree no. 4 can not be made a xLblRefList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_800;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_800 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_801 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_801 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_801 _currn;
#ifdef __cplusplus
_currn = new _TPrule_801;
#else
_currn = (_TPPrule_801) TreeNodeAlloc (sizeof (struct _TPrule_801));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_801;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_801: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPGoToKw) MkGoToKw (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_801: root of subtree no. 2 can not be made a GoToKw node ", 0, _coordref);
_currn->_desc3 = (_TSPxLblRef) MkxLblRef (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_801: root of subtree no. 3 can not be made a xLblRef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_801;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_801 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_802 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, int _TERM1)
#else
NODEPTR Mkrule_802 (_coordref,_desc1,_desc2,_desc3,_desc4, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	int _TERM1;
#endif
{	_TPPrule_802 _currn;
#ifdef __cplusplus
_currn = new _TPrule_802;
#else
_currn = (_TPPrule_802) TreeNodeAlloc (sizeof (struct _TPrule_802));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_802;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_802: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPGoToKw) MkGoToKw (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_802: root of subtree no. 2 can not be made a GoToKw node ", 0, _coordref);
_currn->_desc3 = (_TSPxLblRefList) MkxLblRefList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_802: root of subtree no. 3 can not be made a xLblRefList node ", 0, _coordref);
_currn->_desc4 = (_TSPxExpr) MkxExpr (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_802: root of subtree no. 4 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_802;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_802 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_803 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, int _TERM1)
#else
NODEPTR Mkrule_803 (_coordref,_desc1,_desc2,_desc3,_desc4, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	int _TERM1;
#endif
{	_TPPrule_803 _currn;
#ifdef __cplusplus
_currn = new _TPrule_803;
#else
_currn = (_TPPrule_803) TreeNodeAlloc (sizeof (struct _TPrule_803));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_803;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_803: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxIoControlSpecList) MkxIoControlSpecList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_803: root of subtree no. 2 can not be made a xIoControlSpecList node ", 0, _coordref);
_currn->_desc3 = (_TSPxComma) MkxComma (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_803: root of subtree no. 3 can not be made a xComma node ", 0, _coordref);
_currn->_desc4 = (_TSPxOutputItemList) MkxOutputItemList (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_803: root of subtree no. 4 can not be made a xOutputItemList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_803;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_803 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_804 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_804 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_804 _currn;
#ifdef __cplusplus
_currn = new _TPrule_804;
#else
_currn = (_TPPrule_804) TreeNodeAlloc (sizeof (struct _TPrule_804));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_804;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_804: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxIoControlSpecList) MkxIoControlSpecList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_804: root of subtree no. 2 can not be made a xIoControlSpecList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_804;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_804 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_805 (POSITION *_coordref, NODEPTR _desc1, int _TERM1, int _TERM2)
#else
NODEPTR Mkrule_805 (_coordref,_desc1, _TERM1, _TERM2)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
	int _TERM2;
#endif
{	_TPPrule_805 _currn;
#ifdef __cplusplus
_currn = new _TPrule_805;
#else
_currn = (_TPPrule_805) TreeNodeAlloc (sizeof (struct _TPrule_805));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_805;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_805: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_805;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xScon", _TERM1);
#endif

#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM2);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_805 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_806 (POSITION *_coordref, NODEPTR _desc1, int _TERM1, int _TERM2)
#else
NODEPTR Mkrule_806 (_coordref,_desc1, _TERM1, _TERM2)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
	int _TERM2;
#endif
{	_TPPrule_806 _currn;
#ifdef __cplusplus
_currn = new _TPrule_806;
#else
_currn = (_TPPrule_806) TreeNodeAlloc (sizeof (struct _TPrule_806));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_806;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_806: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_806;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM2);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_806 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_807 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_807 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_807 _currn;
#ifdef __cplusplus
_currn = new _TPrule_807;
#else
_currn = (_TPPrule_807) TreeNodeAlloc (sizeof (struct _TPrule_807));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_807;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_807: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_807;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_807 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_808 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_808 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_808 _currn;
#ifdef __cplusplus
_currn = new _TPrule_808;
#else
_currn = (_TPPrule_808) TreeNodeAlloc (sizeof (struct _TPrule_808));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_808;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_808: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxUnitIdentifier) MkxUnitIdentifier (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_808: root of subtree no. 2 can not be made a xUnitIdentifier node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_808;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_808 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_809 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_809 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_809 _currn;
#ifdef __cplusplus
_currn = new _TPrule_809;
#else
_currn = (_TPPrule_809) TreeNodeAlloc (sizeof (struct _TPrule_809));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_809;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_809: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxIoControlSpecList) MkxIoControlSpecList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_809: root of subtree no. 2 can not be made a xIoControlSpecList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_809;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_809 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_810 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_810 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_810 _currn;
#ifdef __cplusplus
_currn = new _TPrule_810;
#else
_currn = (_TPPrule_810) TreeNodeAlloc (sizeof (struct _TPrule_810));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_810;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_810: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_810: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_810;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_810 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_811 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_811 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_811 _currn;
#ifdef __cplusplus
_currn = new _TPrule_811;
#else
_currn = (_TPPrule_811) TreeNodeAlloc (sizeof (struct _TPrule_811));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_811;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_811: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_811;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_811 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_812 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_812 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_812 _currn;
#ifdef __cplusplus
_currn = new _TPrule_812;
#else
_currn = (_TPPrule_812) TreeNodeAlloc (sizeof (struct _TPrule_812));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_812;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_812: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxIoControlSpec) MkxIoControlSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_812: root of subtree no. 2 can not be made a xIoControlSpec node ", 0, _coordref);
_currn->_desc3 = (_TSPxInputItemList) MkxInputItemList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_812: root of subtree no. 3 can not be made a xInputItemList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_812;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_812 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_813 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_813 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_813 _currn;
#ifdef __cplusplus
_currn = new _TPrule_813;
#else
_currn = (_TPPrule_813) TreeNodeAlloc (sizeof (struct _TPrule_813));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_813;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_813: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxIoControlSpec) MkxIoControlSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_813: root of subtree no. 2 can not be made a xIoControlSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_813;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_813 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_814 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_814 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_814 _currn;
#ifdef __cplusplus
_currn = new _TPrule_814;
#else
_currn = (_TPPrule_814) TreeNodeAlloc (sizeof (struct _TPrule_814));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_814;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_814: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxFormatIdentifier) MkxFormatIdentifier (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_814: root of subtree no. 2 can not be made a xFormatIdentifier node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_814;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_814 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_815 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_815 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_815 _currn;
#ifdef __cplusplus
_currn = new _TPrule_815;
#else
_currn = (_TPPrule_815) TreeNodeAlloc (sizeof (struct _TPrule_815));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_815;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_815: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxFormatIdentifier) MkxFormatIdentifier (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_815: root of subtree no. 2 can not be made a xFormatIdentifier node ", 0, _coordref);
_currn->_desc3 = (_TSPxInputItemList) MkxInputItemList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_815: root of subtree no. 3 can not be made a xInputItemList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_815;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_815 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_816 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_816 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_816 _currn;
#ifdef __cplusplus
_currn = new _TPrule_816;
#else
_currn = (_TPPrule_816) TreeNodeAlloc (sizeof (struct _TPrule_816));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_816;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_816: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxFormatIdentifier) MkxFormatIdentifier (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_816: root of subtree no. 2 can not be made a xFormatIdentifier node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_816;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_816 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_817 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_817 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_817 _currn;
#ifdef __cplusplus
_currn = new _TPrule_817;
#else
_currn = (_TPPrule_817) TreeNodeAlloc (sizeof (struct _TPrule_817));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_817;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_817: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxFormatIdentifier) MkxFormatIdentifier (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_817: root of subtree no. 2 can not be made a xFormatIdentifier node ", 0, _coordref);
_currn->_desc3 = (_TSPxOutputItemList) MkxOutputItemList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_817: root of subtree no. 3 can not be made a xOutputItemList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_817;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_817 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_818 (POSITION *_coordref, NODEPTR _desc1, int _TERM1, int _TERM2)
#else
NODEPTR Mkrule_818 (_coordref,_desc1, _TERM1, _TERM2)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
	int _TERM2;
#endif
{	_TPPrule_818 _currn;
#ifdef __cplusplus
_currn = new _TPrule_818;
#else
_currn = (_TPPrule_818) TreeNodeAlloc (sizeof (struct _TPrule_818));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_818;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_818: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_818;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xScon", _TERM1);
#endif

#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM2);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_818 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_819 (POSITION *_coordref, NODEPTR _desc1, int _TERM1, int _TERM2)
#else
NODEPTR Mkrule_819 (_coordref,_desc1, _TERM1, _TERM2)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
	int _TERM2;
#endif
{	_TPPrule_819 _currn;
#ifdef __cplusplus
_currn = new _TPrule_819;
#else
_currn = (_TPPrule_819) TreeNodeAlloc (sizeof (struct _TPrule_819));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_819;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_819: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_819;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM2);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_819 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_820 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_820 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_820 _currn;
#ifdef __cplusplus
_currn = new _TPrule_820;
#else
_currn = (_TPPrule_820) TreeNodeAlloc (sizeof (struct _TPrule_820));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_820;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_820: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_820;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_820 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_821 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_821 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_821 _currn;
#ifdef __cplusplus
_currn = new _TPrule_821;
#else
_currn = (_TPPrule_821) TreeNodeAlloc (sizeof (struct _TPrule_821));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_821;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_821: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxIoControlSpecList) MkxIoControlSpecList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_821: root of subtree no. 2 can not be made a xIoControlSpecList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_821;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_821 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_822 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_822 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_822 _currn;
#ifdef __cplusplus
_currn = new _TPrule_822;
#else
_currn = (_TPPrule_822) TreeNodeAlloc (sizeof (struct _TPrule_822));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_822;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_822: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxScalarVariable) MkxScalarVariable (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_822: root of subtree no. 2 can not be made a xScalarVariable node ", 0, _coordref);
_currn->_desc3 = (_TSPxOutputItemList) MkxOutputItemList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_822: root of subtree no. 3 can not be made a xOutputItemList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_822;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_822 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_823 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_823 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_823 _currn;
#ifdef __cplusplus
_currn = new _TPrule_823;
#else
_currn = (_TPPrule_823) TreeNodeAlloc (sizeof (struct _TPrule_823));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_823;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_823: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxIoControlSpecList) MkxIoControlSpecList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_823: root of subtree no. 2 can not be made a xIoControlSpecList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_823;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_823 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_824 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_824 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_824 _currn;
#ifdef __cplusplus
_currn = new _TPrule_824;
#else
_currn = (_TPPrule_824) TreeNodeAlloc (sizeof (struct _TPrule_824));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_824;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_824: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_824: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_currn->_desc3 = (_TSPxStmt) MkxStmt (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_824: root of subtree no. 3 can not be made a xStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_824;
return ( (NODEPTR) _currn);
}/* Mkrule_824 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_825 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, NODEPTR _desc5, int _TERM1)
#else
NODEPTR Mkrule_825 (_coordref,_desc1,_desc2,_desc3,_desc4,_desc5, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	NODEPTR _desc5;
	int _TERM1;
#endif
{	_TPPrule_825 _currn;
#ifdef __cplusplus
_currn = new _TPrule_825;
#else
_currn = (_TPPrule_825) TreeNodeAlloc (sizeof (struct _TPrule_825));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_825;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_825: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_825: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_currn->_desc3 = (_TSPxLblRef) MkxLblRef (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_825: root of subtree no. 3 can not be made a xLblRef node ", 0, _coordref);
_currn->_desc4 = (_TSPxLblRef) MkxLblRef (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_825: root of subtree no. 4 can not be made a xLblRef node ", 0, _coordref);
_currn->_desc5 = (_TSPxLblRef) MkxLblRef (_coordref, _desc5);	
if (((NODEPTR)_currn->_desc5) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_825: root of subtree no. 5 can not be made a xLblRef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_825;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_825 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_826 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_826 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_826 _currn;
#ifdef __cplusplus
_currn = new _TPrule_826;
#else
_currn = (_TPPrule_826) TreeNodeAlloc (sizeof (struct _TPrule_826));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_826;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_826: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_826: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_826;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_826 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_827 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_827 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_827 _currn;
#ifdef __cplusplus
_currn = new _TPrule_827;
#else
_currn = (_TPPrule_827) TreeNodeAlloc (sizeof (struct _TPrule_827));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_827;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_827: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxUnitIdentifier) MkxUnitIdentifier (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_827: root of subtree no. 2 can not be made a xUnitIdentifier node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_827;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_827 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_828 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_828 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_828 _currn;
#ifdef __cplusplus
_currn = new _TPrule_828;
#else
_currn = (_TPPrule_828) TreeNodeAlloc (sizeof (struct _TPrule_828));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_828;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_828: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxIoControlSpecList) MkxIoControlSpecList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_828: root of subtree no. 2 can not be made a xIoControlSpecList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_828;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_828 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_829 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_829 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_829 _currn;
#ifdef __cplusplus
_currn = new _TPrule_829;
#else
_currn = (_TPPrule_829) TreeNodeAlloc (sizeof (struct _TPrule_829));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_829;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_829: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_829: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_829;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_829 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_830 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_830 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_830 _currn;
#ifdef __cplusplus
_currn = new _TPrule_830;
#else
_currn = (_TPPrule_830) TreeNodeAlloc (sizeof (struct _TPrule_830));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_830;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_830: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_830;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_830 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_831 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_831 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_831 _currn;
#ifdef __cplusplus
_currn = new _TPrule_831;
#else
_currn = (_TPPrule_831) TreeNodeAlloc (sizeof (struct _TPrule_831));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_831;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_831: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxLblRef) MkxLblRef (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_831: root of subtree no. 2 can not be made a xLblRef node ", 0, _coordref);
_currn->_desc3 = (_TSPxLoopControl) MkxLoopControl (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_831: root of subtree no. 3 can not be made a xLoopControl node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_831;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_831 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_832 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_832 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_832 _currn;
#ifdef __cplusplus
_currn = new _TPrule_832;
#else
_currn = (_TPPrule_832) TreeNodeAlloc (sizeof (struct _TPrule_832));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_832;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_832: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_832;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_832 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_833 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_833 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_833 _currn;
#ifdef __cplusplus
_currn = new _TPrule_833;
#else
_currn = (_TPPrule_833) TreeNodeAlloc (sizeof (struct _TPrule_833));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_833;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_833: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxIoControlSpecList) MkxIoControlSpecList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_833: root of subtree no. 2 can not be made a xIoControlSpecList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_833;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_833 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_834 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_834 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_834 _currn;
#ifdef __cplusplus
_currn = new _TPrule_834;
#else
_currn = (_TPPrule_834) TreeNodeAlloc (sizeof (struct _TPrule_834));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_834;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_834: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxSubroutineNameUse) MkxSubroutineNameUse (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_834: root of subtree no. 2 can not be made a xSubroutineNameUse node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_834;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_834 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_835 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_835 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_835 _currn;
#ifdef __cplusplus
_currn = new _TPrule_835;
#else
_currn = (_TPPrule_835) TreeNodeAlloc (sizeof (struct _TPrule_835));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_835;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_835: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxSubroutineNameUse) MkxSubroutineNameUse (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_835: root of subtree no. 2 can not be made a xSubroutineNameUse node ", 0, _coordref);
_currn->_desc3 = (_TSPxArgList) MkxArgList (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_835: root of subtree no. 3 can not be made a xArgList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_835;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_835 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_836 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_836 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_836 _currn;
#ifdef __cplusplus
_currn = new _TPrule_836;
#else
_currn = (_TPPrule_836) TreeNodeAlloc (sizeof (struct _TPrule_836));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_836;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_836: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxUnitIdentifier) MkxUnitIdentifier (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_836: root of subtree no. 2 can not be made a xUnitIdentifier node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_836;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_836 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_837 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_837 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_837 _currn;
#ifdef __cplusplus
_currn = new _TPrule_837;
#else
_currn = (_TPPrule_837) TreeNodeAlloc (sizeof (struct _TPrule_837));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_837;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_837: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxIoControlSpecList) MkxIoControlSpecList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_837: root of subtree no. 2 can not be made a xIoControlSpecList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_837;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_837 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_838 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_838 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_838 _currn;
#ifdef __cplusplus
_currn = new _TPrule_838;
#else
_currn = (_TPPrule_838) TreeNodeAlloc (sizeof (struct _TPrule_838));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_838;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_838: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxLblRef) MkxLblRef (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_838: root of subtree no. 2 can not be made a xLblRef node ", 0, _coordref);
_currn->_desc3 = (_TSPxVariableName) MkxVariableName (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_838: root of subtree no. 3 can not be made a xVariableName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_838;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_838 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_839 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_839 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_839 _currn;
#ifdef __cplusplus
_currn = new _TPrule_839;
#else
_currn = (_TPPrule_839) TreeNodeAlloc (sizeof (struct _TPrule_839));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_839;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_839: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxName) MkxName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_839: root of subtree no. 2 can not be made a xName node ", 0, _coordref);
_currn->_desc3 = (_TSPxStmtFunctionRange) MkxStmtFunctionRange (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_839: root of subtree no. 3 can not be made a xStmtFunctionRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_839;
return ( (NODEPTR) _currn);
}/* Mkrule_839 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_840 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_840 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_840 _currn;
#ifdef __cplusplus
_currn = new _TPrule_840;
#else
_currn = (_TPPrule_840) TreeNodeAlloc (sizeof (struct _TPrule_840));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_840;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_840: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxSavedEntityList) MkxSavedEntityList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_840: root of subtree no. 2 can not be made a xSavedEntityList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_840;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_840 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_841 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_841 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_841 _currn;
#ifdef __cplusplus
_currn = new _TPrule_841;
#else
_currn = (_TPPrule_841) TreeNodeAlloc (sizeof (struct _TPrule_841));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_841;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_841: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_841;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_841 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_842 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_842 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_842 _currn;
#ifdef __cplusplus
_currn = new _TPrule_842;
#else
_currn = (_TPPrule_842) TreeNodeAlloc (sizeof (struct _TPrule_842));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_842;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_842: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxIntrinsicList) MkxIntrinsicList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_842: root of subtree no. 2 can not be made a xIntrinsicList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_842;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_842 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_843 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_843 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_843 _currn;
#ifdef __cplusplus
_currn = new _TPrule_843;
#else
_currn = (_TPPrule_843) TreeNodeAlloc (sizeof (struct _TPrule_843));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_843;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_843: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxExternalNameList) MkxExternalNameList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_843: root of subtree no. 2 can not be made a xExternalNameList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_843;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_843 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_844 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_844 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_844 _currn;
#ifdef __cplusplus
_currn = new _TPrule_844;
#else
_currn = (_TPPrule_844) TreeNodeAlloc (sizeof (struct _TPrule_844));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_844;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_844: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEquivalenceSetList) MkxEquivalenceSetList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_844: root of subtree no. 2 can not be made a xEquivalenceSetList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_844;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_844 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_845 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_845 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_845 _currn;
#ifdef __cplusplus
_currn = new _TPrule_845;
#else
_currn = (_TPPrule_845) TreeNodeAlloc (sizeof (struct _TPrule_845));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_845;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_845: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxArrayDeclaratorList) MkxArrayDeclaratorList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_845: root of subtree no. 2 can not be made a xArrayDeclaratorList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_845;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_845 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_846 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_846 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_846 _currn;
#ifdef __cplusplus
_currn = new _TPrule_846;
#else
_currn = (_TPPrule_846) TreeNodeAlloc (sizeof (struct _TPrule_846));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_846;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_846: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxComlist) MkxComlist (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_846: root of subtree no. 2 can not be made a xComlist node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_846;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_846 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_847 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_847 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_847 _currn;
#ifdef __cplusplus
_currn = new _TPrule_847;
#else
_currn = (_TPPrule_847) TreeNodeAlloc (sizeof (struct _TPrule_847));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_847;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_847: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxImplicitSpecList) MkxImplicitSpecList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_847: root of subtree no. 2 can not be made a xImplicitSpecList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_847;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_847 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_848 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_848 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_848 _currn;
#ifdef __cplusplus
_currn = new _TPrule_848;
#else
_currn = (_TPPrule_848) TreeNodeAlloc (sizeof (struct _TPrule_848));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_848;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_848: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxDatalist) MkxDatalist (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_848: root of subtree no. 2 can not be made a xDatalist node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_848;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_848 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_849 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_849 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_849 _currn;
#ifdef __cplusplus
_currn = new _TPrule_849;
#else
_currn = (_TPPrule_849) TreeNodeAlloc (sizeof (struct _TPrule_849));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_849;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_849: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxNamedConstantDefList) MkxNamedConstantDefList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_849: root of subtree no. 2 can not be made a xNamedConstantDefList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_849;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_849 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_850 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_850 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_850 _currn;
#ifdef __cplusplus
_currn = new _TPrule_850;
#else
_currn = (_TPPrule_850) TreeNodeAlloc (sizeof (struct _TPrule_850));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_850;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_850: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxFmtSpec) MkxFmtSpec (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_850: root of subtree no. 2 can not be made a xFmtSpec node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_850;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_850 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_851 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_851 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_851 _currn;
#ifdef __cplusplus
_currn = new _TPrule_851;
#else
_currn = (_TPPrule_851) TreeNodeAlloc (sizeof (struct _TPrule_851));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_851;
_currn->_desc1 = (_TSPxLabel) MkxLabel (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_851: root of subtree no. 1 can not be made a xLabel node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_851;
return ( (NODEPTR) _currn);
}/* Mkrule_851 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_852 (POSITION *_coordref)
#else
NODEPTR Mkrule_852 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_852 _currn;
#ifdef __cplusplus
_currn = new _TPrule_852;
#else
_currn = (_TPPrule_852) TreeNodeAlloc (sizeof (struct _TPrule_852));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_852;
_SETCOORD(_currn)
_TERMACT_rule_852;
return ( (NODEPTR) _currn);
}/* Mkrule_852 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_853 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_853 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_853 _currn;
#ifdef __cplusplus
_currn = new _TPrule_853;
#else
_currn = (_TPPrule_853) TreeNodeAlloc (sizeof (struct _TPrule_853));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_853;
_currn->_desc1 = (_TSPxLabel) MkxLabel (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_853: root of subtree no. 1 can not be made a xLabel node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_853;
return ( (NODEPTR) _currn);
}/* Mkrule_853 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_854 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_854 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_854 _currn;
#ifdef __cplusplus
_currn = new _TPrule_854;
#else
_currn = (_TPPrule_854) TreeNodeAlloc (sizeof (struct _TPrule_854));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_854;
_SETCOORD(_currn)
_TERMACT_rule_854;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_854 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_855 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_855 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_855 _currn;
#ifdef __cplusplus
_currn = new _TPrule_855;
#else
_currn = (_TPPrule_855) TreeNodeAlloc (sizeof (struct _TPrule_855));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_855;
_currn->_desc1 = (_TSPxPointerObject) MkxPointerObject (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_855: root of subtree no. 1 can not be made a xPointerObject node ", 0, _coordref);
_currn->_desc2 = (_TSPxFieldSelector) MkxFieldSelector (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_855: root of subtree no. 2 can not be made a xFieldSelector node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_855;
return ( (NODEPTR) _currn);
}/* Mkrule_855 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_856 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_856 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_856 _currn;
#ifdef __cplusplus
_currn = new _TPrule_856;
#else
_currn = (_TPPrule_856) TreeNodeAlloc (sizeof (struct _TPrule_856));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_856;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_856: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_856;
return ( (NODEPTR) _currn);
}/* Mkrule_856 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_857 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_857 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_857 _currn;
#ifdef __cplusplus
_currn = new _TPrule_857;
#else
_currn = (_TPPrule_857) TreeNodeAlloc (sizeof (struct _TPrule_857));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_857;
_currn->_desc1 = (_TSPxDerivedName) MkxDerivedName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_857: root of subtree no. 1 can not be made a xDerivedName node ", 0, _coordref);
_currn->_desc2 = (_TSPxCompName) MkxCompName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_857: root of subtree no. 2 can not be made a xCompName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_857;
return ( (NODEPTR) _currn);
}/* Mkrule_857 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_858 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_858 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_858 _currn;
#ifdef __cplusplus
_currn = new _TPrule_858;
#else
_currn = (_TPPrule_858) TreeNodeAlloc (sizeof (struct _TPrule_858));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_858;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_858: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_858;
return ( (NODEPTR) _currn);
}/* Mkrule_858 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_859 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_859 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_859 _currn;
#ifdef __cplusplus
_currn = new _TPrule_859;
#else
_currn = (_TPPrule_859) TreeNodeAlloc (sizeof (struct _TPrule_859));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_859;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_859: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_currn->_desc2 = (_TSPxExprList) MkxExprList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_859: root of subtree no. 2 can not be made a xExprList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_859;
return ( (NODEPTR) _currn);
}/* Mkrule_859 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_860 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_860 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_860 _currn;
#ifdef __cplusplus
_currn = new _TPrule_860;
#else
_currn = (_TPPrule_860) TreeNodeAlloc (sizeof (struct _TPrule_860));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_860;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_860: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_currn->_desc2 = (_TSPxSFDummyArgNameList) MkxSFDummyArgNameList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_860: root of subtree no. 2 can not be made a xSFDummyArgNameList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_860;
return ( (NODEPTR) _currn);
}/* Mkrule_860 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_861 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_861 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_861 _currn;
#ifdef __cplusplus
_currn = new _TPrule_861;
#else
_currn = (_TPPrule_861) TreeNodeAlloc (sizeof (struct _TPrule_861));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_861;
_currn->_desc1 = (_TSPxStructureComponent) MkxStructureComponent (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_861: root of subtree no. 1 can not be made a xStructureComponent node ", 0, _coordref);
_currn->_desc2 = (_TSPxFieldSelector) MkxFieldSelector (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_861: root of subtree no. 2 can not be made a xFieldSelector node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_861;
return ( (NODEPTR) _currn);
}/* Mkrule_861 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_862 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_862 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_862 _currn;
#ifdef __cplusplus
_currn = new _TPrule_862;
#else
_currn = (_TPPrule_862) TreeNodeAlloc (sizeof (struct _TPrule_862));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_862;
_currn->_desc1 = (_TSPxVariableName) MkxVariableName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_862: root of subtree no. 1 can not be made a xVariableName node ", 0, _coordref);
_currn->_desc2 = (_TSPxFieldSelector) MkxFieldSelector (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_862: root of subtree no. 2 can not be made a xFieldSelector node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_862;
return ( (NODEPTR) _currn);
}/* Mkrule_862 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_863 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_863 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_863 _currn;
#ifdef __cplusplus
_currn = new _TPrule_863;
#else
_currn = (_TPPrule_863) TreeNodeAlloc (sizeof (struct _TPrule_863));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_863;
_currn->_desc1 = (_TSPxAllocateObject) MkxAllocateObject (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_863: root of subtree no. 1 can not be made a xAllocateObject node ", 0, _coordref);
_currn->_desc2 = (_TSPxFieldSelector) MkxFieldSelector (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_863: root of subtree no. 2 can not be made a xFieldSelector node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_863;
return ( (NODEPTR) _currn);
}/* Mkrule_863 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_864 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_864 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_864 _currn;
#ifdef __cplusplus
_currn = new _TPrule_864;
#else
_currn = (_TPPrule_864) TreeNodeAlloc (sizeof (struct _TPrule_864));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_864;
_currn->_desc1 = (_TSPxVariableName) MkxVariableName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_864: root of subtree no. 1 can not be made a xVariableName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_864;
return ( (NODEPTR) _currn);
}/* Mkrule_864 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_865 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_865 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_865 _currn;
#ifdef __cplusplus
_currn = new _TPrule_865;
#else
_currn = (_TPPrule_865) TreeNodeAlloc (sizeof (struct _TPrule_865));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_865;
_currn->_desc1 = (_TSPSMSVariable) MkSMSVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_865: root of subtree no. 1 can not be made a SMSVariable node ", 0, _coordref);
_currn->_desc2 = (_TSPxFieldSelector) MkxFieldSelector (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_865: root of subtree no. 2 can not be made a xFieldSelector node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_865;
return ( (NODEPTR) _currn);
}/* Mkrule_865 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_866 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_866 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_866 _currn;
#ifdef __cplusplus
_currn = new _TPrule_866;
#else
_currn = (_TPPrule_866) TreeNodeAlloc (sizeof (struct _TPrule_866));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_866;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_866: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_866;
return ( (NODEPTR) _currn);
}/* Mkrule_866 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_867 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_867 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_867 _currn;
#ifdef __cplusplus
_currn = new _TPrule_867;
#else
_currn = (_TPPrule_867) TreeNodeAlloc (sizeof (struct _TPrule_867));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_867;
_currn->_desc1 = (_TSPxCompName) MkxCompName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_867: root of subtree no. 1 can not be made a xCompName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_867;
return ( (NODEPTR) _currn);
}/* Mkrule_867 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_868 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_868 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_868 _currn;
#ifdef __cplusplus
_currn = new _TPrule_868;
#else
_currn = (_TPPrule_868) TreeNodeAlloc (sizeof (struct _TPrule_868));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_868;
_currn->_desc1 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_868: root of subtree no. 1 can not be made a xSectionSubscriptList node ", 0, _coordref);
_currn->_desc2 = (_TSPxCompName) MkxCompName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_868: root of subtree no. 2 can not be made a xCompName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_868;
return ( (NODEPTR) _currn);
}/* Mkrule_868 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_869 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_869 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_869 _currn;
#ifdef __cplusplus
_currn = new _TPrule_869;
#else
_currn = (_TPPrule_869) TreeNodeAlloc (sizeof (struct _TPrule_869));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_869;
_currn->_desc1 = (_TSPxDerivedTypeStmt) MkxDerivedTypeStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_869: root of subtree no. 1 can not be made a xDerivedTypeStmt node ", 0, _coordref);
_currn->_desc2 = (_TSPxDerivedBody) MkxDerivedBody (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_869: root of subtree no. 2 can not be made a xDerivedBody node ", 0, _coordref);
_currn->_desc3 = (_TSPxEndTypeStmt) MkxEndTypeStmt (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_869: root of subtree no. 3 can not be made a xEndTypeStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_869;
return ( (NODEPTR) _currn);
}/* Mkrule_869 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_870 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_870 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_870 _currn;
#ifdef __cplusplus
_currn = new _TPrule_870;
#else
_currn = (_TPPrule_870) TreeNodeAlloc (sizeof (struct _TPrule_870));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_870;
_currn->_desc1 = (_TSPxDerivedTypeBody) MkxDerivedTypeBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_870: root of subtree no. 1 can not be made a xDerivedTypeBody node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_870;
return ( (NODEPTR) _currn);
}/* Mkrule_870 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_871 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_871 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_871 _currn;
#ifdef __cplusplus
_currn = new _TPrule_871;
#else
_currn = (_TPPrule_871) TreeNodeAlloc (sizeof (struct _TPrule_871));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_871;
_currn->_desc1 = (_TSPxTypeUseName) MkxTypeUseName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_871: root of subtree no. 1 can not be made a xTypeUseName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_871;
return ( (NODEPTR) _currn);
}/* Mkrule_871 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_872 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_872 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_872 _currn;
#ifdef __cplusplus
_currn = new _TPrule_872;
#else
_currn = (_TPPrule_872) TreeNodeAlloc (sizeof (struct _TPrule_872));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_872;
_currn->_desc1 = (_TSPxTypeName) MkxTypeName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_872: root of subtree no. 1 can not be made a xTypeName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_872;
return ( (NODEPTR) _currn);
}/* Mkrule_872 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_873 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_873 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_873 _currn;
#ifdef __cplusplus
_currn = new _TPrule_873;
#else
_currn = (_TPPrule_873) TreeNodeAlloc (sizeof (struct _TPrule_873));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_873;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_873: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_873;
return ( (NODEPTR) _currn);
}/* Mkrule_873 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_874 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_874 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_874 _currn;
#ifdef __cplusplus
_currn = new _TPrule_874;
#else
_currn = (_TPPrule_874) TreeNodeAlloc (sizeof (struct _TPrule_874));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_874;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_874: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxBinOp) MkxBinOp (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_874: root of subtree no. 2 can not be made a xBinOp node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_874: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_874;
return ( (NODEPTR) _currn);
}/* Mkrule_874 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_875 (POSITION *_coordref)
#else
NODEPTR Mkrule_875 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_875 _currn;
#ifdef __cplusplus
_currn = new _TPrule_875;
#else
_currn = (_TPPrule_875) TreeNodeAlloc (sizeof (struct _TPrule_875));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_875;
_SETCOORD(_currn)
_TERMACT_rule_875;
return ( (NODEPTR) _currn);
}/* Mkrule_875 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_876 (POSITION *_coordref)
#else
NODEPTR Mkrule_876 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_876 _currn;
#ifdef __cplusplus
_currn = new _TPrule_876;
#else
_currn = (_TPPrule_876) TreeNodeAlloc (sizeof (struct _TPrule_876));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_876;
_SETCOORD(_currn)
_TERMACT_rule_876;
return ( (NODEPTR) _currn);
}/* Mkrule_876 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_877 (POSITION *_coordref)
#else
NODEPTR Mkrule_877 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_877 _currn;
#ifdef __cplusplus
_currn = new _TPrule_877;
#else
_currn = (_TPPrule_877) TreeNodeAlloc (sizeof (struct _TPrule_877));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_877;
_SETCOORD(_currn)
_TERMACT_rule_877;
return ( (NODEPTR) _currn);
}/* Mkrule_877 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_878 (POSITION *_coordref)
#else
NODEPTR Mkrule_878 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_878 _currn;
#ifdef __cplusplus
_currn = new _TPrule_878;
#else
_currn = (_TPPrule_878) TreeNodeAlloc (sizeof (struct _TPrule_878));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_878;
_SETCOORD(_currn)
_TERMACT_rule_878;
return ( (NODEPTR) _currn);
}/* Mkrule_878 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_879 (POSITION *_coordref)
#else
NODEPTR Mkrule_879 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_879 _currn;
#ifdef __cplusplus
_currn = new _TPrule_879;
#else
_currn = (_TPPrule_879) TreeNodeAlloc (sizeof (struct _TPrule_879));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_879;
_SETCOORD(_currn)
_TERMACT_rule_879;
return ( (NODEPTR) _currn);
}/* Mkrule_879 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_880 (POSITION *_coordref)
#else
NODEPTR Mkrule_880 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_880 _currn;
#ifdef __cplusplus
_currn = new _TPrule_880;
#else
_currn = (_TPPrule_880) TreeNodeAlloc (sizeof (struct _TPrule_880));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_880;
_SETCOORD(_currn)
_TERMACT_rule_880;
return ( (NODEPTR) _currn);
}/* Mkrule_880 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_881 (POSITION *_coordref)
#else
NODEPTR Mkrule_881 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_881 _currn;
#ifdef __cplusplus
_currn = new _TPrule_881;
#else
_currn = (_TPPrule_881) TreeNodeAlloc (sizeof (struct _TPrule_881));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_881;
_SETCOORD(_currn)
_TERMACT_rule_881;
return ( (NODEPTR) _currn);
}/* Mkrule_881 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_882 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_882 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_882 _currn;
#ifdef __cplusplus
_currn = new _TPrule_882;
#else
_currn = (_TPPrule_882) TreeNodeAlloc (sizeof (struct _TPrule_882));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_882;
_currn->_desc1 = (_TSPxUnOp) MkxUnOp (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_882: root of subtree no. 1 can not be made a xUnOp node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_882: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_882;
return ( (NODEPTR) _currn);
}/* Mkrule_882 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_883 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_883 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_883 _currn;
#ifdef __cplusplus
_currn = new _TPrule_883;
#else
_currn = (_TPPrule_883) TreeNodeAlloc (sizeof (struct _TPrule_883));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_883;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_883: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_883;
return ( (NODEPTR) _currn);
}/* Mkrule_883 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_884 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_884 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_884 _currn;
#ifdef __cplusplus
_currn = new _TPrule_884;
#else
_currn = (_TPPrule_884) TreeNodeAlloc (sizeof (struct _TPrule_884));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_884;
_currn->_desc1 = (_TSPxUnsignedArithmeticConstant) MkxUnsignedArithmeticConstant (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_884: root of subtree no. 1 can not be made a xUnsignedArithmeticConstant node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_884;
return ( (NODEPTR) _currn);
}/* Mkrule_884 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_885 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_885 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_885 _currn;
#ifdef __cplusplus
_currn = new _TPrule_885;
#else
_currn = (_TPPrule_885) TreeNodeAlloc (sizeof (struct _TPrule_885));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_885;
_SETCOORD(_currn)
_TERMACT_rule_885;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_885 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_886 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_886 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_886 _currn;
#ifdef __cplusplus
_currn = new _TPrule_886;
#else
_currn = (_TPPrule_886) TreeNodeAlloc (sizeof (struct _TPrule_886));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_886;
_currn->_desc1 = (_TSPxKindParam) MkxKindParam (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_886: root of subtree no. 1 can not be made a xKindParam node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_886;
return ( (NODEPTR) _currn);
}/* Mkrule_886 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_887 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_887 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_887 _currn;
#ifdef __cplusplus
_currn = new _TPrule_887;
#else
_currn = (_TPPrule_887) TreeNodeAlloc (sizeof (struct _TPrule_887));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_887;
_currn->_desc1 = (_TSPxKindParam) MkxKindParam (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_887: root of subtree no. 1 can not be made a xKindParam node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_887;
return ( (NODEPTR) _currn);
}/* Mkrule_887 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_888 (POSITION *_coordref, int _TERM1, NODEPTR _desc1)
#else
NODEPTR Mkrule_888 (_coordref, _TERM1,_desc1)
	POSITION *_coordref;
	int _TERM1;
	NODEPTR _desc1;
#endif
{	_TPPrule_888 _currn;
#ifdef __cplusplus
_currn = new _TPrule_888;
#else
_currn = (_TPPrule_888) TreeNodeAlloc (sizeof (struct _TPrule_888));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_888;
_currn->_desc1 = (_TSPxKindParam) MkxKindParam (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_888: root of subtree no. 1 can not be made a xKindParam node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_888;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xDcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_888 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_889 (POSITION *_coordref, int _TERM1, NODEPTR _desc1)
#else
NODEPTR Mkrule_889 (_coordref, _TERM1,_desc1)
	POSITION *_coordref;
	int _TERM1;
	NODEPTR _desc1;
#endif
{	_TPPrule_889 _currn;
#ifdef __cplusplus
_currn = new _TPrule_889;
#else
_currn = (_TPPrule_889) TreeNodeAlloc (sizeof (struct _TPrule_889));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_889;
_currn->_desc1 = (_TSPxKindParam) MkxKindParam (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_889: root of subtree no. 1 can not be made a xKindParam node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_889;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xRcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_889 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_890 (POSITION *_coordref, int _TERM1, NODEPTR _desc1)
#else
NODEPTR Mkrule_890 (_coordref, _TERM1,_desc1)
	POSITION *_coordref;
	int _TERM1;
	NODEPTR _desc1;
#endif
{	_TPPrule_890 _currn;
#ifdef __cplusplus
_currn = new _TPrule_890;
#else
_currn = (_TPPrule_890) TreeNodeAlloc (sizeof (struct _TPrule_890));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_890;
_currn->_desc1 = (_TSPxKindParam) MkxKindParam (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_890: root of subtree no. 1 can not be made a xKindParam node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_890;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_890 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_891 (POSITION *_coordref)
#else
NODEPTR Mkrule_891 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_891 _currn;
#ifdef __cplusplus
_currn = new _TPrule_891;
#else
_currn = (_TPPrule_891) TreeNodeAlloc (sizeof (struct _TPrule_891));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_891;
_SETCOORD(_currn)
_TERMACT_rule_891;
return ( (NODEPTR) _currn);
}/* Mkrule_891 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_892 (POSITION *_coordref)
#else
NODEPTR Mkrule_892 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_892 _currn;
#ifdef __cplusplus
_currn = new _TPrule_892;
#else
_currn = (_TPPrule_892) TreeNodeAlloc (sizeof (struct _TPrule_892));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_892;
_SETCOORD(_currn)
_TERMACT_rule_892;
return ( (NODEPTR) _currn);
}/* Mkrule_892 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_893 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_893 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_893 _currn;
#ifdef __cplusplus
_currn = new _TPrule_893;
#else
_currn = (_TPPrule_893) TreeNodeAlloc (sizeof (struct _TPrule_893));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_893;
_SETCOORD(_currn)
_TERMACT_rule_893;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xDcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_893 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_894 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_894 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_894 _currn;
#ifdef __cplusplus
_currn = new _TPrule_894;
#else
_currn = (_TPPrule_894) TreeNodeAlloc (sizeof (struct _TPrule_894));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_894;
_SETCOORD(_currn)
_TERMACT_rule_894;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xRcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_894 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_895 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_895 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_895 _currn;
#ifdef __cplusplus
_currn = new _TPrule_895;
#else
_currn = (_TPPrule_895) TreeNodeAlloc (sizeof (struct _TPrule_895));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_895;
_SETCOORD(_currn)
_TERMACT_rule_895;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_895 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_896 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_896 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_896 _currn;
#ifdef __cplusplus
_currn = new _TPrule_896;
#else
_currn = (_TPPrule_896) TreeNodeAlloc (sizeof (struct _TPrule_896));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_896;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_896: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_896;
return ( (NODEPTR) _currn);
}/* Mkrule_896 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_897 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_897 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_897 _currn;
#ifdef __cplusplus
_currn = new _TPrule_897;
#else
_currn = (_TPPrule_897) TreeNodeAlloc (sizeof (struct _TPrule_897));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_897;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_897: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_897;
return ( (NODEPTR) _currn);
}/* Mkrule_897 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1090 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1090 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1090 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1090;
#else
_currn = (_TPPrule_1090) TreeNodeAlloc (sizeof (struct _TPrule_1090));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1090;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1090: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndSubroutineStmt) MkxEndSubroutineStmt (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1090: root of subtree no. 2 can not be made a xEndSubroutineStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1090;
return ( (NODEPTR) _currn);
}/* Mkrule_1090 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1089 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1089 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1089 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1089;
#else
_currn = (_TPPrule_1089) TreeNodeAlloc (sizeof (struct _TPrule_1089));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1089;
_currn->_desc1 = (_TSPxEndSubroutineStmt) MkxEndSubroutineStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1089: root of subtree no. 1 can not be made a xEndSubroutineStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1089;
return ( (NODEPTR) _currn);
}/* Mkrule_1089 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1088 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1088 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1088 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1088;
#else
_currn = (_TPPrule_1088) TreeNodeAlloc (sizeof (struct _TPrule_1088));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1088;
_currn->_desc1 = (_TSPxDeclarePackedDecomp) MkxDeclarePackedDecomp (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1088: root of subtree no. 1 can not be made a xDeclarePackedDecomp node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1088;
return ( (NODEPTR) _currn);
}/* Mkrule_1088 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1087 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1087 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1087 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1087;
#else
_currn = (_TPPrule_1087) TreeNodeAlloc (sizeof (struct _TPrule_1087));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1087;
_currn->_desc1 = (_TSPxDeclareDecomp) MkxDeclareDecomp (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1087: root of subtree no. 1 can not be made a xDeclareDecomp node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1087;
return ( (NODEPTR) _currn);
}/* Mkrule_1087 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1086 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_1086 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_1086 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1086;
#else
_currn = (_TPPrule_1086) TreeNodeAlloc (sizeof (struct _TPrule_1086));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1086;
_currn->_desc1 = (_TSPxDirectiveBegin) MkxDirectiveBegin (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1086: root of subtree no. 1 can not be made a xDirectiveBegin node ", 0, _coordref);
_currn->_desc2 = (_TSPxBody) MkxBody (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1086: root of subtree no. 2 can not be made a xBody node ", 0, _coordref);
_currn->_desc3 = (_TSPxDirectiveEnd) MkxDirectiveEnd (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1086: root of subtree no. 3 can not be made a xDirectiveEnd node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1086;
return ( (NODEPTR) _currn);
}/* Mkrule_1086 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1085 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1085 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1085 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1085;
#else
_currn = (_TPPrule_1085) TreeNodeAlloc (sizeof (struct _TPrule_1085));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1085;
_currn->_desc1 = (_TSPxExchDirective) MkxExchDirective (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1085: root of subtree no. 1 can not be made a xExchDirective node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1085;
return ( (NODEPTR) _currn);
}/* Mkrule_1085 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1084 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1084 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1084 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1084;
#else
_currn = (_TPPrule_1084) TreeNodeAlloc (sizeof (struct _TPrule_1084));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1084;
_currn->_desc1 = (_TSPxDirectiveName) MkxDirectiveName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1084: root of subtree no. 1 can not be made a xDirectiveName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1084;
return ( (NODEPTR) _currn);
}/* Mkrule_1084 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1083 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1083 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1083 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1083;
#else
_currn = (_TPPrule_1083) TreeNodeAlloc (sizeof (struct _TPrule_1083));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1083;
_currn->_desc1 = (_TSPLocalReferenceEnd) MkLocalReferenceEnd (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1083: root of subtree no. 1 can not be made a LocalReferenceEnd node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1083;
return ( (NODEPTR) _currn);
}/* Mkrule_1083 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1082 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1082 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1082 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1082;
#else
_currn = (_TPPrule_1082) TreeNodeAlloc (sizeof (struct _TPrule_1082));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1082;
_currn->_desc1 = (_TSPLocalReference) MkLocalReference (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1082: root of subtree no. 1 can not be made a LocalReference node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1082;
return ( (NODEPTR) _currn);
}/* Mkrule_1082 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1081 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1081 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1081 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1081;
#else
_currn = (_TPPrule_1081) TreeNodeAlloc (sizeof (struct _TPrule_1081));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1081;
_currn->_desc1 = (_TSPGlobalReferenceEnd) MkGlobalReferenceEnd (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1081: root of subtree no. 1 can not be made a GlobalReferenceEnd node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1081;
return ( (NODEPTR) _currn);
}/* Mkrule_1081 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1080 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1080 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1080 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1080;
#else
_currn = (_TPPrule_1080) TreeNodeAlloc (sizeof (struct _TPrule_1080));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1080;
_currn->_desc1 = (_TSPGlobalReference) MkGlobalReference (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1080: root of subtree no. 1 can not be made a GlobalReference node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1080;
return ( (NODEPTR) _currn);
}/* Mkrule_1080 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1079 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_1079 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_1079 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1079;
#else
_currn = (_TPPrule_1079) TreeNodeAlloc (sizeof (struct _TPrule_1079));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1079;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1079: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_currn->_desc2 = (_TSPxExpr) MkxExpr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1079: root of subtree no. 2 can not be made a xExpr node ", 0, _coordref);
_currn->_desc3 = (_TSPxExpr) MkxExpr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1079: root of subtree no. 3 can not be made a xExpr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1079;
return ( (NODEPTR) _currn);
}/* Mkrule_1079 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1078 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_1078 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_1078 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1078;
#else
_currn = (_TPPrule_1078) TreeNodeAlloc (sizeof (struct _TPrule_1078));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1078;
_SETCOORD(_currn)
_TERMACT_rule_1078;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1078 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1077 (POSITION *_coordref)
#else
NODEPTR Mkrule_1077 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_1077 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1077;
#else
_currn = (_TPPrule_1077) TreeNodeAlloc (sizeof (struct _TPrule_1077));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1077;
_SETCOORD(_currn)
_TERMACT_rule_1077;
return ( (NODEPTR) _currn);
}/* Mkrule_1077 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1076 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1076 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1076 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1076;
#else
_currn = (_TPPrule_1076) TreeNodeAlloc (sizeof (struct _TPrule_1076));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1076;
_currn->_desc1 = (_TSPPeriodicLower) MkPeriodicLower (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1076: root of subtree no. 1 can not be made a PeriodicLower node ", 0, _coordref);
_currn->_desc2 = (_TSPPeriodicUpper) MkPeriodicUpper (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1076: root of subtree no. 2 can not be made a PeriodicUpper node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1076;
return ( (NODEPTR) _currn);
}/* Mkrule_1076 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1075 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1075 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1075 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1075;
#else
_currn = (_TPPrule_1075) TreeNodeAlloc (sizeof (struct _TPrule_1075));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1075;
_currn->_desc1 = (_TSPxParam) MkxParam (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1075: root of subtree no. 1 can not be made a xParam node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1075;
return ( (NODEPTR) _currn);
}/* Mkrule_1075 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1074 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_1074 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_1074 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1074;
#else
_currn = (_TPPrule_1074) TreeNodeAlloc (sizeof (struct _TPrule_1074));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1074;
_currn->_desc1 = (_TSPxParam) MkxParam (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1074: root of subtree no. 1 can not be made a xParam node ", 0, _coordref);
_currn->_desc2 = (_TSPBinOp) MkBinOp (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1074: root of subtree no. 2 can not be made a BinOp node ", 0, _coordref);
_currn->_desc3 = (_TSPxParams) MkxParams (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1074: root of subtree no. 3 can not be made a xParams node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1074;
return ( (NODEPTR) _currn);
}/* Mkrule_1074 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1073 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1073 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1073 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1073;
#else
_currn = (_TPPrule_1073) TreeNodeAlloc (sizeof (struct _TPrule_1073));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1073;
_currn->_desc1 = (_TSPxUnOp) MkxUnOp (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1073: root of subtree no. 1 can not be made a xUnOp node ", 0, _coordref);
_currn->_desc2 = (_TSPxParam) MkxParam (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1073: root of subtree no. 2 can not be made a xParam node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1073;
return ( (NODEPTR) _currn);
}/* Mkrule_1073 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1072 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1072 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1072 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1072;
#else
_currn = (_TPPrule_1072) TreeNodeAlloc (sizeof (struct _TPrule_1072));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1072;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1072: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1072;
return ( (NODEPTR) _currn);
}/* Mkrule_1072 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1071 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_1071 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_1071 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1071;
#else
_currn = (_TPPrule_1071) TreeNodeAlloc (sizeof (struct _TPrule_1071));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1071;
_SETCOORD(_currn)
_TERMACT_rule_1071;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1071 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1070 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1070 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1070 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1070;
#else
_currn = (_TPPrule_1070) TreeNodeAlloc (sizeof (struct _TPrule_1070));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1070;
_currn->_desc1 = (_TSPxParVariable) MkxParVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1070: root of subtree no. 1 can not be made a xParVariable node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1070;
return ( (NODEPTR) _currn);
}/* Mkrule_1070 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1069 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1069 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1069 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1069;
#else
_currn = (_TPPrule_1069) TreeNodeAlloc (sizeof (struct _TPrule_1069));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1069;
_currn->_desc1 = (_TSPxParVariable) MkxParVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1069: root of subtree no. 1 can not be made a xParVariable node ", 0, _coordref);
_currn->_desc2 = (_TSPxParVariables) MkxParVariables (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1069: root of subtree no. 2 can not be made a xParVariables node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1069;
return ( (NODEPTR) _currn);
}/* Mkrule_1069 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1068 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1068 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1068 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1068;
#else
_currn = (_TPPrule_1068) TreeNodeAlloc (sizeof (struct _TPrule_1068));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1068;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1068: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1068;
return ( (NODEPTR) _currn);
}/* Mkrule_1068 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1067 (POSITION *_coordref)
#else
NODEPTR Mkrule_1067 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_1067 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1067;
#else
_currn = (_TPPrule_1067) TreeNodeAlloc (sizeof (struct _TPrule_1067));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1067;
_SETCOORD(_currn)
_TERMACT_rule_1067;
return ( (NODEPTR) _currn);
}/* Mkrule_1067 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1066 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1066 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1066 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1066;
#else
_currn = (_TPPrule_1066) TreeNodeAlloc (sizeof (struct _TPrule_1066));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1066;
_currn->_desc1 = (_TSPKernelEnd) MkKernelEnd (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1066: root of subtree no. 1 can not be made a KernelEnd node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1066;
return ( (NODEPTR) _currn);
}/* Mkrule_1066 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1065 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1065 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1065 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1065;
#else
_currn = (_TPPrule_1065) TreeNodeAlloc (sizeof (struct _TPrule_1065));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1065;
_currn->_desc1 = (_TSPKernelBegin) MkKernelBegin (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1065: root of subtree no. 1 can not be made a KernelBegin node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1065;
return ( (NODEPTR) _currn);
}/* Mkrule_1065 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1064 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1064 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1064 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1064;
#else
_currn = (_TPPrule_1064) TreeNodeAlloc (sizeof (struct _TPrule_1064));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1064;
_currn->_desc1 = (_TSPAccThread) MkAccThread (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1064: root of subtree no. 1 can not be made a AccThread node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1064;
return ( (NODEPTR) _currn);
}/* Mkrule_1064 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1063 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1063 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1063 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1063;
#else
_currn = (_TPPrule_1063) TreeNodeAlloc (sizeof (struct _TPrule_1063));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1063;
_currn->_desc1 = (_TSPAccSync) MkAccSync (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1063: root of subtree no. 1 can not be made a AccSync node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1063;
return ( (NODEPTR) _currn);
}/* Mkrule_1063 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1062 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1062 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1062 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1062;
#else
_currn = (_TPPrule_1062) TreeNodeAlloc (sizeof (struct _TPrule_1062));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1062;
_currn->_desc1 = (_TSPAccDo) MkAccDo (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1062: root of subtree no. 1 can not be made a AccDo node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1062;
return ( (NODEPTR) _currn);
}/* Mkrule_1062 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1061 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1061 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1061 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1061;
#else
_currn = (_TPPrule_1061) TreeNodeAlloc (sizeof (struct _TPrule_1061));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1061;
_currn->_desc1 = (_TSPAccData) MkAccData (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1061: root of subtree no. 1 can not be made a AccData node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1061;
return ( (NODEPTR) _currn);
}/* Mkrule_1061 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1060 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1060 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1060 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1060;
#else
_currn = (_TPPrule_1060) TreeNodeAlloc (sizeof (struct _TPrule_1060));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1060;
_currn->_desc1 = (_TSPxBody) MkxBody (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1060: root of subtree no. 1 can not be made a xBody node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndFunctionStmt) MkxEndFunctionStmt (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1060: root of subtree no. 2 can not be made a xEndFunctionStmt node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1060;
return ( (NODEPTR) _currn);
}/* Mkrule_1060 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1059 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1059 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1059 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1059;
#else
_currn = (_TPPrule_1059) TreeNodeAlloc (sizeof (struct _TPrule_1059));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1059;
_currn->_desc1 = (_TSPxEndFunctionStmt) MkxEndFunctionStmt (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1059: root of subtree no. 1 can not be made a xEndFunctionStmt node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1059;
return ( (NODEPTR) _currn);
}/* Mkrule_1059 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1058 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1058 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1058 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1058;
#else
_currn = (_TPPrule_1058) TreeNodeAlloc (sizeof (struct _TPrule_1058));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1058;
_currn->_desc1 = (_TSPxSMSDirectives) MkxSMSDirectives (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1058: root of subtree no. 1 can not be made a xSMSDirectives node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1058;
return ( (NODEPTR) _currn);
}/* Mkrule_1058 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1057 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1057 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1057 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1057;
#else
_currn = (_TPPrule_1057) TreeNodeAlloc (sizeof (struct _TPrule_1057));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1057;
_currn->_desc1 = (_TSPxGPUDirectives) MkxGPUDirectives (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1057: root of subtree no. 1 can not be made a xGPUDirectives node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1057;
return ( (NODEPTR) _currn);
}/* Mkrule_1057 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1056 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1056 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1056 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1056;
#else
_currn = (_TPPrule_1056) TreeNodeAlloc (sizeof (struct _TPrule_1056));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1056;
_currn->_desc1 = (_TSPxExchangeVariables) MkxExchangeVariables (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1056: root of subtree no. 1 can not be made a xExchangeVariables node ", 0, _coordref);
_currn->_desc2 = (_TSPxExchangeVariable) MkxExchangeVariable (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1056: root of subtree no. 2 can not be made a xExchangeVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1056;
return ( (NODEPTR) _currn);
}/* Mkrule_1056 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1055 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1055 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1055 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1055;
#else
_currn = (_TPPrule_1055) TreeNodeAlloc (sizeof (struct _TPrule_1055));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1055;
_currn->_desc1 = (_TSPxExchangeVariable) MkxExchangeVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1055: root of subtree no. 1 can not be made a xExchangeVariable node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1055;
return ( (NODEPTR) _currn);
}/* Mkrule_1055 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1054 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1054 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1054 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1054;
#else
_currn = (_TPPrule_1054) TreeNodeAlloc (sizeof (struct _TPrule_1054));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1054;
_currn->_desc1 = (_TSPSMSVariable) MkSMSVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1054: root of subtree no. 1 can not be made a SMSVariable node ", 0, _coordref);
_currn->_desc2 = (_TSPxExchangeOptions) MkxExchangeOptions (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1054: root of subtree no. 2 can not be made a xExchangeOptions node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1054;
return ( (NODEPTR) _currn);
}/* Mkrule_1054 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1053 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1053 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1053 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1053;
#else
_currn = (_TPPrule_1053) TreeNodeAlloc (sizeof (struct _TPrule_1053));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1053;
_currn->_desc1 = (_TSPHaloThicks) MkHaloThicks (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1053: root of subtree no. 1 can not be made a HaloThicks node ", 0, _coordref);
_currn->_desc2 = (_TSPHaloOptions) MkHaloOptions (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1053: root of subtree no. 2 can not be made a HaloOptions node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1053;
return ( (NODEPTR) _currn);
}/* Mkrule_1053 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1052 (POSITION *_coordref)
#else
NODEPTR Mkrule_1052 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_1052 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1052;
#else
_currn = (_TPPrule_1052) TreeNodeAlloc (sizeof (struct _TPrule_1052));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1052;
_SETCOORD(_currn)
_TERMACT_rule_1052;
return ( (NODEPTR) _currn);
}/* Mkrule_1052 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1051 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_1051 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_1051 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1051;
#else
_currn = (_TPPrule_1051) TreeNodeAlloc (sizeof (struct _TPrule_1051));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1051;
_SETCOORD(_currn)
_TERMACT_rule_1051;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1051 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1050 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_1050 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_1050 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1050;
#else
_currn = (_TPPrule_1050) TreeNodeAlloc (sizeof (struct _TPrule_1050));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1050;
_SETCOORD(_currn)
_TERMACT_rule_1050;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1050 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1049 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_1049 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_1049 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1049;
#else
_currn = (_TPPrule_1049) TreeNodeAlloc (sizeof (struct _TPrule_1049));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1049;
_currn->_desc1 = (_TSPHaloDirectiveName) MkHaloDirectiveName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1049: root of subtree no. 1 can not be made a HaloDirectiveName node ", 0, _coordref);
_currn->_desc2 = (_TSPxExchangeVariables) MkxExchangeVariables (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1049: root of subtree no. 2 can not be made a xExchangeVariables node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1049;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1049 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1048 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1048 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1048 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1048;
#else
_currn = (_TPPrule_1048) TreeNodeAlloc (sizeof (struct _TPrule_1048));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1048;
_currn->_desc1 = (_TSPxEntityDecl) MkxEntityDecl (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1048: root of subtree no. 1 can not be made a xEntityDecl node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1048;
return ( (NODEPTR) _currn);
}/* Mkrule_1048 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1047 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_1047 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_1047 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1047;
#else
_currn = (_TPPrule_1047) TreeNodeAlloc (sizeof (struct _TPrule_1047));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1047;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1047: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1047: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1047;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1047 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1046 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_1046 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_1046 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1046;
#else
_currn = (_TPPrule_1046) TreeNodeAlloc (sizeof (struct _TPrule_1046));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1046;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1046: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1046;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1046 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1045 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_1045 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_1045 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1045;
#else
_currn = (_TPPrule_1045) TreeNodeAlloc (sizeof (struct _TPrule_1045));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1045;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1045: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1045;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1045 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1044 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_1044 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_1044 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1044;
#else
_currn = (_TPPrule_1044) TreeNodeAlloc (sizeof (struct _TPrule_1044));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1044;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1044: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxEndName) MkxEndName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1044: root of subtree no. 2 can not be made a xEndName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1044;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1044 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1043 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_1043 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_1043 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1043;
#else
_currn = (_TPPrule_1043) TreeNodeAlloc (sizeof (struct _TPrule_1043));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1043;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1043: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1043;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1043 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1042 (POSITION *_coordref)
#else
NODEPTR Mkrule_1042 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_1042 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1042;
#else
_currn = (_TPPrule_1042) TreeNodeAlloc (sizeof (struct _TPrule_1042));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1042;
_SETCOORD(_currn)
_TERMACT_rule_1042;
return ( (NODEPTR) _currn);
}/* Mkrule_1042 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1041 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1041 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1041 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1041;
#else
_currn = (_TPPrule_1041) TreeNodeAlloc (sizeof (struct _TPrule_1041));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1041;
_currn->_desc1 = (_TSPxDirectiveParam) MkxDirectiveParam (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1041: root of subtree no. 1 can not be made a xDirectiveParam node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1041;
return ( (NODEPTR) _currn);
}/* Mkrule_1041 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1040 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1040 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1040 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1040;
#else
_currn = (_TPPrule_1040) TreeNodeAlloc (sizeof (struct _TPrule_1040));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1040;
_currn->_desc1 = (_TSPxDirectiveParam) MkxDirectiveParam (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1040: root of subtree no. 1 can not be made a xDirectiveParam node ", 0, _coordref);
_currn->_desc2 = (_TSPxDirectiveParam) MkxDirectiveParam (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1040: root of subtree no. 2 can not be made a xDirectiveParam node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1040;
return ( (NODEPTR) _currn);
}/* Mkrule_1040 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1039 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_1039 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_1039 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1039;
#else
_currn = (_TPPrule_1039) TreeNodeAlloc (sizeof (struct _TPrule_1039));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1039;
_currn->_desc1 = (_TSPxDirectiveParam) MkxDirectiveParam (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1039: root of subtree no. 1 can not be made a xDirectiveParam node ", 0, _coordref);
_currn->_desc2 = (_TSPxDirectiveParam) MkxDirectiveParam (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1039: root of subtree no. 2 can not be made a xDirectiveParam node ", 0, _coordref);
_currn->_desc3 = (_TSPxDirectiveParam) MkxDirectiveParam (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1039: root of subtree no. 3 can not be made a xDirectiveParam node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1039;
return ( (NODEPTR) _currn);
}/* Mkrule_1039 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1038 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1038 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1038 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1038;
#else
_currn = (_TPPrule_1038) TreeNodeAlloc (sizeof (struct _TPrule_1038));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1038;
_currn->_desc1 = (_TSPxParVariable) MkxParVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1038: root of subtree no. 1 can not be made a xParVariable node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1038;
return ( (NODEPTR) _currn);
}/* Mkrule_1038 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1037 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1037 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1037 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1037;
#else
_currn = (_TPPrule_1037) TreeNodeAlloc (sizeof (struct _TPrule_1037));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1037;
_currn->_desc1 = (_TSPxParVariables) MkxParVariables (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1037: root of subtree no. 1 can not be made a xParVariables node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1037;
return ( (NODEPTR) _currn);
}/* Mkrule_1037 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1036 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_1036 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_1036 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1036;
#else
_currn = (_TPPrule_1036) TreeNodeAlloc (sizeof (struct _TPrule_1036));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1036;
_SETCOORD(_currn)
_TERMACT_rule_1036;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1036 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1035 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_1035 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_1035 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1035;
#else
_currn = (_TPPrule_1035) TreeNodeAlloc (sizeof (struct _TPrule_1035));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1035;
_currn->_desc1 = (_TSPHaloCouplets) MkHaloCouplets (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1035: root of subtree no. 1 can not be made a HaloCouplets node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1035;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1035 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1034 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_1034 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_1034 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1034;
#else
_currn = (_TPPrule_1034) TreeNodeAlloc (sizeof (struct _TPrule_1034));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1034;
_currn->_desc1 = (_TSPHaloAllDims) MkHaloAllDims (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1034: root of subtree no. 1 can not be made a HaloAllDims node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1034;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1034 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1033 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_1033 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_1033 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1033;
#else
_currn = (_TPPrule_1033) TreeNodeAlloc (sizeof (struct _TPrule_1033));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1033;
_SETCOORD(_currn)
_TERMACT_rule_1033;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1033 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1032 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_1032 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_1032 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1032;
#else
_currn = (_TPPrule_1032) TreeNodeAlloc (sizeof (struct _TPrule_1032));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1032;
_currn->_desc1 = (_TSPxDecomp_Handle) MkxDecomp_Handle (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1032: root of subtree no. 1 can not be made a xDecomp_Handle node ", 0, _coordref);
_currn->_desc2 = (_TSPxDirectiveParams) MkxDirectiveParams (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1032: root of subtree no. 2 can not be made a xDirectiveParams node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1032;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1032 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1031 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_1031 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_1031 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1031;
#else
_currn = (_TPPrule_1031) TreeNodeAlloc (sizeof (struct _TPrule_1031));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1031;
_SETCOORD(_currn)
_TERMACT_rule_1031;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1031 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1030 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1030 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1030 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1030;
#else
_currn = (_TPPrule_1030) TreeNodeAlloc (sizeof (struct _TPrule_1030));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1030;
_currn->_desc1 = (_TSPxDeclareDecomp) MkxDeclareDecomp (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1030: root of subtree no. 1 can not be made a xDeclareDecomp node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1030;
return ( (NODEPTR) _currn);
}/* Mkrule_1030 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1029 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1029 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1029 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1029;
#else
_currn = (_TPPrule_1029) TreeNodeAlloc (sizeof (struct _TPrule_1029));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1029;
_currn->_desc1 = (_TSPxDecomp_Expr) MkxDecomp_Expr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1029: root of subtree no. 1 can not be made a xDecomp_Expr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1029;
return ( (NODEPTR) _currn);
}/* Mkrule_1029 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1028 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1028 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1028 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1028;
#else
_currn = (_TPPrule_1028) TreeNodeAlloc (sizeof (struct _TPrule_1028));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1028;
_currn->_desc1 = (_TSPSMSVariable) MkSMSVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1028: root of subtree no. 1 can not be made a SMSVariable node ", 0, _coordref);
_currn->_desc2 = (_TSPNumHandles) MkNumHandles (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1028: root of subtree no. 2 can not be made a NumHandles node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1028;
return ( (NODEPTR) _currn);
}/* Mkrule_1028 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1027 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1027 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1027 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1027;
#else
_currn = (_TPPrule_1027) TreeNodeAlloc (sizeof (struct _TPrule_1027));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1027;
_currn->_desc1 = (_TSPxDecomp_Size) MkxDecomp_Size (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1027: root of subtree no. 1 can not be made a xDecomp_Size node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1027;
return ( (NODEPTR) _currn);
}/* Mkrule_1027 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1026 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1026 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1026 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1026;
#else
_currn = (_TPPrule_1026) TreeNodeAlloc (sizeof (struct _TPrule_1026));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1026;
_currn->_desc1 = (_TSPxDecomp_Size) MkxDecomp_Size (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1026: root of subtree no. 1 can not be made a xDecomp_Size node ", 0, _coordref);
_currn->_desc2 = (_TSPxDecomp_Size) MkxDecomp_Size (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1026: root of subtree no. 2 can not be made a xDecomp_Size node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1026;
return ( (NODEPTR) _currn);
}/* Mkrule_1026 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1025 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_1025 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_1025 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1025;
#else
_currn = (_TPPrule_1025) TreeNodeAlloc (sizeof (struct _TPrule_1025));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1025;
_currn->_desc1 = (_TSPxDecomp_Size) MkxDecomp_Size (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1025: root of subtree no. 1 can not be made a xDecomp_Size node ", 0, _coordref);
_currn->_desc2 = (_TSPxDecomp_Size) MkxDecomp_Size (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1025: root of subtree no. 2 can not be made a xDecomp_Size node ", 0, _coordref);
_currn->_desc3 = (_TSPxDecomp_Size) MkxDecomp_Size (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1025: root of subtree no. 3 can not be made a xDecomp_Size node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1025;
return ( (NODEPTR) _currn);
}/* Mkrule_1025 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1024 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1024 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1024 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1024;
#else
_currn = (_TPPrule_1024) TreeNodeAlloc (sizeof (struct _TPrule_1024));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1024;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1024: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1024;
return ( (NODEPTR) _currn);
}/* Mkrule_1024 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1023 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1023 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1023 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1023;
#else
_currn = (_TPPrule_1023) TreeNodeAlloc (sizeof (struct _TPrule_1023));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1023;
_currn->_desc1 = (_TSPDecompRank) MkDecompRank (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1023: root of subtree no. 1 can not be made a DecompRank node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1023;
return ( (NODEPTR) _currn);
}/* Mkrule_1023 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1022 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1022 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1022 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1022;
#else
_currn = (_TPPrule_1022) TreeNodeAlloc (sizeof (struct _TPrule_1022));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1022;
_currn->_desc1 = (_TSPxDecomp_Expr) MkxDecomp_Expr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1022: root of subtree no. 1 can not be made a xDecomp_Expr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1022;
return ( (NODEPTR) _currn);
}/* Mkrule_1022 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1021 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1021 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1021 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1021;
#else
_currn = (_TPPrule_1021) TreeNodeAlloc (sizeof (struct _TPrule_1021));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1021;
_currn->_desc1 = (_TSPxDecomp_Expr) MkxDecomp_Expr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1021: root of subtree no. 1 can not be made a xDecomp_Expr node ", 0, _coordref);
_currn->_desc2 = (_TSPxDecomp_Expr) MkxDecomp_Expr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1021: root of subtree no. 2 can not be made a xDecomp_Expr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1021;
return ( (NODEPTR) _currn);
}/* Mkrule_1021 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1020 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_1020 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_1020 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1020;
#else
_currn = (_TPPrule_1020) TreeNodeAlloc (sizeof (struct _TPrule_1020));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1020;
_currn->_desc1 = (_TSPxDecomp_Expr) MkxDecomp_Expr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1020: root of subtree no. 1 can not be made a xDecomp_Expr node ", 0, _coordref);
_currn->_desc2 = (_TSPxDecomp_Expr) MkxDecomp_Expr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1020: root of subtree no. 2 can not be made a xDecomp_Expr node ", 0, _coordref);
_currn->_desc3 = (_TSPxDecomp_Expr) MkxDecomp_Expr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1020: root of subtree no. 3 can not be made a xDecomp_Expr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1020;
return ( (NODEPTR) _currn);
}/* Mkrule_1020 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1019 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1019 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1019 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1019;
#else
_currn = (_TPPrule_1019) TreeNodeAlloc (sizeof (struct _TPrule_1019));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1019;
_currn->_desc1 = (_TSPxDecomp_GlobalSizes) MkxDecomp_GlobalSizes (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1019: root of subtree no. 1 can not be made a xDecomp_GlobalSizes node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1019;
return ( (NODEPTR) _currn);
}/* Mkrule_1019 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1018 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1018 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1018 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1018;
#else
_currn = (_TPPrule_1018) TreeNodeAlloc (sizeof (struct _TPrule_1018));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1018;
_currn->_desc1 = (_TSPxDecomp_GlobalSizes) MkxDecomp_GlobalSizes (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1018: root of subtree no. 1 can not be made a xDecomp_GlobalSizes node ", 0, _coordref);
_currn->_desc2 = (_TSPxDecompHalos) MkxDecompHalos (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1018: root of subtree no. 2 can not be made a xDecompHalos node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1018;
return ( (NODEPTR) _currn);
}/* Mkrule_1018 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1017 (POSITION *_coordref)
#else
NODEPTR Mkrule_1017 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_1017 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1017;
#else
_currn = (_TPPrule_1017) TreeNodeAlloc (sizeof (struct _TPrule_1017));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1017;
_SETCOORD(_currn)
_TERMACT_rule_1017;
return ( (NODEPTR) _currn);
}/* Mkrule_1017 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1016 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1016 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1016 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1016;
#else
_currn = (_TPPrule_1016) TreeNodeAlloc (sizeof (struct _TPrule_1016));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1016;
_currn->_desc1 = (_TSPDecompOption) MkDecompOption (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1016: root of subtree no. 1 can not be made a DecompOption node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1016;
return ( (NODEPTR) _currn);
}/* Mkrule_1016 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1015 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1015 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1015 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1015;
#else
_currn = (_TPPrule_1015) TreeNodeAlloc (sizeof (struct _TPrule_1015));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1015;
_currn->_desc1 = (_TSPDecompLowBounds) MkDecompLowBounds (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1015: root of subtree no. 1 can not be made a DecompLowBounds node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1015;
return ( (NODEPTR) _currn);
}/* Mkrule_1015 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1014 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1014 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1014 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1014;
#else
_currn = (_TPPrule_1014) TreeNodeAlloc (sizeof (struct _TPrule_1014));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1014;
_currn->_desc1 = (_TSPDecompLowBounds) MkDecompLowBounds (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1014: root of subtree no. 1 can not be made a DecompLowBounds node ", 0, _coordref);
_currn->_desc2 = (_TSPDecompOption) MkDecompOption (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1014: root of subtree no. 2 can not be made a DecompOption node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1014;
return ( (NODEPTR) _currn);
}/* Mkrule_1014 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1013 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1013 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1013 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1013;
#else
_currn = (_TPPrule_1013) TreeNodeAlloc (sizeof (struct _TPrule_1013));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1013;
_currn->_desc1 = (_TSPxDecomp_Expr) MkxDecomp_Expr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1013: root of subtree no. 1 can not be made a xDecomp_Expr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1013;
return ( (NODEPTR) _currn);
}/* Mkrule_1013 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1012 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1012 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1012 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1012;
#else
_currn = (_TPPrule_1012) TreeNodeAlloc (sizeof (struct _TPrule_1012));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1012;
_currn->_desc1 = (_TSPxDecomp_Expr) MkxDecomp_Expr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1012: root of subtree no. 1 can not be made a xDecomp_Expr node ", 0, _coordref);
_currn->_desc2 = (_TSPxDecomp_Expr) MkxDecomp_Expr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1012: root of subtree no. 2 can not be made a xDecomp_Expr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1012;
return ( (NODEPTR) _currn);
}/* Mkrule_1012 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1011 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_1011 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_1011 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1011;
#else
_currn = (_TPPrule_1011) TreeNodeAlloc (sizeof (struct _TPrule_1011));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1011;
_currn->_desc1 = (_TSPxDecomp_Expr) MkxDecomp_Expr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1011: root of subtree no. 1 can not be made a xDecomp_Expr node ", 0, _coordref);
_currn->_desc2 = (_TSPxDecomp_Expr) MkxDecomp_Expr (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1011: root of subtree no. 2 can not be made a xDecomp_Expr node ", 0, _coordref);
_currn->_desc3 = (_TSPxDecomp_Expr) MkxDecomp_Expr (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1011: root of subtree no. 3 can not be made a xDecomp_Expr node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1011;
return ( (NODEPTR) _currn);
}/* Mkrule_1011 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1010 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1010 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1010 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1010;
#else
_currn = (_TPPrule_1010) TreeNodeAlloc (sizeof (struct _TPrule_1010));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1010;
_currn->_desc1 = (_TSPxDecompLowBounds) MkxDecompLowBounds (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1010: root of subtree no. 1 can not be made a xDecompLowBounds node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1010;
return ( (NODEPTR) _currn);
}/* Mkrule_1010 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1009 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_1009 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_1009 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1009;
#else
_currn = (_TPPrule_1009) TreeNodeAlloc (sizeof (struct _TPrule_1009));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1009;
_currn->_desc1 = (_TSPxDecomp_ActualSizes) MkxDecomp_ActualSizes (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1009: root of subtree no. 1 can not be made a xDecomp_ActualSizes node ", 0, _coordref);
_currn->_desc2 = (_TSPxDecompLowBounds) MkxDecompLowBounds (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1009: root of subtree no. 2 can not be made a xDecompLowBounds node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1009;
return ( (NODEPTR) _currn);
}/* Mkrule_1009 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1008 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_1008 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_1008 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1008;
#else
_currn = (_TPPrule_1008) TreeNodeAlloc (sizeof (struct _TPrule_1008));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1008;
_currn->_desc1 = (_TSPxDecomp_Handle) MkxDecomp_Handle (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1008: root of subtree no. 1 can not be made a xDecomp_Handle node ", 0, _coordref);
_currn->_desc2 = (_TSPParentDecomp_Handle) MkParentDecomp_Handle (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1008: root of subtree no. 2 can not be made a ParentDecomp_Handle node ", 0, _coordref);
_currn->_desc3 = (_TSPxDecompActuals) MkxDecompActuals (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1008: root of subtree no. 3 can not be made a xDecompActuals node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1008;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1008 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1007 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_1007 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_1007 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1007;
#else
_currn = (_TPPrule_1007) TreeNodeAlloc (sizeof (struct _TPrule_1007));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1007;
_currn->_desc1 = (_TSPxDecomp_Handle) MkxDecomp_Handle (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1007: root of subtree no. 1 can not be made a xDecomp_Handle node ", 0, _coordref);
_currn->_desc2 = (_TSPxDecompActuals) MkxDecompActuals (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1007: root of subtree no. 2 can not be made a xDecompActuals node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1007;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1007 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1006 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, NODEPTR _desc4, NODEPTR _desc5, int _TERM1)
#else
NODEPTR Mkrule_1006 (_coordref,_desc1,_desc2,_desc3,_desc4,_desc5, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	NODEPTR _desc4;
	NODEPTR _desc5;
	int _TERM1;
#endif
{	_TPPrule_1006 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1006;
#else
_currn = (_TPPrule_1006) TreeNodeAlloc (sizeof (struct _TPrule_1006));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1006;
_currn->_desc1 = (_TSPxDecomp_Handle) MkxDecomp_Handle (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1006: root of subtree no. 1 can not be made a xDecomp_Handle node ", 0, _coordref);
_currn->_desc2 = (_TSPxDecomp_GlobalSizes) MkxDecomp_GlobalSizes (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1006: root of subtree no. 2 can not be made a xDecomp_GlobalSizes node ", 0, _coordref);
_currn->_desc3 = (_TSPNumPackedRows) MkNumPackedRows (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1006: root of subtree no. 3 can not be made a NumPackedRows node ", 0, _coordref);
_currn->_desc4 = (_TSPPackedRowSizes) MkPackedRowSizes (_coordref, _desc4);	
if (((NODEPTR)_currn->_desc4) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1006: root of subtree no. 4 can not be made a PackedRowSizes node ", 0, _coordref);
_currn->_desc5 = (_TSPCreatePackedOptions) MkCreatePackedOptions (_coordref, _desc5);	
if (((NODEPTR)_currn->_desc5) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1006: root of subtree no. 5 can not be made a CreatePackedOptions node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1006;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1006 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1005 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3, int _TERM1)
#else
NODEPTR Mkrule_1005 (_coordref,_desc1,_desc2,_desc3, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
	int _TERM1;
#endif
{	_TPPrule_1005 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1005;
#else
_currn = (_TPPrule_1005) TreeNodeAlloc (sizeof (struct _TPrule_1005));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1005;
_currn->_desc1 = (_TSPxDecomp_Handle) MkxDecomp_Handle (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1005: root of subtree no. 1 can not be made a xDecomp_Handle node ", 0, _coordref);
_currn->_desc2 = (_TSPxDecompSizes) MkxDecompSizes (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1005: root of subtree no. 2 can not be made a xDecompSizes node ", 0, _coordref);
_currn->_desc3 = (_TSPCreateOptions) MkCreateOptions (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1005: root of subtree no. 3 can not be made a CreateOptions node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1005;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1005 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1004 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1004 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1004 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1004;
#else
_currn = (_TPPrule_1004) TreeNodeAlloc (sizeof (struct _TPrule_1004));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1004;
_currn->_desc1 = (_TSPxSMS_ParRegion) MkxSMS_ParRegion (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1004: root of subtree no. 1 can not be made a xSMS_ParRegion node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1004;
return ( (NODEPTR) _currn);
}/* Mkrule_1004 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1003 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1003 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1003 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1003;
#else
_currn = (_TPPrule_1003) TreeNodeAlloc (sizeof (struct _TPrule_1003));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1003;
_currn->_desc1 = (_TSPxCreatePackedDecomp) MkxCreatePackedDecomp (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1003: root of subtree no. 1 can not be made a xCreatePackedDecomp node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1003;
return ( (NODEPTR) _currn);
}/* Mkrule_1003 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1002 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_1002 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_1002 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1002;
#else
_currn = (_TPPrule_1002) TreeNodeAlloc (sizeof (struct _TPrule_1002));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1002;
_currn->_desc1 = (_TSPxCreateDecomp) MkxCreateDecomp (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1002: root of subtree no. 1 can not be made a xCreateDecomp node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_1002;
return ( (NODEPTR) _currn);
}/* Mkrule_1002 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1001 (POSITION *_coordref, NODEPTR _desc1, int _TERM1)
#else
NODEPTR Mkrule_1001 (_coordref,_desc1, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	int _TERM1;
#endif
{	_TPPrule_1001 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1001;
#else
_currn = (_TPPrule_1001) TreeNodeAlloc (sizeof (struct _TPrule_1001));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1001;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1001: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1001;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1001 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_1000 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_1000 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_1000 _currn;
#ifdef __cplusplus
_currn = new _TPrule_1000;
#else
_currn = (_TPPrule_1000) TreeNodeAlloc (sizeof (struct _TPrule_1000));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_1000;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1000: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxBlockDataName) MkxBlockDataName (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_1000: root of subtree no. 2 can not be made a xBlockDataName node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_1000;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_1000 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_999 (POSITION *_coordref)
#else
NODEPTR Mkrule_999 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_999 _currn;
#ifdef __cplusplus
_currn = new _TPrule_999;
#else
_currn = (_TPPrule_999) TreeNodeAlloc (sizeof (struct _TPrule_999));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_999;
_SETCOORD(_currn)
_TERMACT_rule_999;
return ( (NODEPTR) _currn);
}/* Mkrule_999 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_998 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_998 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_998 _currn;
#ifdef __cplusplus
_currn = new _TPrule_998;
#else
_currn = (_TPPrule_998) TreeNodeAlloc (sizeof (struct _TPrule_998));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_998;
_currn->_desc1 = (_TSPxArrayDeclaratorList) MkxArrayDeclaratorList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_998: root of subtree no. 1 can not be made a xArrayDeclaratorList node ", 0, _coordref);
_currn->_desc2 = (_TSPxArrayDeclarator) MkxArrayDeclarator (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_998: root of subtree no. 2 can not be made a xArrayDeclarator node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_998;
return ( (NODEPTR) _currn);
}/* Mkrule_998 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_997 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_997 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_997 _currn;
#ifdef __cplusplus
_currn = new _TPrule_997;
#else
_currn = (_TPPrule_997) TreeNodeAlloc (sizeof (struct _TPrule_997));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_997;
_currn->_desc1 = (_TSPxArrayDeclarator) MkxArrayDeclarator (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_997: root of subtree no. 1 can not be made a xArrayDeclarator node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_997;
return ( (NODEPTR) _currn);
}/* Mkrule_997 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_996 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_996 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_996 _currn;
#ifdef __cplusplus
_currn = new _TPrule_996;
#else
_currn = (_TPPrule_996) TreeNodeAlloc (sizeof (struct _TPrule_996));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_996;
_currn->_desc1 = (_TSPxArrayAllocationList) MkxArrayAllocationList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_996: root of subtree no. 1 can not be made a xArrayAllocationList node ", 0, _coordref);
_currn->_desc2 = (_TSPxArrayAllocation) MkxArrayAllocation (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_996: root of subtree no. 2 can not be made a xArrayAllocation node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_996;
return ( (NODEPTR) _currn);
}/* Mkrule_996 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_995 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_995 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_995 _currn;
#ifdef __cplusplus
_currn = new _TPrule_995;
#else
_currn = (_TPPrule_995) TreeNodeAlloc (sizeof (struct _TPrule_995));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_995;
_currn->_desc1 = (_TSPxArrayAllocation) MkxArrayAllocation (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_995: root of subtree no. 1 can not be made a xArrayAllocation node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_995;
return ( (NODEPTR) _currn);
}/* Mkrule_995 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_994 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_994 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_994 _currn;
#ifdef __cplusplus
_currn = new _TPrule_994;
#else
_currn = (_TPPrule_994) TreeNodeAlloc (sizeof (struct _TPrule_994));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_994;
_currn->_desc1 = (_TSPxArrayName) MkxArrayName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_994: root of subtree no. 1 can not be made a xArrayName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_994;
return ( (NODEPTR) _currn);
}/* Mkrule_994 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_993 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_993 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_993 _currn;
#ifdef __cplusplus
_currn = new _TPrule_993;
#else
_currn = (_TPPrule_993) TreeNodeAlloc (sizeof (struct _TPrule_993));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_993;
_currn->_desc1 = (_TSPxAllocationList) MkxAllocationList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_993: root of subtree no. 1 can not be made a xAllocationList node ", 0, _coordref);
_currn->_desc2 = (_TSPxAllocation) MkxAllocation (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_993: root of subtree no. 2 can not be made a xAllocation node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_993;
return ( (NODEPTR) _currn);
}/* Mkrule_993 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_992 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_992 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_992 _currn;
#ifdef __cplusplus
_currn = new _TPrule_992;
#else
_currn = (_TPPrule_992) TreeNodeAlloc (sizeof (struct _TPrule_992));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_992;
_currn->_desc1 = (_TSPxAllocation) MkxAllocation (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_992: root of subtree no. 1 can not be made a xAllocation node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_992;
return ( (NODEPTR) _currn);
}/* Mkrule_992 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_991 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_991 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_991 _currn;
#ifdef __cplusplus
_currn = new _TPrule_991;
#else
_currn = (_TPPrule_991) TreeNodeAlloc (sizeof (struct _TPrule_991));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_991;
_currn->_desc1 = (_TSPxAllocateObject) MkxAllocateObject (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_991: root of subtree no. 1 can not be made a xAllocateObject node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_991;
return ( (NODEPTR) _currn);
}/* Mkrule_991 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_990 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_990 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_990 _currn;
#ifdef __cplusplus
_currn = new _TPrule_990;
#else
_currn = (_TPPrule_990) TreeNodeAlloc (sizeof (struct _TPrule_990));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_990;
_currn->_desc1 = (_TSPxAllocateObjectList) MkxAllocateObjectList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_990: root of subtree no. 1 can not be made a xAllocateObjectList node ", 0, _coordref);
_currn->_desc2 = (_TSPxAllocateObject) MkxAllocateObject (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_990: root of subtree no. 2 can not be made a xAllocateObject node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_990;
return ( (NODEPTR) _currn);
}/* Mkrule_990 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_989 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_989 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_989 _currn;
#ifdef __cplusplus
_currn = new _TPrule_989;
#else
_currn = (_TPPrule_989) TreeNodeAlloc (sizeof (struct _TPrule_989));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_989;
_currn->_desc1 = (_TSPxAllocateObject) MkxAllocateObject (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_989: root of subtree no. 1 can not be made a xAllocateObject node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_989;
return ( (NODEPTR) _currn);
}/* Mkrule_989 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_988 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_988 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_988 _currn;
#ifdef __cplusplus
_currn = new _TPrule_988;
#else
_currn = (_TPPrule_988) TreeNodeAlloc (sizeof (struct _TPrule_988));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_988;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_988: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxArrayAllocationList) MkxArrayAllocationList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_988: root of subtree no. 2 can not be made a xArrayAllocationList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_988;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_988 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_987 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_987 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_987 _currn;
#ifdef __cplusplus
_currn = new _TPrule_987;
#else
_currn = (_TPPrule_987) TreeNodeAlloc (sizeof (struct _TPrule_987));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_987;
_currn->_desc1 = (_TSPxLblDef) MkxLblDef (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_987: root of subtree no. 1 can not be made a xLblDef node ", 0, _coordref);
_currn->_desc2 = (_TSPxArrayAllocationList) MkxArrayAllocationList (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_987: root of subtree no. 2 can not be made a xArrayAllocationList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_987;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_987 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_986 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_986 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_986 _currn;
#ifdef __cplusplus
_currn = new _TPrule_986;
#else
_currn = (_TPPrule_986) TreeNodeAlloc (sizeof (struct _TPrule_986));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_986;
_currn->_desc1 = (_TSPxDecomp_Handle) MkxDecomp_Handle (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_986: root of subtree no. 1 can not be made a xDecomp_Handle node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_986;
return ( (NODEPTR) _currn);
}/* Mkrule_986 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_985 (POSITION *_coordref)
#else
NODEPTR Mkrule_985 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_985 _currn;
#ifdef __cplusplus
_currn = new _TPrule_985;
#else
_currn = (_TPPrule_985) TreeNodeAlloc (sizeof (struct _TPrule_985));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_985;
_SETCOORD(_currn)
_TERMACT_rule_985;
return ( (NODEPTR) _currn);
}/* Mkrule_985 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_984 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_984 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_984 _currn;
#ifdef __cplusplus
_currn = new _TPrule_984;
#else
_currn = (_TPPrule_984) TreeNodeAlloc (sizeof (struct _TPrule_984));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_984;
_currn->_desc1 = (_TSPVariableCouplet) MkVariableCouplet (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_984: root of subtree no. 1 can not be made a VariableCouplet node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_984;
return ( (NODEPTR) _currn);
}/* Mkrule_984 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_983 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_983 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_983 _currn;
#ifdef __cplusplus
_currn = new _TPrule_983;
#else
_currn = (_TPPrule_983) TreeNodeAlloc (sizeof (struct _TPrule_983));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_983;
_currn->_desc1 = (_TSPVariableCouplet) MkVariableCouplet (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_983: root of subtree no. 1 can not be made a VariableCouplet node ", 0, _coordref);
_currn->_desc2 = (_TSPVariableCouplets) MkVariableCouplets (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_983: root of subtree no. 2 can not be made a VariableCouplets node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_983;
return ( (NODEPTR) _currn);
}/* Mkrule_983 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_982 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_982 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_982 _currn;
#ifdef __cplusplus
_currn = new _TPrule_982;
#else
_currn = (_TPPrule_982) TreeNodeAlloc (sizeof (struct _TPrule_982));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_982;
_currn->_desc1 = (_TSPxDim) MkxDim (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_982: root of subtree no. 1 can not be made a xDim node ", 0, _coordref);
_currn->_desc2 = (_TSPToLocalOptions) MkToLocalOptions (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_982: root of subtree no. 2 can not be made a ToLocalOptions node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_982;
return ( (NODEPTR) _currn);
}/* Mkrule_982 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_981 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_981 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_981 _currn;
#ifdef __cplusplus
_currn = new _TPrule_981;
#else
_currn = (_TPPrule_981) TreeNodeAlloc (sizeof (struct _TPrule_981));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_981;
_currn->_desc1 = (_TSPxDim) MkxDim (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_981: root of subtree no. 1 can not be made a xDim node ", 0, _coordref);
_currn->_desc2 = (_TSPRefVariables) MkRefVariables (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_981: root of subtree no. 2 can not be made a RefVariables node ", 0, _coordref);
_currn->_desc3 = (_TSPToLocalOptions) MkToLocalOptions (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_981: root of subtree no. 3 can not be made a ToLocalOptions node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_981;
return ( (NODEPTR) _currn);
}/* Mkrule_981 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_980 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_980 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_980 _currn;
#ifdef __cplusplus
_currn = new _TPrule_980;
#else
_currn = (_TPPrule_980) TreeNodeAlloc (sizeof (struct _TPrule_980));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_980;
_currn->_desc1 = (_TSPToLocalOption) MkToLocalOption (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_980: root of subtree no. 1 can not be made a ToLocalOption node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_980;
return ( (NODEPTR) _currn);
}/* Mkrule_980 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_979 (POSITION *_coordref)
#else
NODEPTR Mkrule_979 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_979 _currn;
#ifdef __cplusplus
_currn = new _TPrule_979;
#else
_currn = (_TPPrule_979) TreeNodeAlloc (sizeof (struct _TPrule_979));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_979;
_SETCOORD(_currn)
_TERMACT_rule_979;
return ( (NODEPTR) _currn);
}/* Mkrule_979 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_978 (POSITION *_coordref)
#else
NODEPTR Mkrule_978 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_978 _currn;
#ifdef __cplusplus
_currn = new _TPrule_978;
#else
_currn = (_TPPrule_978) TreeNodeAlloc (sizeof (struct _TPrule_978));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_978;
_SETCOORD(_currn)
_TERMACT_rule_978;
return ( (NODEPTR) _currn);
}/* Mkrule_978 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_977 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_977 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_977 _currn;
#ifdef __cplusplus
_currn = new _TPrule_977;
#else
_currn = (_TPPrule_977) TreeNodeAlloc (sizeof (struct _TPrule_977));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_977;
_currn->_desc1 = (_TSPToLocalOption) MkToLocalOption (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_977: root of subtree no. 1 can not be made a ToLocalOption node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_977;
return ( (NODEPTR) _currn);
}/* Mkrule_977 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_976 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_976 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_976 _currn;
#ifdef __cplusplus
_currn = new _TPrule_976;
#else
_currn = (_TPPrule_976) TreeNodeAlloc (sizeof (struct _TPrule_976));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_976;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_976: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_976;
return ( (NODEPTR) _currn);
}/* Mkrule_976 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_975 (POSITION *_coordref)
#else
NODEPTR Mkrule_975 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_975 _currn;
#ifdef __cplusplus
_currn = new _TPrule_975;
#else
_currn = (_TPPrule_975) TreeNodeAlloc (sizeof (struct _TPrule_975));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_975;
_SETCOORD(_currn)
_TERMACT_rule_975;
return ( (NODEPTR) _currn);
}/* Mkrule_975 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_974 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_974 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_974 _currn;
#ifdef __cplusplus
_currn = new _TPrule_974;
#else
_currn = (_TPPrule_974) TreeNodeAlloc (sizeof (struct _TPrule_974));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_974;
_currn->_desc1 = (_TSPThreads) MkThreads (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_974: root of subtree no. 1 can not be made a Threads node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_974;
return ( (NODEPTR) _currn);
}/* Mkrule_974 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_973 (POSITION *_coordref)
#else
NODEPTR Mkrule_973 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_973 _currn;
#ifdef __cplusplus
_currn = new _TPrule_973;
#else
_currn = (_TPPrule_973) TreeNodeAlloc (sizeof (struct _TPrule_973));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_973;
_SETCOORD(_currn)
_TERMACT_rule_973;
return ( (NODEPTR) _currn);
}/* Mkrule_973 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_972 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_972 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_972 _currn;
#ifdef __cplusplus
_currn = new _TPrule_972;
#else
_currn = (_TPPrule_972) TreeNodeAlloc (sizeof (struct _TPrule_972));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_972;
_currn->_desc1 = (_TSPSpectralOption) MkSpectralOption (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_972: root of subtree no. 1 can not be made a SpectralOption node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_972;
return ( (NODEPTR) _currn);
}/* Mkrule_972 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_971 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_971 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_971 _currn;
#ifdef __cplusplus
_currn = new _TPrule_971;
#else
_currn = (_TPPrule_971) TreeNodeAlloc (sizeof (struct _TPrule_971));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_971;
_currn->_desc1 = (_TSPSpectralOption) MkSpectralOption (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_971: root of subtree no. 1 can not be made a SpectralOption node ", 0, _coordref);
_currn->_desc2 = (_TSPSpectralOption) MkSpectralOption (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_971: root of subtree no. 2 can not be made a SpectralOption node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_971;
return ( (NODEPTR) _currn);
}/* Mkrule_971 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_970 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_970 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_970 _currn;
#ifdef __cplusplus
_currn = new _TPrule_970;
#else
_currn = (_TPPrule_970) TreeNodeAlloc (sizeof (struct _TPrule_970));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_970;
_currn->_desc1 = (_TSPSpectralOption) MkSpectralOption (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_970: root of subtree no. 1 can not be made a SpectralOption node ", 0, _coordref);
_currn->_desc2 = (_TSPSpectralOption) MkSpectralOption (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_970: root of subtree no. 2 can not be made a SpectralOption node ", 0, _coordref);
_currn->_desc3 = (_TSPSpectralOption) MkSpectralOption (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_970: root of subtree no. 3 can not be made a SpectralOption node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_970;
return ( (NODEPTR) _currn);
}/* Mkrule_970 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_969 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_969 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_969 _currn;
#ifdef __cplusplus
_currn = new _TPrule_969;
#else
_currn = (_TPPrule_969) TreeNodeAlloc (sizeof (struct _TPrule_969));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_969;
_currn->_desc1 = (_TSPScrambleStrategy) MkScrambleStrategy (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_969: root of subtree no. 1 can not be made a ScrambleStrategy node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_969;
return ( (NODEPTR) _currn);
}/* Mkrule_969 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_968 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_968 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_968 _currn;
#ifdef __cplusplus
_currn = new _TPrule_968;
#else
_currn = (_TPPrule_968) TreeNodeAlloc (sizeof (struct _TPrule_968));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_968;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_968: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_968;
return ( (NODEPTR) _currn);
}/* Mkrule_968 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_967 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_967 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_967 _currn;
#ifdef __cplusplus
_currn = new _TPrule_967;
#else
_currn = (_TPPrule_967) TreeNodeAlloc (sizeof (struct _TPrule_967));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_967;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_967: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_967;
return ( (NODEPTR) _currn);
}/* Mkrule_967 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_966 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_966 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_966 _currn;
#ifdef __cplusplus
_currn = new _TPrule_966;
#else
_currn = (_TPPrule_966) TreeNodeAlloc (sizeof (struct _TPrule_966));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_966;
_SETCOORD(_currn)
_TERMACT_rule_966;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_966 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_965 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_965 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_965 _currn;
#ifdef __cplusplus
_currn = new _TPrule_965;
#else
_currn = (_TPPrule_965) TreeNodeAlloc (sizeof (struct _TPrule_965));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_965;
_currn->_desc1 = (_TSPRefVariable) MkRefVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_965: root of subtree no. 1 can not be made a RefVariable node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_965;
return ( (NODEPTR) _currn);
}/* Mkrule_965 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_964 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_964 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_964 _currn;
#ifdef __cplusplus
_currn = new _TPrule_964;
#else
_currn = (_TPPrule_964) TreeNodeAlloc (sizeof (struct _TPrule_964));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_964;
_currn->_desc1 = (_TSPRefVariable) MkRefVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_964: root of subtree no. 1 can not be made a RefVariable node ", 0, _coordref);
_currn->_desc2 = (_TSPRefVariables) MkRefVariables (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_964: root of subtree no. 2 can not be made a RefVariables node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_964;
return ( (NODEPTR) _currn);
}/* Mkrule_964 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_963 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_963 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_963 _currn;
#ifdef __cplusplus
_currn = new _TPrule_963;
#else
_currn = (_TPPrule_963) TreeNodeAlloc (sizeof (struct _TPrule_963));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_963;
_currn->_desc1 = (_TSPxName) MkxName (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_963: root of subtree no. 1 can not be made a xName node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_963;
return ( (NODEPTR) _currn);
}/* Mkrule_963 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_962 (POSITION *_coordref)
#else
NODEPTR Mkrule_962 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_962 _currn;
#ifdef __cplusplus
_currn = new _TPrule_962;
#else
_currn = (_TPPrule_962) TreeNodeAlloc (sizeof (struct _TPrule_962));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_962;
_SETCOORD(_currn)
_TERMACT_rule_962;
return ( (NODEPTR) _currn);
}/* Mkrule_962 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_961 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_961 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_961 _currn;
#ifdef __cplusplus
_currn = new _TPrule_961;
#else
_currn = (_TPPrule_961) TreeNodeAlloc (sizeof (struct _TPrule_961));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_961;
_currn->_desc1 = (_TSPxDecomp_Expr) MkxDecomp_Expr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_961: root of subtree no. 1 can not be made a xDecomp_Expr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_961;
return ( (NODEPTR) _currn);
}/* Mkrule_961 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_960 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_960 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_960 _currn;
#ifdef __cplusplus
_currn = new _TPrule_960;
#else
_currn = (_TPPrule_960) TreeNodeAlloc (sizeof (struct _TPrule_960));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_960;
_currn->_desc1 = (_TSPxDecomp_Expr) MkxDecomp_Expr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_960: root of subtree no. 1 can not be made a xDecomp_Expr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_960;
return ( (NODEPTR) _currn);
}/* Mkrule_960 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_959 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_959 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_959 _currn;
#ifdef __cplusplus
_currn = new _TPrule_959;
#else
_currn = (_TPPrule_959) TreeNodeAlloc (sizeof (struct _TPrule_959));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_959;
_currn->_desc1 = (_TSPxDecomp_Handle) MkxDecomp_Handle (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_959: root of subtree no. 1 can not be made a xDecomp_Handle node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_959;
return ( (NODEPTR) _currn);
}/* Mkrule_959 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_958 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_958 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_958 _currn;
#ifdef __cplusplus
_currn = new _TPrule_958;
#else
_currn = (_TPPrule_958) TreeNodeAlloc (sizeof (struct _TPrule_958));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_958;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_958: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_958;
return ( (NODEPTR) _currn);
}/* Mkrule_958 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_957 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_957 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_957 _currn;
#ifdef __cplusplus
_currn = new _TPrule_957;
#else
_currn = (_TPPrule_957) TreeNodeAlloc (sizeof (struct _TPrule_957));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_957;
_currn->_desc1 = (_TSPPackedOption) MkPackedOption (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_957: root of subtree no. 1 can not be made a PackedOption node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_957;
return ( (NODEPTR) _currn);
}/* Mkrule_957 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_956 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_956 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_956 _currn;
#ifdef __cplusplus
_currn = new _TPrule_956;
#else
_currn = (_TPPrule_956) TreeNodeAlloc (sizeof (struct _TPrule_956));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_956;
_currn->_desc1 = (_TSPPackedOption) MkPackedOption (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_956: root of subtree no. 1 can not be made a PackedOption node ", 0, _coordref);
_currn->_desc2 = (_TSPPackedOptions) MkPackedOptions (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_956: root of subtree no. 2 can not be made a PackedOptions node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_956;
return ( (NODEPTR) _currn);
}/* Mkrule_956 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_955 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_955 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_955 _currn;
#ifdef __cplusplus
_currn = new _TPrule_955;
#else
_currn = (_TPPrule_955) TreeNodeAlloc (sizeof (struct _TPrule_955));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_955;
_currn->_desc1 = (_TSPSpecialPackedPropertyRow) MkSpecialPackedPropertyRow (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_955: root of subtree no. 1 can not be made a SpecialPackedPropertyRow node ", 0, _coordref);
_currn->_desc2 = (_TSPSpecialPackedPropertyType) MkSpecialPackedPropertyType (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_955: root of subtree no. 2 can not be made a SpecialPackedPropertyType node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_955;
return ( (NODEPTR) _currn);
}/* Mkrule_955 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_954 (POSITION *_coordref)
#else
NODEPTR Mkrule_954 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_954 _currn;
#ifdef __cplusplus
_currn = new _TPrule_954;
#else
_currn = (_TPPrule_954) TreeNodeAlloc (sizeof (struct _TPrule_954));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_954;
_SETCOORD(_currn)
_TERMACT_rule_954;
return ( (NODEPTR) _currn);
}/* Mkrule_954 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_953 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_953 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_953 _currn;
#ifdef __cplusplus
_currn = new _TPrule_953;
#else
_currn = (_TPPrule_953) TreeNodeAlloc (sizeof (struct _TPrule_953));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_953;
_currn->_desc1 = (_TSPNumBlocks) MkNumBlocks (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_953: root of subtree no. 1 can not be made a NumBlocks node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_953;
return ( (NODEPTR) _currn);
}/* Mkrule_953 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_952 (POSITION *_coordref)
#else
NODEPTR Mkrule_952 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_952 _currn;
#ifdef __cplusplus
_currn = new _TPrule_952;
#else
_currn = (_TPPrule_952) TreeNodeAlloc (sizeof (struct _TPrule_952));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_952;
_SETCOORD(_currn)
_TERMACT_rule_952;
return ( (NODEPTR) _currn);
}/* Mkrule_952 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_951 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_951 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_951 _currn;
#ifdef __cplusplus
_currn = new _TPrule_951;
#else
_currn = (_TPPrule_951) TreeNodeAlloc (sizeof (struct _TPrule_951));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_951;
_currn->_desc1 = (_TSPParam) MkParam (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_951: root of subtree no. 1 can not be made a Param node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_951;
return ( (NODEPTR) _currn);
}/* Mkrule_951 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_950 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_950 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_950 _currn;
#ifdef __cplusplus
_currn = new _TPrule_950;
#else
_currn = (_TPPrule_950) TreeNodeAlloc (sizeof (struct _TPrule_950));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_950;
_currn->_desc1 = (_TSPxExpr) MkxExpr (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_950: root of subtree no. 1 can not be made a xExpr node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_950;
return ( (NODEPTR) _currn);
}/* Mkrule_950 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_949 (POSITION *_coordref)
#else
NODEPTR Mkrule_949 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_949 _currn;
#ifdef __cplusplus
_currn = new _TPrule_949;
#else
_currn = (_TPPrule_949) TreeNodeAlloc (sizeof (struct _TPrule_949));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_949;
_SETCOORD(_currn)
_TERMACT_rule_949;
return ( (NODEPTR) _currn);
}/* Mkrule_949 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_948 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_948 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_948 _currn;
#ifdef __cplusplus
_currn = new _TPrule_948;
#else
_currn = (_TPPrule_948) TreeNodeAlloc (sizeof (struct _TPrule_948));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_948;
_currn->_desc1 = (_TSPxSectionSubscriptList) MkxSectionSubscriptList (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_948: root of subtree no. 1 can not be made a xSectionSubscriptList node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_948;
return ( (NODEPTR) _currn);
}/* Mkrule_948 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_947 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_947 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_947 _currn;
#ifdef __cplusplus
_currn = new _TPrule_947;
#else
_currn = (_TPPrule_947) TreeNodeAlloc (sizeof (struct _TPrule_947));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_947;
_currn->_desc1 = (_TSPxRelHandle) MkxRelHandle (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_947: root of subtree no. 1 can not be made a xRelHandle node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_947;
return ( (NODEPTR) _currn);
}/* Mkrule_947 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_946 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_946 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_946 _currn;
#ifdef __cplusplus
_currn = new _TPrule_946;
#else
_currn = (_TPPrule_946) TreeNodeAlloc (sizeof (struct _TPrule_946));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_946;
_SETCOORD(_currn)
_TERMACT_rule_946;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_946 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_945 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_945 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_945 _currn;
#ifdef __cplusplus
_currn = new _TPrule_945;
#else
_currn = (_TPPrule_945) TreeNodeAlloc (sizeof (struct _TPrule_945));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_945;
_currn->_desc1 = (_TSPoDecomp) MkoDecomp (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_945: root of subtree no. 1 can not be made a oDecomp node ", 0, _coordref);
_currn->_desc2 = (_TSPVariableCouplets) MkVariableCouplets (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_945: root of subtree no. 2 can not be made a VariableCouplets node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_945;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_945 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_944 (POSITION *_coordref)
#else
NODEPTR Mkrule_944 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_944 _currn;
#ifdef __cplusplus
_currn = new _TPrule_944;
#else
_currn = (_TPPrule_944) TreeNodeAlloc (sizeof (struct _TPrule_944));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_944;
_SETCOORD(_currn)
_TERMACT_rule_944;
return ( (NODEPTR) _currn);
}/* Mkrule_944 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_943 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_943 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_943 _currn;
#ifdef __cplusplus
_currn = new _TPrule_943;
#else
_currn = (_TPPrule_943) TreeNodeAlloc (sizeof (struct _TPrule_943));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_943;
_currn->_desc1 = (_TSPHaloVariable) MkHaloVariable (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_943: root of subtree no. 1 can not be made a HaloVariable node ", 0, _coordref);
_currn->_desc2 = (_TSPHaloVariable) MkHaloVariable (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_943: root of subtree no. 2 can not be made a HaloVariable node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_943;
return ( (NODEPTR) _currn);
}/* Mkrule_943 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_942 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_942 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_942 _currn;
#ifdef __cplusplus
_currn = new _TPrule_942;
#else
_currn = (_TPPrule_942) TreeNodeAlloc (sizeof (struct _TPrule_942));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_942;
_currn->_desc1 = (_TSPxParams) MkxParams (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_942: root of subtree no. 1 can not be made a xParams node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_942;
return ( (NODEPTR) _currn);
}/* Mkrule_942 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_941 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_941 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_941 _currn;
#ifdef __cplusplus
_currn = new _TPrule_941;
#else
_currn = (_TPPrule_941) TreeNodeAlloc (sizeof (struct _TPrule_941));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_941;
_currn->_desc1 = (_TSPHaloThick) MkHaloThick (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_941: root of subtree no. 1 can not be made a HaloThick node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_941;
return ( (NODEPTR) _currn);
}/* Mkrule_941 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_940 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_940 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_940 _currn;
#ifdef __cplusplus
_currn = new _TPrule_940;
#else
_currn = (_TPPrule_940) TreeNodeAlloc (sizeof (struct _TPrule_940));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_940;
_currn->_desc1 = (_TSPHaloThick) MkHaloThick (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_940: root of subtree no. 1 can not be made a HaloThick node ", 0, _coordref);
_currn->_desc2 = (_TSPHaloThick) MkHaloThick (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_940: root of subtree no. 2 can not be made a HaloThick node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_940;
return ( (NODEPTR) _currn);
}/* Mkrule_940 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_939 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_939 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_939 _currn;
#ifdef __cplusplus
_currn = new _TPrule_939;
#else
_currn = (_TPPrule_939) TreeNodeAlloc (sizeof (struct _TPrule_939));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_939;
_currn->_desc1 = (_TSPHaloThick) MkHaloThick (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_939: root of subtree no. 1 can not be made a HaloThick node ", 0, _coordref);
_currn->_desc2 = (_TSPHaloThick) MkHaloThick (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_939: root of subtree no. 2 can not be made a HaloThick node ", 0, _coordref);
_currn->_desc3 = (_TSPHaloThick) MkHaloThick (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_939: root of subtree no. 3 can not be made a HaloThick node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_939;
return ( (NODEPTR) _currn);
}/* Mkrule_939 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_938 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_938 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_938 _currn;
#ifdef __cplusplus
_currn = new _TPrule_938;
#else
_currn = (_TPPrule_938) TreeNodeAlloc (sizeof (struct _TPrule_938));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_938;
_currn->_desc1 = (_TSPxExchThick) MkxExchThick (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_938: root of subtree no. 1 can not be made a xExchThick node ", 0, _coordref);
_currn->_desc2 = (_TSPxExchThick) MkxExchThick (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_938: root of subtree no. 2 can not be made a xExchThick node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_938;
return ( (NODEPTR) _currn);
}/* Mkrule_938 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_937 (POSITION *_coordref)
#else
NODEPTR Mkrule_937 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_937 _currn;
#ifdef __cplusplus
_currn = new _TPrule_937;
#else
_currn = (_TPPrule_937) TreeNodeAlloc (sizeof (struct _TPrule_937));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_937;
_SETCOORD(_currn)
_TERMACT_rule_937;
return ( (NODEPTR) _currn);
}/* Mkrule_937 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_936 (POSITION *_coordref)
#else
NODEPTR Mkrule_936 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_936 _currn;
#ifdef __cplusplus
_currn = new _TPrule_936;
#else
_currn = (_TPPrule_936) TreeNodeAlloc (sizeof (struct _TPrule_936));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_936;
_SETCOORD(_currn)
_TERMACT_rule_936;
return ( (NODEPTR) _currn);
}/* Mkrule_936 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_935 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_935 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_935 _currn;
#ifdef __cplusplus
_currn = new _TPrule_935;
#else
_currn = (_TPPrule_935) TreeNodeAlloc (sizeof (struct _TPrule_935));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_935;
_currn->_desc1 = (_TSPCornerDepth) MkCornerDepth (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_935: root of subtree no. 1 can not be made a CornerDepth node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_935;
return ( (NODEPTR) _currn);
}/* Mkrule_935 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_934 (POSITION *_coordref)
#else
NODEPTR Mkrule_934 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_934 _currn;
#ifdef __cplusplus
_currn = new _TPrule_934;
#else
_currn = (_TPPrule_934) TreeNodeAlloc (sizeof (struct _TPrule_934));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_934;
_SETCOORD(_currn)
_TERMACT_rule_934;
return ( (NODEPTR) _currn);
}/* Mkrule_934 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_933 (POSITION *_coordref)
#else
NODEPTR Mkrule_933 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_933 _currn;
#ifdef __cplusplus
_currn = new _TPrule_933;
#else
_currn = (_TPPrule_933) TreeNodeAlloc (sizeof (struct _TPrule_933));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_933;
_SETCOORD(_currn)
_TERMACT_rule_933;
return ( (NODEPTR) _currn);
}/* Mkrule_933 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_932 (POSITION *_coordref)
#else
NODEPTR Mkrule_932 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_932 _currn;
#ifdef __cplusplus
_currn = new _TPrule_932;
#else
_currn = (_TPPrule_932) TreeNodeAlloc (sizeof (struct _TPrule_932));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_932;
_SETCOORD(_currn)
_TERMACT_rule_932;
return ( (NODEPTR) _currn);
}/* Mkrule_932 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_931 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_931 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_931 _currn;
#ifdef __cplusplus
_currn = new _TPrule_931;
#else
_currn = (_TPPrule_931) TreeNodeAlloc (sizeof (struct _TPrule_931));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_931;
_currn->_desc1 = (_TSPHaloVariables) MkHaloVariables (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_931: root of subtree no. 1 can not be made a HaloVariables node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_931;
return ( (NODEPTR) _currn);
}/* Mkrule_931 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_930 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_930 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_930 _currn;
#ifdef __cplusplus
_currn = new _TPrule_930;
#else
_currn = (_TPPrule_930) TreeNodeAlloc (sizeof (struct _TPrule_930));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_930;
_currn->_desc1 = (_TSPHaloVariables) MkHaloVariables (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_930: root of subtree no. 1 can not be made a HaloVariables node ", 0, _coordref);
_currn->_desc2 = (_TSPHaloVariables) MkHaloVariables (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_930: root of subtree no. 2 can not be made a HaloVariables node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_930;
return ( (NODEPTR) _currn);
}/* Mkrule_930 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_929 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_929 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_929 _currn;
#ifdef __cplusplus
_currn = new _TPrule_929;
#else
_currn = (_TPPrule_929) TreeNodeAlloc (sizeof (struct _TPrule_929));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_929;
_currn->_desc1 = (_TSPHaloVariables) MkHaloVariables (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_929: root of subtree no. 1 can not be made a HaloVariables node ", 0, _coordref);
_currn->_desc2 = (_TSPHaloVariables) MkHaloVariables (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_929: root of subtree no. 2 can not be made a HaloVariables node ", 0, _coordref);
_currn->_desc3 = (_TSPHaloVariables) MkHaloVariables (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_929: root of subtree no. 3 can not be made a HaloVariables node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_929;
return ( (NODEPTR) _currn);
}/* Mkrule_929 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_928 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_928 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_928 _currn;
#ifdef __cplusplus
_currn = new _TPrule_928;
#else
_currn = (_TPPrule_928) TreeNodeAlloc (sizeof (struct _TPrule_928));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_928;
_SETCOORD(_currn)
_TERMACT_rule_928;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_928 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_927 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_927 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_927 _currn;
#ifdef __cplusplus
_currn = new _TPrule_927;
#else
_currn = (_TPPrule_927) TreeNodeAlloc (sizeof (struct _TPrule_927));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_927;
_SETCOORD(_currn)
_TERMACT_rule_927;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_927 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_926 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, int _TERM1)
#else
NODEPTR Mkrule_926 (_coordref,_desc1,_desc2, _TERM1)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	int _TERM1;
#endif
{	_TPPrule_926 _currn;
#ifdef __cplusplus
_currn = new _TPrule_926;
#else
_currn = (_TPPrule_926) TreeNodeAlloc (sizeof (struct _TPrule_926));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_926;
_currn->_desc1 = (_TSPoDecomp) MkoDecomp (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_926: root of subtree no. 1 can not be made a oDecomp node ", 0, _coordref);
_currn->_desc2 = (_TSPVariableCouplets) MkVariableCouplets (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_926: root of subtree no. 2 can not be made a VariableCouplets node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_926;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xEOS", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_926 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_925 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_925 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_925 _currn;
#ifdef __cplusplus
_currn = new _TPrule_925;
#else
_currn = (_TPPrule_925) TreeNodeAlloc (sizeof (struct _TPrule_925));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_925;
_currn->_desc1 = (_TSPDim) MkDim (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_925: root of subtree no. 1 can not be made a Dim node ", 0, _coordref);
_currn->_desc2 = (_TSPThreadRange) MkThreadRange (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_925: root of subtree no. 2 can not be made a ThreadRange node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_925;
return ( (NODEPTR) _currn);
}/* Mkrule_925 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_924 (POSITION *_coordref)
#else
NODEPTR Mkrule_924 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_924 _currn;
#ifdef __cplusplus
_currn = new _TPrule_924;
#else
_currn = (_TPPrule_924) TreeNodeAlloc (sizeof (struct _TPrule_924));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_924;
_SETCOORD(_currn)
_TERMACT_rule_924;
return ( (NODEPTR) _currn);
}/* Mkrule_924 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_923 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_923 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_923 _currn;
#ifdef __cplusplus
_currn = new _TPrule_923;
#else
_currn = (_TPPrule_923) TreeNodeAlloc (sizeof (struct _TPrule_923));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_923;
_SETCOORD(_currn)
_TERMACT_rule_923;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_923 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_922 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_922 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_922 _currn;
#ifdef __cplusplus
_currn = new _TPrule_922;
#else
_currn = (_TPPrule_922) TreeNodeAlloc (sizeof (struct _TPrule_922));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_922;
_currn->_desc1 = (_TSPUnstructuredOption) MkUnstructuredOption (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_922: root of subtree no. 1 can not be made a UnstructuredOption node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_922;
return ( (NODEPTR) _currn);
}/* Mkrule_922 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_921 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_921 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_921 _currn;
#ifdef __cplusplus
_currn = new _TPrule_921;
#else
_currn = (_TPPrule_921) TreeNodeAlloc (sizeof (struct _TPrule_921));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_921;
_currn->_desc1 = (_TSPAlignedOption) MkAlignedOption (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_921: root of subtree no. 1 can not be made a AlignedOption node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_921;
return ( (NODEPTR) _currn);
}/* Mkrule_921 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_920 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_920 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_920 _currn;
#ifdef __cplusplus
_currn = new _TPrule_920;
#else
_currn = (_TPPrule_920) TreeNodeAlloc (sizeof (struct _TPrule_920));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_920;
_currn->_desc1 = (_TSPDecompLowBound) MkDecompLowBound (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_920: root of subtree no. 1 can not be made a DecompLowBound node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_920;
return ( (NODEPTR) _currn);
}/* Mkrule_920 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_919 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_919 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_919 _currn;
#ifdef __cplusplus
_currn = new _TPrule_919;
#else
_currn = (_TPPrule_919) TreeNodeAlloc (sizeof (struct _TPrule_919));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_919;
_currn->_desc1 = (_TSPDecompLowBound) MkDecompLowBound (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_919: root of subtree no. 1 can not be made a DecompLowBound node ", 0, _coordref);
_currn->_desc2 = (_TSPDecompLowBound) MkDecompLowBound (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_919: root of subtree no. 2 can not be made a DecompLowBound node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_919;
return ( (NODEPTR) _currn);
}/* Mkrule_919 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_918 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_918 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_918 _currn;
#ifdef __cplusplus
_currn = new _TPrule_918;
#else
_currn = (_TPPrule_918) TreeNodeAlloc (sizeof (struct _TPrule_918));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_918;
_currn->_desc1 = (_TSPDecompLowBound) MkDecompLowBound (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_918: root of subtree no. 1 can not be made a DecompLowBound node ", 0, _coordref);
_currn->_desc2 = (_TSPDecompLowBound) MkDecompLowBound (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_918: root of subtree no. 2 can not be made a DecompLowBound node ", 0, _coordref);
_currn->_desc3 = (_TSPDecompLowBound) MkDecompLowBound (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_918: root of subtree no. 3 can not be made a DecompLowBound node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_918;
return ( (NODEPTR) _currn);
}/* Mkrule_918 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_917 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_917 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_917 _currn;
#ifdef __cplusplus
_currn = new _TPrule_917;
#else
_currn = (_TPPrule_917) TreeNodeAlloc (sizeof (struct _TPrule_917));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_917;
_currn->_desc1 = (_TSPxParams) MkxParams (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_917: root of subtree no. 1 can not be made a xParams node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_917;
return ( (NODEPTR) _currn);
}/* Mkrule_917 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_916 (POSITION *_coordref)
#else
NODEPTR Mkrule_916 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_916 _currn;
#ifdef __cplusplus
_currn = new _TPrule_916;
#else
_currn = (_TPPrule_916) TreeNodeAlloc (sizeof (struct _TPrule_916));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_916;
_SETCOORD(_currn)
_TERMACT_rule_916;
return ( (NODEPTR) _currn);
}/* Mkrule_916 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_915 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_915 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_915 _currn;
#ifdef __cplusplus
_currn = new _TPrule_915;
#else
_currn = (_TPPrule_915) TreeNodeAlloc (sizeof (struct _TPrule_915));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_915;
_currn->_desc1 = (_TSPPackedOptions) MkPackedOptions (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_915: root of subtree no. 1 can not be made a PackedOptions node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_915;
return ( (NODEPTR) _currn);
}/* Mkrule_915 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_914 (POSITION *_coordref)
#else
NODEPTR Mkrule_914 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_914 _currn;
#ifdef __cplusplus
_currn = new _TPrule_914;
#else
_currn = (_TPPrule_914) TreeNodeAlloc (sizeof (struct _TPrule_914));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_914;
_SETCOORD(_currn)
_TERMACT_rule_914;
return ( (NODEPTR) _currn);
}/* Mkrule_914 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_913 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_913 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_913 _currn;
#ifdef __cplusplus
_currn = new _TPrule_913;
#else
_currn = (_TPPrule_913) TreeNodeAlloc (sizeof (struct _TPrule_913));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_913;
_currn->_desc1 = (_TSPSpectralOptions) MkSpectralOptions (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_913: root of subtree no. 1 can not be made a SpectralOptions node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_913;
return ( (NODEPTR) _currn);
}/* Mkrule_913 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_912 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_912 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_912 _currn;
#ifdef __cplusplus
_currn = new _TPrule_912;
#else
_currn = (_TPPrule_912) TreeNodeAlloc (sizeof (struct _TPrule_912));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_912;
_currn->_desc1 = (_TSPBoundaryTypes) MkBoundaryTypes (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_912: root of subtree no. 1 can not be made a BoundaryTypes node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_912;
return ( (NODEPTR) _currn);
}/* Mkrule_912 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_911 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_911 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_911 _currn;
#ifdef __cplusplus
_currn = new _TPrule_911;
#else
_currn = (_TPPrule_911) TreeNodeAlloc (sizeof (struct _TPrule_911));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_911;
_SETCOORD(_currn)
_TERMACT_rule_911;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIdent", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_911 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_910 (POSITION *_coordref, int _TERM1)
#else
NODEPTR Mkrule_910 (_coordref, _TERM1)
	POSITION *_coordref;
	int _TERM1;
#endif
{	_TPPrule_910 _currn;
#ifdef __cplusplus
_currn = new _TPrule_910;
#else
_currn = (_TPPrule_910) TreeNodeAlloc (sizeof (struct _TPrule_910));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_910;
_SETCOORD(_currn)
_TERMACT_rule_910;
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
_dapto_term_int((_currn)->_uid, "xIcon", _TERM1);
#endif

return ( (NODEPTR) _currn);
}/* Mkrule_910 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_909 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_909 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_909 _currn;
#ifdef __cplusplus
_currn = new _TPrule_909;
#else
_currn = (_TPPrule_909) TreeNodeAlloc (sizeof (struct _TPrule_909));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_909;
_currn->_desc1 = (_TSPBoundaryType) MkBoundaryType (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_909: root of subtree no. 1 can not be made a BoundaryType node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_909;
return ( (NODEPTR) _currn);
}/* Mkrule_909 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_908 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_908 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_908 _currn;
#ifdef __cplusplus
_currn = new _TPrule_908;
#else
_currn = (_TPPrule_908) TreeNodeAlloc (sizeof (struct _TPrule_908));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_908;
_currn->_desc1 = (_TSPBoundaryType) MkBoundaryType (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_908: root of subtree no. 1 can not be made a BoundaryType node ", 0, _coordref);
_currn->_desc2 = (_TSPBoundaryType) MkBoundaryType (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_908: root of subtree no. 2 can not be made a BoundaryType node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_908;
return ( (NODEPTR) _currn);
}/* Mkrule_908 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_907 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2, NODEPTR _desc3)
#else
NODEPTR Mkrule_907 (_coordref,_desc1,_desc2,_desc3)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
	NODEPTR _desc3;
#endif
{	_TPPrule_907 _currn;
#ifdef __cplusplus
_currn = new _TPrule_907;
#else
_currn = (_TPPrule_907) TreeNodeAlloc (sizeof (struct _TPrule_907));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_907;
_currn->_desc1 = (_TSPBoundaryType) MkBoundaryType (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_907: root of subtree no. 1 can not be made a BoundaryType node ", 0, _coordref);
_currn->_desc2 = (_TSPBoundaryType) MkBoundaryType (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_907: root of subtree no. 2 can not be made a BoundaryType node ", 0, _coordref);
_currn->_desc3 = (_TSPBoundaryType) MkBoundaryType (_coordref, _desc3);	
if (((NODEPTR)_currn->_desc3) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_907: root of subtree no. 3 can not be made a BoundaryType node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_907;
return ( (NODEPTR) _currn);
}/* Mkrule_907 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_906 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_906 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_906 _currn;
#ifdef __cplusplus
_currn = new _TPrule_906;
#else
_currn = (_TPPrule_906) TreeNodeAlloc (sizeof (struct _TPrule_906));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_906;
_currn->_desc1 = (_TSPxPeriodicOptions) MkxPeriodicOptions (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_906: root of subtree no. 1 can not be made a xPeriodicOptions node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_906;
return ( (NODEPTR) _currn);
}/* Mkrule_906 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_905 (POSITION *_coordref)
#else
NODEPTR Mkrule_905 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_905 _currn;
#ifdef __cplusplus
_currn = new _TPrule_905;
#else
_currn = (_TPPrule_905) TreeNodeAlloc (sizeof (struct _TPrule_905));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_905;
_SETCOORD(_currn)
_TERMACT_rule_905;
return ( (NODEPTR) _currn);
}/* Mkrule_905 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_904 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_904 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_904 _currn;
#ifdef __cplusplus
_currn = new _TPrule_904;
#else
_currn = (_TPPrule_904) TreeNodeAlloc (sizeof (struct _TPrule_904));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_904;
_currn->_desc1 = (_TSPBlocks) MkBlocks (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_904: root of subtree no. 1 can not be made a Blocks node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_904;
return ( (NODEPTR) _currn);
}/* Mkrule_904 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_903 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_903 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_903 _currn;
#ifdef __cplusplus
_currn = new _TPrule_903;
#else
_currn = (_TPPrule_903) TreeNodeAlloc (sizeof (struct _TPrule_903));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_903;
_currn->_desc1 = (_TSPAlignedDecomp) MkAlignedDecomp (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_903: root of subtree no. 1 can not be made a AlignedDecomp node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_903;
return ( (NODEPTR) _currn);
}/* Mkrule_903 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_902 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_902 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_902 _currn;
#ifdef __cplusplus
_currn = new _TPrule_902;
#else
_currn = (_TPPrule_902) TreeNodeAlloc (sizeof (struct _TPrule_902));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_902;
_currn->_desc1 = (_TSPxDecomp_Handle) MkxDecomp_Handle (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_902: root of subtree no. 1 can not be made a xDecomp_Handle node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_902;
return ( (NODEPTR) _currn);
}/* Mkrule_902 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_901 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_901 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_901 _currn;
#ifdef __cplusplus
_currn = new _TPrule_901;
#else
_currn = (_TPPrule_901) TreeNodeAlloc (sizeof (struct _TPrule_901));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_901;
_currn->_desc1 = (_TSPAccDoTypes) MkAccDoTypes (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_901: root of subtree no. 1 can not be made a AccDoTypes node ", 0, _coordref);
_currn->_desc2 = (_TSPAccDoType) MkAccDoType (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_901: root of subtree no. 2 can not be made a AccDoType node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_901;
return ( (NODEPTR) _currn);
}/* Mkrule_901 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_900 (POSITION *_coordref, NODEPTR _desc1)
#else
NODEPTR Mkrule_900 (_coordref,_desc1)
	POSITION *_coordref;
	NODEPTR _desc1;
#endif
{	_TPPrule_900 _currn;
#ifdef __cplusplus
_currn = new _TPrule_900;
#else
_currn = (_TPPrule_900) TreeNodeAlloc (sizeof (struct _TPrule_900));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_900;
_currn->_desc1 = (_TSPAccDoType) MkAccDoType (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_900: root of subtree no. 1 can not be made a AccDoType node ", 0, _coordref);
_COPYCOORD(_currn)
_TERMACT_rule_900;
return ( (NODEPTR) _currn);
}/* Mkrule_900 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_899 (POSITION *_coordref, NODEPTR _desc1, NODEPTR _desc2)
#else
NODEPTR Mkrule_899 (_coordref,_desc1,_desc2)
	POSITION *_coordref;
	NODEPTR _desc1;
	NODEPTR _desc2;
#endif
{	_TPPrule_899 _currn;
#ifdef __cplusplus
_currn = new _TPrule_899;
#else
_currn = (_TPPrule_899) TreeNodeAlloc (sizeof (struct _TPrule_899));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_899;
_currn->_desc1 = (_TSPAccDoFunction) MkAccDoFunction (_coordref, _desc1);	
if (((NODEPTR)_currn->_desc1) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_899: root of subtree no. 1 can not be made a AccDoFunction node ", 0, _coordref);
_currn->_desc2 = (_TSPDoFunctionWidth) MkDoFunctionWidth (_coordref, _desc2);	
if (((NODEPTR)_currn->_desc2) == NULLNODEPTR)	
	message (DEADLY, "RULE rule_899: root of subtree no. 2 can not be made a DoFunctionWidth node ", 0, _coordref);
_SETCOORD(_currn)
_TERMACT_rule_899;
return ( (NODEPTR) _currn);
}/* Mkrule_899 */

#if defined(__STDC__) || defined(__cplusplus)
NODEPTR Mkrule_898 (POSITION *_coordref)
#else
NODEPTR Mkrule_898 (_coordref)
	POSITION *_coordref;
#endif
{	_TPPrule_898 _currn;
#ifdef __cplusplus
_currn = new _TPrule_898;
#else
_currn = (_TPPrule_898) TreeNodeAlloc (sizeof (struct _TPrule_898));
#endif
#ifdef MONITOR
_currn->_uid=MONTblStackSize; MONTblStackPush(((NODEPTR)_currn));
#endif
_currn->_prod = RULErule_898;
_SETCOORD(_currn)
_TERMACT_rule_898;
return ( (NODEPTR) _currn);
}/* Mkrule_898 */
