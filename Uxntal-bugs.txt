0016        oneByte = .false. 
0002        tokenLabel = getTokenLabel(token)
0004        tokenVal = getTokenVal(token)
0006        tokenExtBits = 0
0015        cs = ''
0002        tokenLabel
000c        id
000e        sidx
0012        slen
000a        ii

* An empty string should be a string { 0000 } STH2r, not #00
* The allocation for cs on the stack should be #0040 but is only #0001
*             do i=sidx,sidx+slen-1_2
                ii = i-sidx+1_2
                
is not correct: the expression for ii gets 0008 instead of i                

.fp LDZ2 #0008 ADD2 LDA2 
.fp LDZ2 #000e ADD2 LDA2  SUB2 #0001  ADD2 DUP2 print-int nl 
.fp LDZ2 #000a ADD2 STA2 ( scalar )

should be

;decodeTokenStr_i LDA2 
.fp LDZ2 #000e ADD2 LDA2  SUB2 #0001  ADD2
.fp LDZ2 #000a ADD2 STA2

When copying a substr we must make sure the length is set 

.fp LDZ2 #0015 ADD2 .fp LDZ2 #000a ADD2 LDA2 INC2 ADD2 STA (  WV20240723: WRONG? )  ( COPY SUBSTR )
.fp LDZ2 #000a ADD2 LDA2 #0001  ADD2 .fp LDZ2 #000a ADD2 STA2 ( scalar )
.fp LDZ2 #000a ADD2 LDA2 #0001 SUB2 .fp LDZ2 #0015 ADD2 STA2

 The root cause is that when we allocate a string on the stack we should write its length!
 And we should do this for arrays as well, because otherwise SIZE does not work; to support SHAPE as well we'd need to tag the dims onto the end which we can do once we know the size. So arrays and strings should both have a 2-byte field. 


